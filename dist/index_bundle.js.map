{"version":3,"sources":["webpack://main/webpack/universalModuleDefinition","webpack://main/./node_modules/@assemblyscript/loader/index.js","webpack://main/./build/untouched.wasm","webpack://main/./src/common/Commands.ts","webpack://main/./src/common/GroupType.ts","webpack://main/./src/common/PipelineType.ts","webpack://main/./src/common/ResourceType.ts","webpack://main/./src/ts/AppBindings.ts","webpack://main/./src/ts/core/GameManager.ts","webpack://main/./src/ts/core/InputManager.ts","webpack://main/./src/ts/core/RenderQueueManager.ts","webpack://main/./src/ts/core/Texture.ts","webpack://main/./src/ts/core/Utils.ts","webpack://main/./src/ts/core/pipelines/DefaultPipelineDescriptor.ts","webpack://main/./src/ts/core/pipelines/Pipeline.ts","webpack://main/./src/ts/core/pipelines/debug-pipeline/index.ts","webpack://main/./src/ts/core/pipelines/resources/LightingResource.ts","webpack://main/./src/ts/core/pipelines/resources/MaterialResource.ts","webpack://main/./src/ts/core/pipelines/resources/MemoryUtils.ts","webpack://main/./src/ts/core/pipelines/resources/PipelineResourceInstance.ts","webpack://main/./src/ts/core/pipelines/resources/PipelineResourceTemplate.ts","webpack://main/./src/ts/core/pipelines/resources/TextureResource.ts","webpack://main/./src/ts/core/pipelines/resources/TransformResource.ts","webpack://main/./src/ts/core/pipelines/shader-lib/MathFunctions.ts","webpack://main/./src/ts/core/pipelines/shader-lib/Utils.ts","webpack://main/webpack/bootstrap","webpack://main/webpack/runtime/define property getters","webpack://main/webpack/runtime/global","webpack://main/webpack/runtime/hasOwnProperty shorthand","webpack://main/webpack/runtime/make namespace object","webpack://main/webpack/runtime/publicPath","webpack://main/./src/ts/index.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C;AACA,wDAAwD;AACxD,0BAA0B,uBAAuB,MAAM,wBAAwB,GAAG,KAAK,GAAG,KAAK;AAC/F;AACA;AACA;AACA,0BAA0B,uBAAuB,EAAE,aAAa,EAAE,4BAA4B;AAC9F;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,gCAAgC;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;;AAEA;AACA;AACA;AACA,wFAAwF,GAAG,UAAU,KAAK;AAC1G;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D;;AAEA;AACA;AACA,gEAAgE;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,uDAAuD,IAAI;AAC3D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,KAAK;AACjC,4BAA4B,KAAK;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACO,+CAA+C;AACtD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACO,6CAA6C;AACpD;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACO,wDAAwD;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACO,+CAA+C;AACtD;AACA,iBAAiB,6CAA6C;AAC9D,yEAAyE,YAAY;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA,gDAAgD,UAAU,oCAAoC,EAAE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B,EAAE;AAChD,wBAAwB,2BAA2B,EAAE;AACrD;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW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","file":"index_bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"main\"] = factory();\n\telse\n\t\troot[\"main\"] = factory();\n})(self, function() {\nreturn ","// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\n// const ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst STATICARRAY = 1 << 2;\n// const SET = 1 << 3;\n// const MAP = 1 << 4;\nconst VAL_ALIGN_OFFSET = 6;\n// const VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 11;\nconst VAL_FLOAT = 1 << 12;\n// const VAL_NULLABLE = 1 << 13;\nconst VAL_MANAGED = 1 << 14;\n// const KEY_ALIGN_OFFSET = 15;\n// const KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\n// const KEY_SIGNED = 1 << 20;\n// const KEY_FLOAT = 1 << 21;\n// const KEY_NULLABLE = 1 << 22;\n// const KEY_MANAGED = 1 << 23;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\n\nconst STRING_DECODE_THRESHOLD = 32;\nconst decoder = new TextDecoder(\"utf-16le\");\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const len = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2] >>> 1;\n  const arr = new Uint16Array(buffer, ptr, len);\n  if (len <= STRING_DECODE_THRESHOLD) {\n    return String.fromCharCode.apply(String, arr);\n  }\n  return decoder.decode(arr);\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const extendedExports = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(msg, file, line, colm) {\n    const memory = extendedExports.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(`abort: ${getString(memory, msg)} at ${getString(memory, file)}:${line}:${colm}`);\n  };\n  env.trace = env.trace || function trace(msg, n, ...args) {\n    const memory = extendedExports.memory || env.memory;\n    console.log(`trace: ${getString(memory, msg)}${n ? \" \" : \"\"}${args.slice(0, n).join(\", \")}`);\n  };\n  env.seed = env.seed || Date.now;\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return extendedExports;\n}\n\nconst E_NOEXPORTRUNTIME = \"Operation requires compiling with --exportRuntime\";\nconst F_NOEXPORTRUNTIME = function() { throw Error(E_NOEXPORTRUNTIME); };\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(extendedExports, instance) {\n  const exports = instance.exports;\n  const memory = exports.memory;\n  const table = exports.table;\n  const __new = exports.__new || F_NOEXPORTRUNTIME;\n  const __pin = exports.__pin || F_NOEXPORTRUNTIME;\n  const __unpin = exports.__unpin || F_NOEXPORTRUNTIME;\n  const __collect = exports.__collect || F_NOEXPORTRUNTIME;\n  const __rtti_base = exports.__rtti_base;\n  const getRttiCount = __rtti_base\n    ? function (arr) { return arr[__rtti_base >>> 2]; }\n    : F_NOEXPORTRUNTIME;\n\n  extendedExports.__new = __new;\n  extendedExports.__pin = __pin;\n  extendedExports.__unpin = __unpin;\n  extendedExports.__collect = __collect;\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = getRttiCount(U32);\n    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);\n    return U32[(__rtti_base + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets and validate runtime type info for the given id for array like objects */\n  function getArrayInfo(id) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY | STATICARRAY))) throw Error(`not an array: ${id}, flags=${info}`);\n    return info;\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = getRttiCount(U32);\n    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);\n    return U32[(__rtti_base + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  // function getKeyAlign(info) {\n  //   return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  // }\n\n  /** Allocates a new string in the module's memory and returns its pointer. */\n  function __newString(str) {\n    if (str == null) return 0;\n    const length = str.length;\n    const ptr = __new(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  extendedExports.__newString = __newString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    if (!ptr) return null;\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(`not a string: ${ptr}`);\n    return getStringImpl(buffer, ptr);\n  }\n\n  extendedExports.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(`unsupported align: ${alignLog2}`);\n  }\n\n  /** Allocates a new array in the module's memory and returns its pointer. */\n  function __newArray(id, values) {\n    const info = getArrayInfo(id);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = __new(length << align, info & STATICARRAY ? id : ARRAYBUFFER_ID);\n    let result;\n    if (info & STATICARRAY) {\n      result = buf;\n    } else {\n      __pin(buf);\n      const arr = __new(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n      __unpin(buf);\n      const U32 = new Uint32Array(memory.buffer);\n      U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = buf;\n      U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n      U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n      if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n      result = arr;\n    }\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) {\n        const value = values[i];\n        view[(buf >>> align) + i] = value;\n      }\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return result;\n  }\n\n  extendedExports.__newArray = __newArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getArrayInfo(id);\n    const align = getValueAlign(info);\n    let buf = info & STATICARRAY\n      ? arr\n      : U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);\n  }\n\n  extendedExports.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  extendedExports.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  extendedExports.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  /** Attach a set of get TypedArray and View functions to the exports. */\n  function attachTypedArrayFunctions(ctor, name, align) {\n    extendedExports[`__get${name}`] = getTypedArray.bind(null, ctor, align);\n    extendedExports[`__get${name}View`] = getTypedArrayView.bind(null, ctor, align);\n  }\n\n  [\n    Int8Array,\n    Uint8Array,\n    Uint8ClampedArray,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array\n  ].forEach(ctor => {\n    attachTypedArrayFunctions(ctor, ctor.name, 31 - Math.clz32(ctor.BYTES_PER_ELEMENT));\n  });\n\n  if (BIGINT) {\n    [BigUint64Array, BigInt64Array].forEach(ctor => {\n      attachTypedArrayFunctions(ctor, ctor.name.slice(3), 3);\n    });\n  }\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    let id = U32[ptr + ID_OFFSET >>> 2];\n    if (id <= getRttiCount(U32)) {\n      do {\n        if (id == baseId) return true;\n        id = getBase(id);\n      } while (id);\n    }\n    return false;\n  }\n\n  extendedExports.__instanceof = __instanceof;\n\n  // Pull basic exports to extendedExports so code in preInstantiate can use them\n  extendedExports.memory = extendedExports.memory || memory;\n  extendedExports.table  = extendedExports.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(exports, extendedExports);\n}\n\nfunction isResponse(src) {\n  return typeof Response !== \"undefined\" && src instanceof Response;\n}\n\nfunction isModule(src) {\n  return src instanceof WebAssembly.Module;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nexport async function instantiate(source, imports = {}) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  const module = isModule(source) ? source : await WebAssembly.compile(source);\n  const extended = preInstantiate(imports);\n  const instance = await WebAssembly.instantiate(module, imports);\n  const exports = postInstantiate(extended, instance);\n  return { module, instance, exports };\n}\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nexport function instantiateSync(source, imports = {}) {\n  const module = isModule(source) ? source : new WebAssembly.Module(source);\n  const extended = preInstantiate(imports);\n  const instance = new WebAssembly.Instance(module, imports);\n  const exports = postInstantiate(extended, instance);\n  return { module, instance, exports };\n}\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nexport async function instantiateStreaming(source, imports = {}) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  const extended = preInstantiate(imports);\n  const result = await WebAssembly.instantiateStreaming(source, imports);\n  const exports = postInstantiate(extended, result.instance);\n  return { ...result, exports };\n}\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nexport function demangle(exports, extendedExports = {}) {\n  const setArgumentsLength = exports[\"__argumentsLength\"]\n    ? length => { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || (() => { /* nop */ });\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = extendedExports;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      const className = name.substring(0, hash);\n      const classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        const ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf() { return this[THIS]; }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get() { return getter(this[THIS]); },\n            set(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return extendedExports;\n}\n\nexport default {\n  instantiate,\n  instantiateSync,\n  instantiateStreaming,\n  demangle\n};\n","export default __webpack_public_path__ + \"untouched.wasm\";","export enum Commands {\r\n  CLEAR,\r\n  RENDER_VAO,\r\n  ACTIVATE_SHADER,\r\n  UMATRIX4FV,\r\n  UTEXTURE2D,\r\n  GL_DEPTH_MASK,\r\n  GL_DEPTH_FUNC,\r\n  GL_CLEAR_DEPTH,\r\n  GL_ENABLE,\r\n  GL_DISABLE,\r\n  GL_STENCIL_MASK,\r\n  GL_STENCIL_FUNC,\r\n  GL_STENCIL_OP,\r\n  GL_CLEAR_STENCIL,\r\n  GL_POLYGON_OFFSET,\r\n  GL_CULLFACE,\r\n  GL_COLOR_MASK,\r\n  GL_CLEAR_COLOR,\r\n  GL_FRONT_FACE,\r\n  GL_BLEND_EQUATION,\r\n  GL_BLEND_FUNC,\r\n  GL_BLEND_EQUATION_SEPARATE,\r\n  GL_BLEND_FUNC_SEPARATE,\r\n}\r\n\r\nexport enum GPUCommands {\r\n  SET_PIPELINE,\r\n  SET_TRANSFORM,\r\n  SETUP_LIGHTING,\r\n  SET_INDEX_BUFFER,\r\n  SET_BUFFER,\r\n  START_PASS,\r\n  SET_BIND_GROUP,\r\n  END_PASS,\r\n  DRAW_INDEXED,\r\n}\r\n","export enum GroupType {\r\n  Transform,\r\n  Material,\r\n}\r\n","export enum PipelineType {\r\n  Mesh,\r\n}\r\n","export enum ResourceType {\r\n  Transform,\r\n  Material,\r\n  Lighting,\r\n  Texture,\r\n}\r\n","import { GPUBufferUsageFlags } from \"../common/GPUEnums\";\r\nimport { ExportType } from \"./index\";\r\nimport { GameManager } from \"./core/GameManager\";\r\n\r\ntype Import = WebAssembly.Imports;\r\nexport const vaos: WebGLVertexArrayObject[] = [];\r\nexport const buffers: WebGLBuffer[] = [];\r\nlet wasmExports: ExportType;\r\nlet wasmArrayBuffer: Uint32Array, wasmDataView: DataView, wasmMemoryBlock: ArrayBuffer;\r\n\r\nexport function bindExports(exports: ExportType) {\r\n  wasmExports = exports;\r\n\r\n  wasmMemoryBlock = wasmExports.exports.memory!.buffer;\r\n  wasmArrayBuffer = new Uint32Array(wasmMemoryBlock);\r\n  wasmDataView = new DataView(exports.exports.memory.buffer);\r\n  wasmDataView;\r\n}\r\n\r\nexport function createBindingsGPU(importObject: Import, gameManager: GameManager) {\r\n  if (!importObject.env.memory) throw new Error(\"You need to set memory in your importObject\");\r\n\r\n  const binding = {\r\n    print(stringIndex: number) {\r\n      if (wasmExports) console.log(wasmExports.exports.__getString(stringIndex));\r\n    },\r\n    createBufferFromF32(data: number, usage: GPUBufferUsageFlags) {\r\n      const buffer = wasmExports.exports.__getFloat32Array(data);\r\n      return gameManager.createBufferF32(buffer, usage);\r\n    },\r\n    createIndexBuffer(data: number, usage: GPUBufferUsageFlags) {\r\n      const buffer = wasmExports.exports.__getUint32Array(data);\r\n      return gameManager.createIndexBuffer(buffer, usage);\r\n    },\r\n    render(commandsIndex: number) {\r\n      const commandBuffer = wasmExports.exports.__getArray(commandsIndex) as Array<number>;\r\n      gameManager.renderQueueManager.run(commandBuffer, wasmArrayBuffer, wasmMemoryBlock);\r\n    },\r\n  };\r\n\r\n  importObject.Imports = binding;\r\n}\r\n","import { InputManager } from \"./InputManager\";\r\nimport { GPUBufferUsageFlags } from \"../../common/GPUEnums\";\r\nimport { PipelineType } from \"../../common/PipelineType\";\r\nimport { DebugPipeline } from \"./pipelines/debug-pipeline\";\r\nimport { Pipeline } from \"./pipelines/Pipeline\";\r\nimport { createBuffer, createIndexBuffer } from \"./Utils\";\r\nimport { RenderQueueManager } from \"./RenderQueueManager\";\r\nimport { WasmInterface } from \"..\";\r\nimport { Texture } from \"./Texture\";\r\nimport { GroupType } from \"../../common/GroupType\";\r\nimport { ResourceType } from \"../../common/ResourceType\";\r\nimport { MeshPipeline } from \"build/types\";\r\n\r\nconst meshPipelineInstances: MeshPipeline[] = [];\r\n\r\nexport class GameManager {\r\n  canvas: HTMLCanvasElement;\r\n  device: GPUDevice;\r\n  context: GPUCanvasContext;\r\n  format: GPUTextureFormat;\r\n  inputManager: InputManager;\r\n  wasm: WasmInterface;\r\n\r\n  buffers: GPUBuffer[];\r\n  pipelines: Pipeline<any>[];\r\n  samplers: GPUSampler[];\r\n  textures: Texture[];\r\n\r\n  onResizeHandler: () => void;\r\n  onFrameHandler: () => void;\r\n  disposed: boolean;\r\n  renderQueueManager: RenderQueueManager;\r\n\r\n  renderTargetView: GPUTextureView;\r\n  renderTarget: GPUTexture;\r\n  depthTexture: GPUTexture;\r\n\r\n  currentPass: GPURenderPassEncoder | null;\r\n  currentCommandEncoder: GPUCommandEncoder;\r\n\r\n  constructor(canvasId: string) {\r\n    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;\r\n    this.buffers = [];\r\n    this.textures = [];\r\n    this.samplers = [];\r\n    this.disposed = false;\r\n    this.currentPass = null;\r\n    this.renderQueueManager = new RenderQueueManager(this);\r\n    this.onResizeHandler = this.onWindowResize.bind(this);\r\n    this.onFrameHandler = this.onFrame.bind(this);\r\n  }\r\n\r\n  async init(wasm: WasmInterface) {\r\n    this.wasm = wasm;\r\n\r\n    const hasGPU = this.hasWebGPU();\r\n    if (!hasGPU) throw new Error(\"Your current browser does not support WebGPU!\");\r\n\r\n    this.inputManager = new InputManager(this.canvas, wasm);\r\n\r\n    const adapter = await navigator.gpu?.requestAdapter();\r\n    const device = (await adapter?.requestDevice()) as GPUDevice;\r\n    const context = this.canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\r\n    const format = context.getPreferredFormat(adapter!);\r\n\r\n    context.configure({\r\n      device: device,\r\n      format: format,\r\n      size: this.canvasSize(),\r\n    });\r\n\r\n    this.device = device;\r\n    this.context = context;\r\n    this.format = format;\r\n\r\n    this.samplers = [\r\n      device.createSampler({\r\n        minFilter: \"linear\",\r\n        magFilter: \"linear\",\r\n      }),\r\n    ];\r\n\r\n    // TEXTURES\r\n    const texturePaths = [\r\n      { name: \"grid\", path: \"./media/uv-grid.jpg\" },\r\n      { name: \"crate\", path: \"./media/crate-wooden.jpg\" },\r\n    ];\r\n\r\n    this.textures = await Promise.all(\r\n      texturePaths.map((tp, index) => {\r\n        const texture = new Texture(tp.name, tp.path);\r\n        wasm.TextureFactory.createTexture(wasm.__newString(tp.name), index);\r\n        return texture.load(device);\r\n      })\r\n    );\r\n\r\n    // PIPELINES\r\n    this.pipelines = [\r\n      new DebugPipeline(\"textured\", { diffuseMap: this.textures[1], NUM_DIR_LIGHTS: 0 }),\r\n      new DebugPipeline(\"simple\", { NUM_DIR_LIGHTS: 0 }),\r\n    ];\r\n\r\n    const sampleCount = 4;\r\n    this.renderTarget = device.createTexture({\r\n      size: this.canvasSize(),\r\n      sampleCount,\r\n      format: format,\r\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n\r\n    this.renderTargetView = this.renderTarget.createView();\r\n    this.depthTexture = device.createTexture({\r\n      size: this.canvasSize(),\r\n      format: \"depth24plus\",\r\n      sampleCount: sampleCount,\r\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n\r\n    // Initialize the wasm module\r\n    wasm.AsSceneManager.init(this.canvas.width, this.canvas.height);\r\n\r\n    this.initRuntime();\r\n\r\n    // Setup events\r\n    window.addEventListener(\"resize\", this.onResizeHandler);\r\n    window.requestAnimationFrame(this.onFrameHandler);\r\n    window.addEventListener(\"click\", (e) => {\r\n      const pipelines = this.pipelines as DebugPipeline[];\r\n      pipelines.forEach((p) => {\r\n        if (p.defines.diffuseMap) {\r\n          delete p.defines.diffuseMap;\r\n          p.defines = p.defines;\r\n        } else {\r\n          p.defines.diffuseMap = this.textures[1];\r\n          p.defines = p.defines;\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  getTexture(name: string) {\r\n    return this.textures.find((t) => t.name === name) || null;\r\n  }\r\n\r\n  initRuntime() {\r\n    const wasm = this.wasm;\r\n    const runime = wasm.Runtime.wrap(wasm.AsSceneManager.getRuntime());\r\n\r\n    this.pipelines.forEach((p) => {\r\n      p.build(this);\r\n      p.initialize(this);\r\n    });\r\n\r\n    const containerPtr = wasm.__pin(wasm.createLevel1());\r\n    const container = wasm.Level1.wrap(containerPtr);\r\n    container.addAsset(this.createMesh(1, \"sphere\", false));\r\n    container.addAsset(this.createMesh(1, \"box\", true));\r\n    container.addAsset(this.createMesh(1, \"box\", true));\r\n    wasm.__unpin(containerPtr);\r\n\r\n    runime.addContainer(containerPtr);\r\n  }\r\n\r\n  createMesh(size: number, type: \"box\" | \"sphere\", useTexture = true) {\r\n    // Get the pipeline\r\n    const debugPipeline = this.getPipeline(useTexture ? \"textured\" : \"simple\")!;\r\n    const pipelineIndex = this.pipelines.indexOf(debugPipeline);\r\n\r\n    // Create an instance in WASM\r\n    const pipelineInsPtr = this.wasm.PipelineFactory.createPipeline(\r\n      this.wasm.__newString(debugPipeline.name),\r\n      pipelineIndex,\r\n      PipelineType.Mesh\r\n    );\r\n    const meshPipelineIns = this.wasm.MeshPipeline.wrap(pipelineInsPtr);\r\n\r\n    meshPipelineInstances.push(meshPipelineIns);\r\n\r\n    // Assign a transform buffer to the intance\r\n    meshPipelineIns.transformGroupId = debugPipeline.getTemplateByType(ResourceType.Transform)!.template.group;\r\n    meshPipelineIns.transformResourceIndex = debugPipeline.addResourceInstance(this, GroupType.Transform);\r\n\r\n    const geometryPtr =\r\n      type === \"box\" ? this.wasm.GeometryFactory.createBox(size) : this.wasm.GeometryFactory.createSphere(size);\r\n    const meshPtr = this.wasm.createMesh(geometryPtr, pipelineInsPtr);\r\n    return meshPtr;\r\n  }\r\n\r\n  dispose() {\r\n    this.disposed = true;\r\n    window.removeEventListener(\"resize\", this.onResizeHandler);\r\n    this.inputManager?.dispose();\r\n  }\r\n\r\n  // TODO:\r\n  private onWindowResize() {\r\n    this.wasm.AsSceneManager.resize(this.canvas.width, this.canvas.height);\r\n  }\r\n\r\n  private onFrame() {\r\n    if (this.disposed) return;\r\n    this.wasm.AsSceneManager.update(performance.now());\r\n    window.requestAnimationFrame(this.onFrameHandler);\r\n  }\r\n\r\n  canvasSize() {\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n    const size = [this.canvas.clientWidth * devicePixelRatio, this.canvas.clientHeight * devicePixelRatio];\r\n    return size;\r\n  }\r\n\r\n  hasWebGPU() {\r\n    if (!navigator.gpu) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  getPipeline(name: string) {\r\n    return this.pipelines.find((p) => p.name === name);\r\n  }\r\n\r\n  startPass() {\r\n    const device = this.device;\r\n    const commandEncoder = device.createCommandEncoder();\r\n    const renderPass = commandEncoder.beginRenderPass({\r\n      colorAttachments: [\r\n        {\r\n          view: this.renderTargetView,\r\n          resolveTarget: this.context.getCurrentTexture().createView(),\r\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, //background color\r\n          storeOp: \"store\",\r\n        },\r\n      ],\r\n      depthStencilAttachment: {\r\n        view: this.depthTexture.createView(),\r\n        depthLoadValue: 1,\r\n        depthStoreOp: \"store\",\r\n        stencilLoadValue: 0,\r\n        stencilStoreOp: \"store\",\r\n      },\r\n    });\r\n\r\n    this.currentPass = renderPass;\r\n    this.currentCommandEncoder = commandEncoder;\r\n  }\r\n\r\n  endPass() {\r\n    this.currentPass!.endPass();\r\n    this.device.queue.submit([this.currentCommandEncoder.finish()]);\r\n  }\r\n\r\n  createBufferF32(\r\n    data: Float32Array,\r\n    usageFlag: GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST\r\n  ) {\r\n    const buffer = createBuffer(this.device, data, usageFlag);\r\n    this.buffers.push(buffer);\r\n    return this.buffers.length - 1;\r\n  }\r\n\r\n  createIndexBuffer(\r\n    data: Uint32Array,\r\n    usageFlag: GPUBufferUsageFlags = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST\r\n  ) {\r\n    const buffer = createIndexBuffer(this.device, data, usageFlag);\r\n    this.buffers.push(buffer);\r\n    return this.buffers.length - 1;\r\n  }\r\n}\r\n","import { WasmInterface } from \"../index\";\r\n\r\nexport enum MouseEventType {\r\n  MouseDown,\r\n  MouseUp,\r\n  MouseMove,\r\n  MouseWheel,\r\n}\r\n\r\nexport class InputManager {\r\n  canvas: HTMLCanvasElement;\r\n  wasm: WasmInterface;\r\n\r\n  private onDownHandler: (e: MouseEvent) => void;\r\n  private onUpHandler: (e: MouseEvent) => void;\r\n  private onMoveHandler: (e: MouseEvent) => void;\r\n  private onWheelHandler: (e: WheelEvent) => void;\r\n  private canvasBounds: DOMRect;\r\n\r\n  constructor(canvas: HTMLCanvasElement, wasm: WasmInterface) {\r\n    this.wasm = wasm;\r\n    this.canvas = canvas;\r\n    this.canvasBounds = canvas.getBoundingClientRect();\r\n\r\n    this.onDownHandler = this.onDown.bind(this);\r\n    this.onUpHandler = this.onUp.bind(this);\r\n    this.onMoveHandler = this.onMove.bind(this);\r\n    this.onWheelHandler = this.onWheel.bind(this);\r\n\r\n    this.canvas.addEventListener(\"mousedown\", this.onDownHandler);\r\n    window.addEventListener(\"wheel\", this.onWheelHandler);\r\n    window.addEventListener(\"mouseup\", this.onUpHandler);\r\n    window.addEventListener(\"mousemove\", this.onMoveHandler);\r\n\r\n    this.reset();\r\n  }\r\n\r\n  reset() {\r\n    this.canvasBounds = this.canvas.getBoundingClientRect();\r\n  }\r\n\r\n  private onUp(e: MouseEvent) {\r\n    this.sendMouseEvent(MouseEventType.MouseUp, e, this.canvasBounds, 0);\r\n  }\r\n\r\n  private onMove(e: MouseEvent) {\r\n    this.sendMouseEvent(MouseEventType.MouseMove, e, this.canvasBounds, 0);\r\n  }\r\n\r\n  private onDown(e: MouseEvent) {\r\n    e.preventDefault();\r\n    this.sendMouseEvent(MouseEventType.MouseDown, e, this.canvasBounds, 0);\r\n  }\r\n\r\n  private onWheel(e: WheelEvent) {\r\n    this.sendMouseEvent(MouseEventType.MouseWheel, e, this.canvasBounds, e.deltaY);\r\n  }\r\n\r\n  private createMouseEvent(e: MouseEvent, bounds: DOMRect, delta: number = 0) {\r\n    const mouseEventPtr = this.wasm.__pin(\r\n      this.wasm.ASInputManager.createMouseEvent(\r\n        e.clientX,\r\n        e.clientY,\r\n        e.pageX,\r\n        e.pageY,\r\n        e.ctrlKey,\r\n        e.shiftKey,\r\n        e.altKey,\r\n        e.button,\r\n        e.buttons,\r\n        bounds.x,\r\n        bounds.y,\r\n        bounds.width,\r\n        bounds.height,\r\n        delta\r\n      )\r\n    );\r\n    this.wasm.ASInputManager.MouseEvent.wrap(mouseEventPtr);\r\n    return mouseEventPtr;\r\n  }\r\n\r\n  private sendMouseEvent(type: MouseEventType, event: MouseEvent, bounds: DOMRect, delta: number): void {\r\n    const manager = this.wasm.ASInputManager.InputManager.wrap(this.wasm.ASInputManager.getInputManager());\r\n    const wasmEvent = this.createMouseEvent(event, bounds, delta);\r\n\r\n    if (type === MouseEventType.MouseUp) manager.onMouseUp(wasmEvent);\r\n    else if (type === MouseEventType.MouseMove) manager.onMouseMove(wasmEvent);\r\n    else if (type === MouseEventType.MouseDown) manager.onMouseDown(wasmEvent);\r\n    else if (type === MouseEventType.MouseWheel) manager.onWheel(wasmEvent);\r\n\r\n    this.wasm.__unpin(wasmEvent);\r\n  }\r\n\r\n  dispose() {\r\n    this.canvas.removeEventListener(\"mousedown\", this.onDownHandler);\r\n    window.removeEventListener(\"wheel\", this.onWheelHandler);\r\n    window.removeEventListener(\"mouseup\", this.onUpHandler);\r\n    window.removeEventListener(\"mousemove\", this.onMoveHandler);\r\n  }\r\n}\r\n","import { GroupType } from \"../../common/GroupType\";\r\nimport { ResourceType } from \"../../common/ResourceType\";\r\nimport { GPUCommands } from \"../../common/Commands\";\r\nimport { GameManager } from \"./GameManager\";\r\nimport { Pipeline } from \"./pipelines/Pipeline\";\r\nimport { LightingResource } from \"./pipelines/resources/LightingResource\";\r\nimport { PipelineResourceInstance } from \"./pipelines/resources/PipelineResourceInstance\";\r\n\r\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\r\nconst normalAs4x4 = new Float32Array(12);\r\n\r\nexport class RenderQueueManager {\r\n  manager: GameManager;\r\n\r\n  constructor(manager: GameManager) {\r\n    this.manager = manager;\r\n  }\r\n\r\n  run(commandBuffer: Array<number>, arrayBuffer: Uint32Array, wasmMemoryBlock: ArrayBuffer) {\r\n    const manager = this.manager;\r\n    const device = manager.device;\r\n\r\n    const getPtrIndex = function (ptr: number) {\r\n      return arrayBuffer[(ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET) >>> 2];\r\n    };\r\n    getPtrIndex;\r\n\r\n    let pipeline: Pipeline<any>, buffer: GPUBuffer, instances: PipelineResourceInstance[], resourceIndex: number;\r\n\r\n    let pass = manager.currentPass!;\r\n\r\n    for (let i = 0, l = commandBuffer.length; i < l; i++) {\r\n      const command = commandBuffer[i];\r\n\r\n      switch (command) {\r\n        case GPUCommands.SETUP_LIGHTING:\r\n          const numDirectionLights = commandBuffer[i + 1];\r\n\r\n          if (LightingResource.numDirLights !== numDirectionLights) {\r\n            LightingResource.numDirLights = numDirectionLights;\r\n            LightingResource.rebuildDirectionLights = true;\r\n            this.manager.pipelines.forEach((p) => {\r\n              if (p.getTemplateByType(ResourceType.Material)) {\r\n                p.defines = { ...p.defines, NUM_DIR_LIGHTS: numDirectionLights };\r\n              }\r\n            });\r\n          }\r\n\r\n          buffer = LightingResource.lightingConfig;\r\n          if (buffer) {\r\n            const info = getPtrIndex(commandBuffer[i + 2]);\r\n            device.queue.writeBuffer(buffer, 0, wasmMemoryBlock, info, 4);\r\n          }\r\n\r\n          buffer = LightingResource.sceneLightingBuffer;\r\n          if (buffer) {\r\n            const ambientLights = getPtrIndex(commandBuffer[i + 3]);\r\n            device.queue.writeBuffer(buffer, 0, wasmMemoryBlock, ambientLights, 4 * 4);\r\n          }\r\n\r\n          buffer = LightingResource.directionLightsBuffer;\r\n          if (buffer) {\r\n            const dirLights = getPtrIndex(commandBuffer[i + 4]);\r\n            device.queue.writeBuffer(buffer, 0, wasmMemoryBlock, dirLights, numDirectionLights * 4 * 4 * 2);\r\n          }\r\n\r\n          i += 4;\r\n          break;\r\n\r\n        case GPUCommands.SET_TRANSFORM:\r\n          instances = pipeline!.groupInstances.get(GroupType.Transform)!;\r\n          resourceIndex = commandBuffer[i + 1];\r\n          const projMatrixPtr = getPtrIndex(commandBuffer[i + 2]);\r\n          const mvMatrixPtr = getPtrIndex(commandBuffer[i + 3]);\r\n          const normMatrixPtr = getPtrIndex(commandBuffer[i + 4]);\r\n\r\n          const mat3x3 = new Float32Array(wasmMemoryBlock, normMatrixPtr, 9);\r\n\r\n          // TODO: Make this neater\r\n          normalAs4x4[0] = mat3x3[0];\r\n          normalAs4x4[1] = mat3x3[1];\r\n          normalAs4x4[2] = mat3x3[2];\r\n\r\n          normalAs4x4[4] = mat3x3[3];\r\n          normalAs4x4[5] = mat3x3[4];\r\n          normalAs4x4[6] = mat3x3[5];\r\n\r\n          normalAs4x4[8] = mat3x3[6];\r\n          normalAs4x4[9] = mat3x3[7];\r\n          normalAs4x4[10] = mat3x3[8];\r\n\r\n          const transformBuffer = instances[resourceIndex].buffers![0];\r\n          device.queue.writeBuffer(transformBuffer, 0, wasmMemoryBlock, projMatrixPtr, 64);\r\n          device.queue.writeBuffer(transformBuffer, 64, wasmMemoryBlock, mvMatrixPtr, 64);\r\n          device.queue.writeBuffer(transformBuffer, 128, normalAs4x4);\r\n          i += 4;\r\n          break;\r\n\r\n        case GPUCommands.SET_INDEX_BUFFER:\r\n          buffer = manager.buffers[commandBuffer[i + 1]];\r\n          pass.setIndexBuffer(buffer, \"uint32\");\r\n          i += 1;\r\n          break;\r\n\r\n        case GPUCommands.SET_BUFFER:\r\n          const slot = commandBuffer[i + 1];\r\n          buffer = manager.buffers[commandBuffer[i + 2]];\r\n          pass.setVertexBuffer(slot, buffer);\r\n          i += 2;\r\n          break;\r\n\r\n        case GPUCommands.DRAW_INDEXED:\r\n          const indexCount = commandBuffer[i + 1];\r\n          pass.drawIndexed(indexCount);\r\n          i += 1;\r\n          break;\r\n\r\n        case GPUCommands.SET_PIPELINE:\r\n          const newPipeline = manager.pipelines[commandBuffer[i + 1]];\r\n\r\n          if (newPipeline.rebuild) {\r\n            newPipeline.build(manager);\r\n            newPipeline.initialize(manager);\r\n          }\r\n\r\n          if (newPipeline === pipeline!) {\r\n            i += 1;\r\n            break;\r\n          }\r\n\r\n          pipeline = newPipeline;\r\n\r\n          pass.setPipeline(pipeline.renderPipeline!);\r\n          i += 1;\r\n          break;\r\n\r\n        case GPUCommands.SET_BIND_GROUP:\r\n          instances = pipeline!.groupInstances.get(commandBuffer[i + 1])!;\r\n          const instance = instances?.[commandBuffer[i + 2]];\r\n          if (instance) pass.setBindGroup(instance.group, instance.bindGroup);\r\n\r\n          i += 2;\r\n          break;\r\n\r\n        case GPUCommands.START_PASS:\r\n          manager.startPass();\r\n          pass = manager.currentPass!;\r\n          break;\r\n\r\n        case GPUCommands.END_PASS:\r\n          manager.endPass();\r\n          break;\r\n      }\r\n    }\r\n  }\r\n}\r\n","export class Texture {\r\n  name: string;\r\n  path: string;\r\n  gpuTexture: GPUTexture;\r\n  imageData: ImageBitmap;\r\n\r\n  constructor(name: string, path: string) {\r\n    this.name = name;\r\n    this.path = path;\r\n  }\r\n\r\n  async load(device: GPUDevice) {\r\n    let gpuTexture: GPUTexture;\r\n    const img = document.createElement(\"img\");\r\n    img.src = this.path;\r\n    await img.decode();\r\n    this.imageData = await createImageBitmap(img);\r\n\r\n    gpuTexture = device.createTexture({\r\n      size: [this.imageData.width, this.imageData.height, 1],\r\n      format: \"rgba8unorm\",\r\n      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n\r\n    device.queue.copyExternalImageToTexture({ source: this.imageData }, { texture: gpuTexture }, [\r\n      this.imageData.width,\r\n      this.imageData.height,\r\n    ]);\r\n\r\n    this.gpuTexture = gpuTexture;\r\n    return this;\r\n  }\r\n}\r\n","import { GPUBufferUsageFlags } from \"../../common/GPUEnums\";\r\n\r\nexport function createBuffer(\r\n  device: GPUDevice,\r\n  data: Float32Array,\r\n  usageFlag: GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST\r\n) {\r\n  const buffer = device.createBuffer({\r\n    size: data.byteLength,\r\n    usage: usageFlag,\r\n    // mappedAtCreation is true so we can interact with it via the CPU\r\n    mappedAtCreation: true,\r\n  });\r\n  new Float32Array(buffer.getMappedRange()).set(data);\r\n  buffer.unmap();\r\n  return buffer;\r\n}\r\n\r\nexport function createIndexBuffer(\r\n  device: GPUDevice,\r\n  data: Uint32Array,\r\n  usageFlag: GPUBufferUsageFlags = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST\r\n) {\r\n  const buffer = device.createBuffer({\r\n    size: data.byteLength,\r\n    usage: usageFlag,\r\n    // mappedAtCreation is true so we can interact with it via the CPU\r\n    mappedAtCreation: true,\r\n  });\r\n  new Uint32Array(buffer.getMappedRange()).set(data);\r\n  buffer.unmap();\r\n  return buffer;\r\n}\r\n","export const defaultPipelineDescriptor: Partial<GPURenderPipelineDescriptor> = {\r\n  primitive: {\r\n    topology: \"triangle-list\",\r\n    cullMode: \"back\",\r\n    frontFace: \"ccw\",\r\n  },\r\n  depthStencil: {\r\n    format: \"depth24plus\",\r\n    depthWriteEnabled: true,\r\n    depthCompare: \"less\",\r\n  },\r\n  multisample: {\r\n    count: 4,\r\n  },\r\n};\r\n","import { GameManager } from \"../GameManager\";\r\nimport { BindingData, PipelineResourceTemplate } from \"./resources/PipelineResourceTemplate\";\r\nimport { PipelineResourceInstance } from \"./resources/PipelineResourceInstance\";\r\nimport { GroupType } from \"../../../common/GroupType\";\r\nimport { ResourceType } from \"../../../common/ResourceType\";\r\nimport \"./shader-lib/Utils\";\r\nimport { Defines, SourceFragments } from \"./shader-lib/Utils\";\r\n\r\nexport class GroupMapping {\r\n  index: number;\r\n  bindingCount: number;\r\n\r\n  constructor(index: number) {\r\n    this.index = index;\r\n    this.bindingCount = 0;\r\n  }\r\n\r\n  getBinding(): number {\r\n    const toRet = this.bindingCount;\r\n    this.bindingCount++;\r\n    return toRet;\r\n  }\r\n}\r\n\r\nexport abstract class Pipeline<T extends Defines<T>> {\r\n  name: string;\r\n  renderPipeline: GPURenderPipeline | null;\r\n  fragmentSource: SourceFragments<T>;\r\n  vertexSource: SourceFragments<T>;\r\n  private _defines: Defines<T>;\r\n  private resourceTemplates: PipelineResourceTemplate[];\r\n  groupInstances: Map<GroupType, PipelineResourceInstance[]>;\r\n  rebuild: boolean;\r\n\r\n  groupMapping: Map<GroupType, GroupMapping>;\r\n  private groups: number;\r\n\r\n  constructor(name: string, vertexSource: SourceFragments<T>, fragmentSource: SourceFragments<T>, defines: Defines<T>) {\r\n    this.name = name;\r\n    this.renderPipeline = null;\r\n    this.vertexSource = vertexSource;\r\n    this.fragmentSource = fragmentSource;\r\n    this.resourceTemplates = [];\r\n    this.groupInstances = new Map();\r\n    this.defines = defines;\r\n    this.rebuild = true;\r\n\r\n    this.groupMapping = new Map();\r\n    this.groups = 0;\r\n  }\r\n\r\n  set defines(defines: T) {\r\n    this._defines = defines;\r\n    this.rebuild = true;\r\n  }\r\n\r\n  get defines(): T {\r\n    return this._defines;\r\n  }\r\n\r\n  groupIndex(type: GroupType): number {\r\n    if (this.groupMapping.has(type)) return this.groupMapping.get(type)!.index;\r\n    else {\r\n      const groupMapping = new GroupMapping(this.groups);\r\n      this.groupMapping.set(type, groupMapping);\r\n      this.groups++;\r\n      return groupMapping.index;\r\n    }\r\n  }\r\n\r\n  bindingIndex(type: GroupType): number {\r\n    if (this.groupMapping.has(type)) {\r\n      const groupMapping = this.groupMapping.get(type)!;\r\n      return groupMapping.getBinding();\r\n    } else {\r\n      const groupMapping = new GroupMapping(this.groups);\r\n      this.groupMapping.set(type, groupMapping);\r\n      this.groups++;\r\n      return groupMapping.getBinding();\r\n    }\r\n  }\r\n\r\n  /** Use this function to add resource templates */\r\n  abstract onAddResources(): void;\r\n\r\n  getTemplateByType(type: ResourceType, id?: string) {\r\n    if (id) return this.resourceTemplates.find((t) => t.resourceType === type && id === t.id);\r\n    else return this.resourceTemplates.find((t) => t.resourceType === type);\r\n  }\r\n\r\n  getTemplateByGroup(type: GroupType) {\r\n    return this.resourceTemplates.find((t) => t.groupType === type);\r\n  }\r\n\r\n  addTemplate(template: PipelineResourceTemplate) {\r\n    this.resourceTemplates.push(template);\r\n    return this;\r\n  }\r\n\r\n  build(gameManager: GameManager): void {\r\n    this.rebuild = false;\r\n\r\n    const groupInstanceMap = this.groupInstances;\r\n    const templates = this.resourceTemplates;\r\n\r\n    // Destroy previous instances\r\n    templates.forEach((template) => {\r\n      const resourceInstances = groupInstanceMap.get(template.groupType);\r\n      resourceInstances?.forEach((i) => {\r\n        i.dispose();\r\n      });\r\n    });\r\n\r\n    // Reset\r\n    templates.splice(0, templates.length);\r\n    this.groupMapping.clear();\r\n    this.groups = 0;\r\n\r\n    this.onAddResources();\r\n\r\n    let curBinding = 0;\r\n    const binds: Map<number, number> = new Map();\r\n\r\n    templates.forEach((resourceTemplate) => {\r\n      const groupIndex = this.groupIndex(resourceTemplate.groupType);\r\n      if (!binds.has(groupIndex)) binds.set(groupIndex, 0);\r\n\r\n      curBinding = binds.get(groupIndex)!;\r\n\r\n      const template = resourceTemplate.build(gameManager, this, curBinding);\r\n\r\n      curBinding += template.bindings.length;\r\n      binds.set(groupIndex, curBinding);\r\n\r\n      resourceTemplate.template = template;\r\n    });\r\n  }\r\n\r\n  initialize(gameManager: GameManager): void {\r\n    const templates = this.resourceTemplates;\r\n    const groupInstances = this.groupInstances;\r\n    const prevGroupKeys = Array.from(this.groupInstances.keys());\r\n    const uniqueNewGroupKeys = templates\r\n      .map((r) => r.groupType)\r\n      .filter((value, index, self) => self.indexOf(value) === index);\r\n    const groupCache: Map<GroupType, { numInstances: number; bindData: Map<number, BindingData[]> }> = new Map();\r\n\r\n    // Remove any unused instances\r\n    prevGroupKeys.forEach((key) => {\r\n      if (!uniqueNewGroupKeys.includes(key)) groupInstances.delete(key);\r\n    });\r\n\r\n    // Initialize temp cache maps\r\n    for (const newKey of uniqueNewGroupKeys) {\r\n      let numInstancesToCreate = 0;\r\n      let instances: PipelineResourceInstance[];\r\n\r\n      // If we previously had instances, then save the number of them\r\n      // as we have to re-create the same amount as before. Otherwise just create 1;\r\n      if (groupInstances.has(newKey)) {\r\n        instances = groupInstances.get(newKey)!;\r\n        numInstancesToCreate = instances.length;\r\n        instances.splice(0, instances.length);\r\n      } else {\r\n        numInstancesToCreate = 1;\r\n        instances = [];\r\n        groupInstances.set(newKey, instances);\r\n      }\r\n\r\n      groupCache.set(newKey, { bindData: new Map(), numInstances: numInstancesToCreate });\r\n    }\r\n\r\n    // Initialize each template\r\n    templates.forEach((resourceTemplate) => {\r\n      const { bindData, numInstances } = groupCache.get(resourceTemplate.groupType)!;\r\n\r\n      for (let i = 0; i < numInstances; i++)\r\n        if (bindData.has(i)) {\r\n          bindData.get(i)!.push(resourceTemplate.getBindingData(gameManager, this.renderPipeline!));\r\n        } else {\r\n          bindData.set(i, [resourceTemplate.getBindingData(gameManager, this.renderPipeline!)]);\r\n        }\r\n    });\r\n\r\n    // Create the instances & bind groups\r\n    groupCache.forEach((cache, groupType) => {\r\n      const instances: PipelineResourceInstance[] = new Array(cache.numInstances);\r\n      const groupIndex = this.groupIndex(groupType);\r\n\r\n      for (let i = 0; i < cache.numInstances; i++) {\r\n        let buffers: GPUBuffer[] | null = null;\r\n\r\n        // Join all the entries from each template\r\n        // Also join all the collect each of the buffers we want to cache for the render queue\r\n        const entries: GPUBindGroupEntry[] = cache.bindData.get(i)!.reduce((accumulator, cur) => {\r\n          if (cur.buffer) {\r\n            if (!buffers) buffers = [cur.buffer];\r\n            else buffers.push(cur.buffer);\r\n          }\r\n\r\n          accumulator.push(...cur.binds);\r\n          return accumulator;\r\n        }, [] as GPUBindGroupEntry[]);\r\n\r\n        const bindGroup = gameManager.device.createBindGroup({\r\n          label: GroupType[groupType],\r\n          layout: this.renderPipeline!.getBindGroupLayout(groupIndex),\r\n          entries,\r\n        });\r\n\r\n        instances[i] = new PipelineResourceInstance(groupIndex, bindGroup, buffers);\r\n      }\r\n\r\n      groupInstances.set(groupType, instances);\r\n    });\r\n  }\r\n\r\n  addResourceInstance(manager: GameManager, type: GroupType) {\r\n    const template = this.getTemplateByGroup(type);\r\n\r\n    if (template) {\r\n      const bindingData = template.getBindingData(manager, this.renderPipeline!);\r\n      const groupIndex = this.groupIndex(type);\r\n\r\n      const bindGroup = manager.device.createBindGroup({\r\n        label: GroupType[type],\r\n        layout: this.renderPipeline!.getBindGroupLayout(groupIndex),\r\n        entries: bindingData.binds,\r\n      });\r\n\r\n      const instances = new PipelineResourceInstance(\r\n        groupIndex,\r\n        bindGroup,\r\n        bindingData.buffer ? [bindingData.buffer] : null\r\n      );\r\n\r\n      const instanceArray = this.groupInstances.get(type)!;\r\n      instanceArray.push(instances);\r\n      return instanceArray.length - 1;\r\n    } else throw new Error(\"Pipeline does not use resource type\");\r\n  }\r\n}\r\n","import { ResourceType } from \"../../../../common/ResourceType\";\r\nimport { GameManager } from \"../../GameManager\";\r\nimport { Texture } from \"../../Texture\";\r\nimport { defaultPipelineDescriptor } from \"../DefaultPipelineDescriptor\";\r\nimport { Pipeline } from \"../Pipeline\";\r\nimport { LightingResource } from \"../resources/LightingResource\";\r\nimport { MaterialResource } from \"../resources/MaterialResource\";\r\nimport { TextureResource } from \"../resources/TextureResource\";\r\nimport { TransformResource } from \"../resources/TransformResource\";\r\nimport { mathConstants, mathFunctions } from \"../shader-lib/MathFunctions\";\r\nimport { shader, shaderBuilder } from \"../shader-lib/Utils\";\r\n\r\n// prettier-ignore\r\nconst vertexShader = shader<DebugDefines>`\r\n${e => e.getTemplateByType(ResourceType.Transform)!.template.vertexBlock }\r\n\r\nstruct Output {\r\n    [[builtin(position)]] Position : vec4<f32>;\r\n    [[location(0)]] vFragUV : vec2<f32>;\r\n    [[location(1)]] vNormal : vec3<f32>;\r\n    [[location(2)]] vViewPosition : vec3<f32>;\r\n};\r\n\r\n[[stage(vertex)]]\r\nfn main([[location(0)]] pos: vec4<f32>, [[location(1)]] norm: vec3<f32>, [[location(2)]] uv: vec2<f32>) -> Output {\r\n    var output: Output;\r\n    var mvPosition = vec4<f32>( pos.xyz, 1.0 );\r\n\r\n    mvPosition = uniforms.modelViewMatrix * mvPosition;\r\n\r\n    output.vViewPosition = - mvPosition.xyz;\r\n    output.Position = uniforms.projMatrix * mvPosition;\r\n    output.vFragUV = uv;\r\n\r\n    var transformedNormal = uniforms.normalMatrix * norm.xyz;\r\n    output.vNormal = normalize( transformedNormal );\r\n\r\n    return output;\r\n}\r\n`;\r\n\r\n// prettier-ignore\r\nconst fragmentShader = shader<DebugDefines>`\r\n\r\n${e => e.getTemplateByType(ResourceType.Lighting)!.template.fragmentBlock}\r\n${e => e.getTemplateByType(ResourceType.Material)!.template.fragmentBlock}\r\n${e => e.defines.diffuseMap ? e.getTemplateByType(ResourceType.Texture, 'diffuse')!.template.fragmentBlock : ''}\r\n${e => e.defines.normalMap ? e.getTemplateByType(ResourceType.Texture, 'normal')!.template.fragmentBlock : ''}\r\n\r\n// INTERNAL STRUCTS\r\nstruct IncidentLight {\r\n  color: vec3<f32>;\r\n  direction: vec3<f32>;\r\n  visible: bool;\r\n};\r\n\r\nstruct ReflectedLight {\r\n  directDiffuse: vec3<f32>;\r\n  directSpecular: vec3<f32>;\r\n  indirectDiffuse: vec3<f32>;\r\n  indirectSpecular: vec3<f32>;\r\n};\r\n\r\nstruct PhysicalMaterial {\r\n  diffuseColor: vec3<f32>;\r\n  specularColor: vec3<f32>;\r\n  roughness: f32;\r\n  specularF90: f32;\r\n};\r\n\r\nstruct GeometricContext {\r\n  position: vec3<f32>;\r\n  normal: vec3<f32>;\r\n  viewDir: vec3<f32>;\r\n};\r\n\r\nstruct DirectionalLight {\r\n  direction: vec3<f32>;\r\n  color: vec3<f32>;\r\n};\r\n\r\n${mathConstants}\r\n${mathFunctions}\r\n\r\nfn packNormalToRGB( normal: vec3<f32> ) -> vec3<f32> {\r\n  return normalize( normal ) * 0.5 + 0.5;\r\n}\r\n\r\nfn getDirectionalLightInfo( directionalLight: DirectionalLight, geometry: GeometricContext, light: ptr<function, IncidentLight> ) {\r\n  (*light).color = directionalLight.color;\r\n  (*light).direction = directionalLight.direction;\r\n  (*light).visible = true;\r\n}\r\n\r\nfn BRDF_Lambert( diffuseColor: vec3<f32> ) -> vec3<f32> {\r\n  return RECIPROCAL_PI * diffuseColor;\r\n}\r\n\r\nfn F_Schlick( f0: vec3<f32>, f90: f32, dotVH: f32  ) -> vec3<f32> {\r\n  var fresnel: f32 = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\r\n  return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\r\n}\r\n\r\nfn V_GGX_SmithCorrelated( alpha: f32, dotNL: f32, dotNV: f32 ) -> f32 {\r\n  var a2: f32 = pow2( alpha );\r\n  var gv: f32 = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\r\n  var gl: f32 = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\r\n  return 0.5 / max( gv + gl, EPSILON );\r\n}\r\n\r\nfn D_GGX( alpha: f32, dotNH: f32 ) -> f32 {\r\n  var a2: f32 = pow2( alpha );\r\n  var denom: f32 = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\r\n  return RECIPROCAL_PI * a2 / pow2( denom );\r\n}\r\n\r\nfn BRDF_GGX( lightDir: vec3<f32>, viewDir: vec3<f32>, normal: vec3<f32>, f0: vec3<f32>, f90: f32, roughness: f32 ) -> vec3<f32> {\r\n  var alpha: f32 = pow2( roughness );\r\n  var halfDir: vec3<f32> = normalize( lightDir + viewDir );\r\n  var dotNL: f32 = saturate( dot( normal, lightDir ) );\r\n  var dotNV: f32 = saturate( dot( normal, viewDir ) );\r\n  var dotNH: f32 = saturate( dot( normal, halfDir ) );\r\n  var dotVH: f32 = saturate( dot( viewDir, halfDir ) );\r\n  var F: vec3<f32> = F_Schlick( f0, f90, dotVH );\r\n  var V: f32 = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\r\n  var D: f32 = D_GGX( alpha, dotNH );\r\n  return F * ( V * D );\r\n}\r\n\r\nfn DFGApprox( normal: vec3<f32>, viewDir: vec3<f32>, roughness: f32 ) -> vec2<f32> {\r\n  var dotNV = saturate( dot( normal, viewDir ) );\r\n  var c0 = vec4<f32>( -1.0, - 0.0275, - 0.572, 0.022 );\r\n  var c1 = vec4<f32>( 1.0, 0.0425, 1.04, - 0.04 );\r\n  var r = roughness * c0 + c1;\r\n  var a004: f32 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\r\n  var fab = vec2<f32>( - 1.04, 1.04 ) * a004 + r.zw;\r\n  return fab;\r\n}\r\n\r\nfn computeMultiscattering( normal: vec3<f32>, viewDir: vec3<f32>, specularColor: vec3<f32>, specularF90: f32, roughness: f32, singleScatter: ptr<function, vec3<f32>>, multiScatter: ptr<function, vec3<f32>> ) {\r\n  var fab = DFGApprox( normal, viewDir, roughness );\r\n  var FssEss = specularColor * fab.x + specularF90 * fab.y;\r\n  var Ess = fab.x + fab.y;\r\n  var Ems = 1.0 - Ess;\r\n  var Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\r\n  var Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\r\n  (*singleScatter) = (*singleScatter) + FssEss;\r\n  (*multiScatter) = (*multiScatter) + (Fms * Ems);\r\n}\r\n\r\nfn RE_Direct_Physical( directLight: IncidentLight, geometry: GeometricContext, material: PhysicalMaterial, reflectedLight: ptr<function, ReflectedLight> ) {\r\n  var dotNL: f32 = saturate( dot( geometry.normal, directLight.direction ) );\r\n  var irradiance: vec3<f32> = dotNL * directLight.color;\r\n  // #ifdef USE_CLEARCOAT\r\n  //     var dotNLcc: f32 = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\r\n  //     var ccIrradiance: vec3<f32> = dotNLcc * directLight.color;\r\n  //     clearcoatSpecular = clearcoatSpecular + ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\r\n  // #endif\r\n  // #ifdef USE_SHEEN\r\n  //     (*reflectedLight).directSpecular = (*reflectedLight).directSpecular + irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\r\n  // #endif\r\n  (*reflectedLight).directSpecular = (*reflectedLight).directSpecular + irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\r\n  (*reflectedLight).directDiffuse = (*reflectedLight).directDiffuse + irradiance * BRDF_Lambert( material.diffuseColor );\r\n}\r\n\r\nfn RE_IndirectDiffuse_Physical( irradiance: vec3<f32>, geometry: GeometricContext, material: PhysicalMaterial, reflectedLight: ptr<function, ReflectedLight> ) {\r\n  (*reflectedLight).indirectDiffuse = (*reflectedLight).indirectDiffuse + (irradiance * BRDF_Lambert( material.diffuseColor ));\r\n}\r\n\r\nfn RE_IndirectSpecular_Physical( radiance: vec3<f32>, irradiance: vec3<f32>, clearcoatRadiance: vec3<f32>, geometry: GeometricContext, material: PhysicalMaterial, reflectedLight: ptr<function, ReflectedLight> ) {\r\n  // #ifdef USE_CLEARCOAT\r\n  //     clearcoatSpecular = clearcoatSpecular + (clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness ));\r\n  // #endif\r\n  var singleScattering = vec3<f32>( 0.0 );\r\n  var multiScattering = vec3<f32>( 0.0 );\r\n  var cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\r\n  computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, &singleScattering, &multiScattering );\r\n  var diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\r\n  (*reflectedLight).indirectSpecular = (*reflectedLight).indirectSpecular + (radiance * singleScattering);\r\n  (*reflectedLight).indirectSpecular = (*reflectedLight).indirectSpecular + (multiScattering * cosineWeightedIrradiance);\r\n  (*reflectedLight).indirectDiffuse = (*reflectedLight).indirectDiffuse + (diffuse * cosineWeightedIrradiance);\r\n}\r\n\r\nfn changeDiffuseToRed( colorPtr: ptr<function, vec4<f32>> ) {\r\n  (*colorPtr).g = 0.0;\r\n  (*colorPtr).b = 0.0;\r\n}\r\n\r\n[[stage(fragment)]]\r\nfn main(\r\n  [[location(0)]] vFragUV: vec2<f32>,\r\n  [[location(1)]] vNormal : vec3<f32>,\r\n  [[location(2)]] vViewPosition : vec3<f32>\r\n) -> [[location(0)]] vec4<f32> {\r\n\r\n  var normal = normalize( vNormal );\r\n  var geometryNormal = normal;\r\n\r\n  var totalEmissiveRadiance: vec3<f32> = materialData.emissive.xyz;\r\n  var diffuseColor = vec4<f32>( materialData.diffuse.xyz, materialData.opacity );\r\n  var reflectedLight: ReflectedLight = ReflectedLight( vec3<f32>( 0.0 ), vec3<f32>( 0.0 ), vec3<f32>( 0.0 ), vec3<f32>( 0.0 ) );\r\n\r\n  ${e => e.defines.diffuseMap &&\r\n  `var texelColor = textureSample(diffuseTexture, diffuseSampler, vFragUV);\r\n  diffuseColor = diffuseColor * texelColor;`}\r\n\r\n  // TODO: Alpha test - discard early\r\n\r\n  // Metalness\r\n  var metalnessFactor: f32 = materialData.metalness;\r\n  // TODO:\r\n  ${e => e.defines.metalnessMap &&\r\n    `vec4 texelMetalness = = textureSample(metalnessMap, mySampler, vFragUV);\r\n    metalnessFactor *= texelMetalness.b;`\r\n  }\r\n\r\n  // Roughness\r\n  var roughnessFactor: f32 = materialData.roughness;\r\n  // TODO:\r\n  ${e => e.defines.roughnessMap &&\r\n    `vec4 texelRoughness = textureSample(roughnessMap, mySampler, vFragUV);\r\n    roughnessFactor *= texelRoughness.b;`\r\n  }\r\n\r\n  var isOrthographic = false;\r\n  var geometry: GeometricContext;\r\n  geometry.position = -vViewPosition;\r\n  geometry.normal = normal;\r\n  geometry.viewDir =  select(normalize( vViewPosition ), vec3<f32>( 0.0, 0.0, 1.0 ), isOrthographic ); // Same as ternary operator (select( false, true, condition ))\r\n\r\n  var directLight: IncidentLight;\r\n  var material: PhysicalMaterial;\r\n\r\n  material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\r\n\r\n  var dxy: vec3<f32> = max( abs( dpdx( geometryNormal ) ), abs( dpdy( geometryNormal ) ) );\r\n  var geometryRoughness: f32 = max( max( dxy.x, dxy.y ), dxy.z );\r\n\r\n  material.roughness = max( roughnessFactor, 0.0525 );\r\n  material.roughness = material.roughness + geometryRoughness;\r\n  material.roughness = min( material.roughness, 1.0 );\r\n\r\n  // #ifdef IOR\r\n  //     #ifdef SPECULAR\r\n  //         float specularIntensityFactor = specularIntensity;\r\n  //         vec3 specularColorFactor = specularColor;\r\n  //         #ifdef USE_SPECULARINTENSITYMAP\r\n  //             specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\r\n  //         #endif\r\n  //         #ifdef USE_SPECULARCOLORMAP\r\n  //             specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\r\n  //         #endif\r\n  //         material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\r\n  //     #else\r\n  //         float specularIntensityFactor = 1.0;\r\n  //         vec3 specularColorFactor = vec3( 1.0 );\r\n  //         material.specularF90 = 1.0;\r\n  //     #endif\r\n  //     material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\r\n  // #else\r\n      material.specularColor = mix( vec3<f32>( 0.04 ), diffuseColor.rgb, metalnessFactor );\r\n      material.specularF90 = 1.0;\r\n  // #endif\r\n\r\n\r\n  // Lighting\r\n  // ========\r\n  var numDirectionalLights = lightingConfigUniform.numDirectionalLights;\r\n\r\n  ${e => e.defines.NUM_DIR_LIGHTS ? `\r\n  for (var i : u32 = 0u; i < numDirectionalLights; i = i + 1u) {\r\n    var directionalLight: DirectionalLight;\r\n    directionalLight.direction = directionLightsUniform.directionalLights[i].direction.xyz;\r\n    directionalLight.color = directionLightsUniform.directionalLights[i].color.xyz;\r\n\r\n    getDirectionalLightInfo( directionalLight, geometry, &directLight );\r\n    RE_Direct_Physical( directLight, geometry, material, &reflectedLight );\r\n  }` : ''}\r\n\r\n  // #if defined( RE_IndirectDiffuse )\r\n  var iblIrradiance = vec3<f32>( 0.0 );\r\n  var irradiance = sceneLightingUniform.ambientLightColor.xyz;\r\n\r\n  // TODO\r\n  // irradiance = irradiance + getLightProbeIrradiance( lightProbe, geometry.normal );\r\n\r\n  // #if defined( RE_IndirectSpecular )\r\n  var radiance = vec3<f32>( 0.0 );\r\n  var clearcoatRadiance = vec3<f32>( 0.0 );\r\n\r\n  // #if defined( RE_IndirectDiffuse )\r\n    // #ifdef USE_LIGHTMAP\r\n    //   vec4 lightMapTexel = texture2D( lightMap, vUv2 );\r\n    //   vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\r\n    //   #ifndef PHYSICALLY_CORRECT_LIGHTS\r\n    //       lightMapIrradiance *= PI;\r\n    //   #endif\r\n    //   irradiance = irradiance + lightMapIrradiance;\r\n    // #endif\r\n    // #if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\r\n    //   iblIrradiance = iblIrradiance + getIBLIrradiance( geometry.normal );\r\n    // #endif\r\n  // #endif\r\n\r\n  // #if defined( RE_IndirectDiffuse )\r\n    RE_IndirectDiffuse_Physical( irradiance, geometry, material, &reflectedLight );\r\n  // #endif\r\n  // #if defined( RE_IndirectSpecular )\r\n    RE_IndirectSpecular_Physical( radiance, iblIrradiance, clearcoatRadiance, geometry, material, &reflectedLight );\r\n  // #endif\r\n\r\n  var totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\r\n  var totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\r\n  var outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\r\n  return vec4<f32>( outgoingLight.xyz, 1.0);\r\n}\r\n`;\r\n\r\ninterface DebugDefines {\r\n  diffuseMap?: Texture;\r\n  normalMap?: Texture;\r\n  metalnessMap?: Texture;\r\n  roughnessMap?: Texture;\r\n  NUM_DIR_LIGHTS: number;\r\n}\r\n\r\nexport class DebugPipeline extends Pipeline<DebugDefines> {\r\n  constructor(name: string, defines: DebugDefines) {\r\n    super(name, vertexShader, fragmentShader, defines);\r\n  }\r\n\r\n  onAddResources(): void {\r\n    const transformResource = new TransformResource();\r\n    this.addTemplate(transformResource);\r\n\r\n    const materialResource = new MaterialResource();\r\n    this.addTemplate(materialResource);\r\n\r\n    const lightingResource = new LightingResource();\r\n    this.addTemplate(lightingResource);\r\n\r\n    if (this.defines.diffuseMap) {\r\n      const resource = new TextureResource(this.defines.diffuseMap, \"diffuse\");\r\n      this.addTemplate(resource);\r\n    }\r\n\r\n    if (this.defines.normalMap) {\r\n      const resource = new TextureResource(this.defines.normalMap, \"normal\");\r\n      this.addTemplate(resource);\r\n    }\r\n  }\r\n\r\n  build(gameManager: GameManager): void {\r\n    super.build(gameManager);\r\n\r\n    // Build the shaders - should go after adding the resources as we might use those in the shader source\r\n    const vertSource = shaderBuilder(this.vertexSource, this);\r\n    const fragSource = shaderBuilder(this.fragmentSource, this);\r\n\r\n    this.renderPipeline = gameManager.device.createRenderPipeline({\r\n      ...defaultPipelineDescriptor,\r\n      label: \"Debug Pipeline\",\r\n      vertex: {\r\n        module: gameManager.device.createShaderModule({\r\n          code: vertSource,\r\n        }),\r\n        entryPoint: \"main\",\r\n        buffers: [\r\n          {\r\n            arrayStride: Float32Array.BYTES_PER_ELEMENT * 3, // (3 + 2)\r\n            attributes: [\r\n              {\r\n                shaderLocation: 0,\r\n                format: \"float32x3\",\r\n                offset: 0,\r\n              },\r\n              // {\r\n              //   shaderLocation: 1,\r\n              //   format: \"float32x3\",\r\n              //   offset: 12,\r\n              // },\r\n            ],\r\n          },\r\n          {\r\n            arrayStride: Float32Array.BYTES_PER_ELEMENT * 3,\r\n            attributes: [\r\n              {\r\n                shaderLocation: 1,\r\n                format: \"float32x3\",\r\n                offset: 0,\r\n              },\r\n            ],\r\n          },\r\n          {\r\n            arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,\r\n            attributes: [\r\n              {\r\n                shaderLocation: 2,\r\n                format: \"float32x2\",\r\n                offset: 0,\r\n              },\r\n            ],\r\n          },\r\n        ],\r\n      },\r\n      fragment: {\r\n        module: gameManager.device.createShaderModule({\r\n          code: fragSource,\r\n        }),\r\n        entryPoint: \"main\",\r\n        targets: [{ format: gameManager.format }],\r\n      },\r\n    });\r\n  }\r\n}\r\n","import { GameManager } from \"../../GameManager\";\r\nimport { UNIFORM_TYPES_MAP } from \"./MemoryUtils\";\r\nimport { BindingData, PipelineResourceTemplate, Template } from \"./PipelineResourceTemplate\";\r\nimport { GroupType } from \"../../../../common/GroupType\";\r\nimport { ResourceType } from \"../../../../common/ResourceType\";\r\nimport { Defines } from \"../shader-lib/Utils\";\r\nimport { Pipeline } from \"../Pipeline\";\r\n\r\nexport class LightingResource extends PipelineResourceTemplate {\r\n  static lightingConfig: GPUBuffer;\r\n  static directionLightsBuffer: GPUBuffer;\r\n  static sceneLightingBuffer: GPUBuffer;\r\n\r\n  static numDirLights: number = 0;\r\n  static rebuildDirectionLights = true;\r\n\r\n  directionLightBinding: number;\r\n  lightingConfigBinding: number;\r\n  sceneLightingBinding: number;\r\n\r\n  constructor() {\r\n    super(GroupType.Material, ResourceType.Lighting);\r\n  }\r\n\r\n  build<T extends Defines<T>>(manager: GameManager, pipeline: Pipeline<T>, curBindIndex: number): Template {\r\n    this.lightingConfigBinding = curBindIndex;\r\n    this.sceneLightingBinding = curBindIndex + 1;\r\n    this.directionLightBinding = pipeline.defines.NUM_DIR_LIGHTS ? curBindIndex + 2 : -1;\r\n    const group = pipeline.groupIndex(this.groupType);\r\n\r\n    if (!LightingResource.lightingConfig) {\r\n      const LIGHTING_CONFIG_SIZE = UNIFORM_TYPES_MAP[\"u32\"];\r\n      const SCENE_LIGHTING_BUFFER = UNIFORM_TYPES_MAP[\"vec4<f32>\"];\r\n\r\n      LightingResource.lightingConfig = manager.device.createBuffer({\r\n        label: \"lightingConfigUniform\",\r\n        size: LIGHTING_CONFIG_SIZE,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n        mappedAtCreation: true,\r\n      });\r\n\r\n      LightingResource.sceneLightingBuffer = manager.device.createBuffer({\r\n        label: \"sceneLightingBuffer\",\r\n        size: SCENE_LIGHTING_BUFFER,\r\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n        mappedAtCreation: true,\r\n      });\r\n\r\n      // Defaults for lighting info\r\n      // prettier-ignore\r\n      const lightInofoDefaults = new Uint32Array([\r\n        0, // Num Directional lights\r\n      ]);\r\n\r\n      // Defaults for scene lights buffer\r\n      // prettier-ignore\r\n      const sceneLightingBufferDefaults = new  Float32Array([\r\n        0.4, 0.4, 0.4, 0, // Ambient Light Color\r\n      ]);\r\n\r\n      // Set defaults\r\n      new Float32Array(LightingResource.lightingConfig.getMappedRange()).set(lightInofoDefaults);\r\n      LightingResource.lightingConfig.unmap();\r\n\r\n      new Float32Array(LightingResource.sceneLightingBuffer.getMappedRange()).set(sceneLightingBufferDefaults);\r\n      LightingResource.sceneLightingBuffer.unmap();\r\n    }\r\n\r\n    if (LightingResource.rebuildDirectionLights && LightingResource.numDirLights > 0) {\r\n      LightingResource.rebuildDirectionLights = false;\r\n\r\n      if (LightingResource.directionLightsBuffer) LightingResource.directionLightsBuffer.destroy();\r\n\r\n      LightingResource.directionLightsBuffer = manager.device.createBuffer({\r\n        label: \"dirLightsBuffer\",\r\n        size: UNIFORM_TYPES_MAP[\"vec4<f32>\"] * 2 * LightingResource.numDirLights,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      });\r\n    }\r\n\r\n    // prettier-ignore\r\n    return {\r\n      group,\r\n      bindings: [ { buffer: LightingResource.lightingConfig, }, { buffer: LightingResource.sceneLightingBuffer },\r\n      ].concat(LightingResource.numDirLights ? { buffer: LightingResource.directionLightsBuffer } : []),\r\n\r\n      fragmentBlock: `struct SceneLightingUniform {\r\n        ambientLightColor: vec4<f32>;\r\n      };\r\n\r\n      struct LightingConfigUniform {\r\n        numDirectionalLights: u32;\r\n      };\r\n\r\n      [[group(${group}), binding(${this.lightingConfigBinding})]] var<uniform> lightingConfigUniform: LightingConfigUniform;\r\n      [[group(${group}), binding(${this.sceneLightingBinding})]] var<uniform> sceneLightingUniform: SceneLightingUniform;\r\n\r\n\r\n      ${pipeline.defines.NUM_DIR_LIGHTS ? `\r\n      struct DirectionLightUniform {\r\n        direction : vec4<f32>;\r\n        color : vec4<f32>;\r\n      };\r\n\r\n      struct DirectionLightsUniform {\r\n        directionalLights: array<DirectionLightUniform>;\r\n      };\r\n\r\n      [[group(${group}), binding(${this.directionLightBinding})]] var<storage, read> directionLightsUniform: DirectionLightsUniform;\r\n      ` : ''}\r\n      `,\r\n      vertexBlock: null,\r\n    };\r\n  }\r\n\r\n  getBindingData(manager: GameManager, pipeline: GPURenderPipeline): BindingData {\r\n    return {\r\n      binds: [\r\n        {\r\n          binding: this.lightingConfigBinding,\r\n          resource: {\r\n            buffer: LightingResource.lightingConfig,\r\n          },\r\n        },\r\n        {\r\n          binding: this.sceneLightingBinding,\r\n          resource: {\r\n            buffer: LightingResource.sceneLightingBuffer,\r\n          },\r\n        },\r\n      ].concat(\r\n        LightingResource.numDirLights\r\n          ? {\r\n              binding: this.directionLightBinding,\r\n              resource: {\r\n                buffer: LightingResource.directionLightsBuffer,\r\n              },\r\n            }\r\n          : []\r\n      ),\r\n      buffer: null,\r\n    };\r\n  }\r\n}\r\n","import { GameManager } from \"../../GameManager\";\r\nimport { BindingData, PipelineResourceTemplate, Template } from \"./PipelineResourceTemplate\";\r\nimport { Defines } from \"../shader-lib/Utils\";\r\nimport { Pipeline } from \"../Pipeline\";\r\nimport { GroupType } from \"../../../../common/GroupType\";\r\nimport { ResourceType } from \"../../../../common/ResourceType\";\r\n\r\nexport class MaterialResource extends PipelineResourceTemplate {\r\n  binding: number;\r\n\r\n  constructor() {\r\n    super(GroupType.Material, ResourceType.Material);\r\n  }\r\n\r\n  build<T extends Defines<T>>(manager: GameManager, pipeline: Pipeline<T>, curBindIndex: number): Template {\r\n    this.binding = curBindIndex;\r\n    const group = pipeline.groupIndex(this.groupType);\r\n\r\n    // prettier-ignore\r\n    const initialValues = new Float32Array([\r\n      1, 1, 1, 0,         // Diffuse\r\n      0.1, 0.1, 0.1, 0,   // Emissive\r\n      1,                  // Alpha\r\n      0,                  // Metalness\r\n      0.5                 // Roughness\r\n    ]);\r\n    const SIZE = Float32Array.BYTES_PER_ELEMENT * initialValues.length;\r\n\r\n    const buffer = manager.device.createBuffer({\r\n      label: \"materialData\",\r\n      size: SIZE,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true,\r\n    });\r\n\r\n    // Set defaults\r\n    new Float32Array(buffer.getMappedRange()).set(initialValues);\r\n    buffer.unmap();\r\n\r\n    const resource: GPUBindingResource = {\r\n      buffer: buffer,\r\n      offset: 0,\r\n      size: SIZE,\r\n    };\r\n\r\n    return {\r\n      group,\r\n      bindings: [resource],\r\n      // prettier-ignore\r\n      fragmentBlock: `\r\n      struct MaterialData {\r\n        diffuse: vec4<f32>;\r\n        emissive: vec4<f32>;\r\n        opacity: f32;\r\n        metalness: f32;\r\n        roughness: f32;\r\n      };\r\n\r\n      [[group(${group}), binding(${curBindIndex})]] var<uniform> materialData: MaterialData;\r\n      `,\r\n      vertexBlock: null,\r\n    };\r\n  }\r\n\r\n  getBindingData(manager: GameManager, pipeline: GPURenderPipeline): BindingData {\r\n    // prettier-ignore\r\n    const initialValues = new Float32Array([\r\n      1, 1, 1, 0,         // Diffuse\r\n      0.1, 0.1, 0.1, 0,   // Emissive\r\n      1,                  // Alpha\r\n      0,                  // Metalness\r\n      0.5                 // Roughness\r\n    ]);\r\n    const SIZE = Float32Array.BYTES_PER_ELEMENT * initialValues.length;\r\n\r\n    const buffer = manager.device.createBuffer({\r\n      label: \"materialData\",\r\n      size: SIZE,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n      mappedAtCreation: true,\r\n    });\r\n\r\n    // Set defaults\r\n    new Float32Array(buffer.getMappedRange()).set(initialValues);\r\n    buffer.unmap();\r\n\r\n    const resource: GPUBindingResource = {\r\n      buffer: buffer,\r\n      offset: 0,\r\n      size: SIZE,\r\n    };\r\n\r\n    return {\r\n      binds: [\r\n        {\r\n          binding: this.binding,\r\n          resource,\r\n        },\r\n      ],\r\n      buffer,\r\n    };\r\n  }\r\n}\r\n","export const UNIFORM_TYPES_MAP = {\r\n  \"mat4x4<f32>\": 16 * Float32Array.BYTES_PER_ELEMENT,\r\n  \"mat3x3<f32>\": 12 * Float32Array.BYTES_PER_ELEMENT,\r\n  \"vec4<f32>\": 4 * Float32Array.BYTES_PER_ELEMENT,\r\n  \"vec3<f32>\": 3 * Float32Array.BYTES_PER_ELEMENT,\r\n  \"vec2<f32>\": 2 * Float32Array.BYTES_PER_ELEMENT,\r\n  f32: 1 * Float32Array.BYTES_PER_ELEMENT,\r\n  i32: 1 * Int32Array.BYTES_PER_ELEMENT,\r\n  u32: 1 * Uint32Array.BYTES_PER_ELEMENT,\r\n  i16: 1 * Int16Array.BYTES_PER_ELEMENT,\r\n  u16: 1 * Uint16Array.BYTES_PER_ELEMENT,\r\n};\r\n","export class PipelineResourceInstance {\r\n  group: number;\r\n  bindGroup: GPUBindGroup;\r\n  buffers: GPUBuffer[] | null;\r\n\r\n  constructor(group: number, bindGroup: GPUBindGroup, buffer: GPUBuffer[] | null = null) {\r\n    this.group = group;\r\n    this.bindGroup = bindGroup;\r\n    this.buffers = buffer;\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.buffers) this.buffers!.forEach((b) => b.destroy());\r\n  }\r\n}\r\n","import { GameManager } from \"../../GameManager\";\r\nimport { Pipeline } from \"../Pipeline\";\r\nimport { GroupType } from \"../../../../common/GroupType\";\r\nimport { ResourceType } from \"../../../../common/ResourceType\";\r\nimport { Defines } from \"../shader-lib/Utils\";\r\n\r\nexport type Template = {\r\n  group: number;\r\n  bindings: GPUBindingResource[];\r\n  fragmentBlock: string | null;\r\n  vertexBlock: string | null;\r\n};\r\n\r\nexport type BindingData = {\r\n  binds: GPUBindGroupEntry[];\r\n  buffer: GPUBuffer | null;\r\n};\r\n\r\nexport abstract class PipelineResourceTemplate {\r\n  template: Template;\r\n  groupType: GroupType;\r\n  resourceType: ResourceType;\r\n  id?: string;\r\n\r\n  constructor(groupType: GroupType, groupSubType: ResourceType, id?: string) {\r\n    this.groupType = groupType;\r\n    this.resourceType = groupSubType;\r\n    this.id = id;\r\n  }\r\n\r\n  /** Creates the resource. Must return a group index*/\r\n  abstract build<T extends Defines<T>>(manager: GameManager, pipeline: Pipeline<T>, curBindIndex: number): Template;\r\n  abstract getBindingData(manager: GameManager, pipeline: GPURenderPipeline): BindingData;\r\n}\r\n","import { GameManager } from \"../../GameManager\";\r\nimport { Texture } from \"../../Texture\";\r\nimport { BindingData, PipelineResourceTemplate, Template } from \"./PipelineResourceTemplate\";\r\nimport { Pipeline } from \"../Pipeline\";\r\nimport { Defines } from \"../shader-lib/Utils\";\r\nimport { GroupType } from \"../../../../common/GroupType\";\r\nimport { ResourceType } from \"../../../../common/ResourceType\";\r\n\r\nexport class TextureResource extends PipelineResourceTemplate {\r\n  texture: Texture;\r\n  textureBind: number;\r\n  samplerBind: number;\r\n\r\n  constructor(texture: Texture, id: string) {\r\n    super(GroupType.Material, ResourceType.Texture, id);\r\n    this.texture = texture;\r\n  }\r\n\r\n  build<T extends Defines<T>>(manager: GameManager, pipeline: Pipeline<T>, curBindIndex: number): Template {\r\n    this.samplerBind = curBindIndex;\r\n    this.textureBind = curBindIndex + 1;\r\n    const group = pipeline.groupIndex(this.groupType);\r\n\r\n    // prettier-ignore\r\n    return {\r\n      group,\r\n      bindings: [manager.samplers[0], this.texture!.gpuTexture.createView()],\r\n      fragmentBlock: `\r\n      ${pipeline.defines.diffuseMap && `\r\n      [[group(${group}), binding(${this.samplerBind})]] var ${this.id}Sampler: sampler;\r\n      [[group(${group}), binding(${this.textureBind})]] var ${this.id}Texture: texture_2d<f32>;`\r\n      }`,\r\n      vertexBlock: null,\r\n    };\r\n  }\r\n\r\n  getBindingData(manager: GameManager, pipeline: GPURenderPipeline): BindingData {\r\n    return {\r\n      binds: [\r\n        {\r\n          binding: this.samplerBind,\r\n          resource: manager.samplers[0],\r\n        },\r\n        {\r\n          binding: this.textureBind,\r\n          resource: this.texture!.gpuTexture.createView(),\r\n        },\r\n      ],\r\n      buffer: null,\r\n    };\r\n  }\r\n}\r\n","import { GameManager } from \"../../GameManager\";\r\nimport { UNIFORM_TYPES_MAP } from \"./MemoryUtils\";\r\nimport { BindingData, PipelineResourceTemplate, Template } from \"./PipelineResourceTemplate\";\r\nimport { Pipeline } from \"../Pipeline\";\r\nimport { Defines } from \"../shader-lib/Utils\";\r\nimport { GroupType } from \"../../../../common/GroupType\";\r\nimport { ResourceType } from \"../../../../common/ResourceType\";\r\n\r\nexport class TransformResource extends PipelineResourceTemplate {\r\n  binding: number;\r\n\r\n  constructor() {\r\n    super(GroupType.Transform, ResourceType.Transform);\r\n  }\r\n\r\n  build<T extends Defines<T>>(manager: GameManager, pipeline: Pipeline<T>, curBindIndex: number): Template {\r\n    this.binding = curBindIndex;\r\n    const group = pipeline.groupIndex(this.groupType);\r\n\r\n    const SIZEOF_MATRICES = UNIFORM_TYPES_MAP[\"mat4x4<f32>\"] * 2 + UNIFORM_TYPES_MAP[\"mat3x3<f32>\"];\r\n\r\n    const buffer = manager.device.createBuffer({\r\n      label: \"transform\",\r\n      size: SIZEOF_MATRICES,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    return {\r\n      group,\r\n      bindings: [\r\n        {\r\n          buffer,\r\n        },\r\n      ],\r\n      fragmentBlock: null,\r\n      // prettier-ignore\r\n      vertexBlock: `\r\n      struct TransformUniform {\r\n        projMatrix: mat4x4<f32>;\r\n        modelViewMatrix: mat4x4<f32>;\r\n        normalMatrix: mat3x3<f32>;\r\n      };\r\n      [[group(${group}), binding(${curBindIndex})]] var<uniform> uniforms: TransformUniform;\r\n      `,\r\n    };\r\n  }\r\n\r\n  getBindingData(manager: GameManager, pipeline: GPURenderPipeline): BindingData {\r\n    const SIZEOF_MATRICES = UNIFORM_TYPES_MAP[\"mat4x4<f32>\"] * 2 + UNIFORM_TYPES_MAP[\"mat3x3<f32>\"];\r\n\r\n    const buffer = manager.device.createBuffer({\r\n      label: \"transform\",\r\n      size: SIZEOF_MATRICES,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n    });\r\n\r\n    return {\r\n      binds: [\r\n        {\r\n          binding: this.binding,\r\n          resource: {\r\n            buffer: buffer,\r\n            offset: 0,\r\n            size: SIZEOF_MATRICES,\r\n          },\r\n        },\r\n      ],\r\n      buffer,\r\n    };\r\n  }\r\n}\r\n","export const mathConstants = /* wgsl */ `\r\nlet PI: f32 = 3.141592653589793;\r\nlet PI2: f32 = 6.283185307179586;\r\nlet PI_HALF: f32 = 1.5707963267948966;\r\nlet RECIPROCAL_PI: f32 = 0.3183098861837907;\r\nlet RECIPROCAL_PI2: f32 = 0.15915494309189535;\r\nlet EPSILON: f32 = 0.000001;\r\n`;\r\n\r\nexport const mathFunctions = /* wgsl */ `\r\nfn saturate( a: f32 ) -> f32 {\r\n    return clamp( a, 0.0, 1.0 );\r\n}\r\n\r\nfn whiteComplement( a: f32 ) -> f32 {\r\n    return ( 1.0 - saturate( a ) );\r\n}\r\n\r\nfn pow2( x: f32 ) -> f32 {\r\n    return x*x;\r\n}\r\n\r\nfn pow3( x: f32 ) -> f32 {\r\n    return x*x*x;\r\n}\r\n\r\nfn pow4( x: f32 ) -> f32 {\r\n    var x2 = x*x;\r\n    return x2*x2;\r\n}\r\n\r\nfn max3( v: vec3<f32> ) -> f32 {\r\n    return max( max( v.x, v.y ), v.z );\r\n}\r\n\r\nfn average( color: vec3<f32> )-> f32 {\r\n    return dot( color, vec3( 0.3333 ) );\r\n}\r\n\r\nfn rand( uv: vec2<f32> ) -> f32 {\r\n    var a: f32 = 12.9898;\r\n    var b: f32 = 78.233;\r\n    var c: f32 = 43758.5453;\r\n    var dt = dot( uv.xy, vec2<f32>( a, b ) );\r\n    var sn = dt % PI;\r\n    return fract( sin( sn ) * c );\r\n}\r\n\r\nfn precisionSafeLength( v: vec3<f32> )-> f32 {\r\n    return length( v );\r\n}`;\r\n","import { Texture } from \"../../Texture\";\r\nimport { Pipeline } from \"../Pipeline\";\r\n\r\nexport type Defines<T> = {\r\n  [K in keyof T]: T[K];\r\n} & {\r\n  diffuseMap?: Texture;\r\n  normalMap?: Texture;\r\n  NUM_DIR_LIGHTS: number;\r\n};\r\n\r\nexport type ShaderFunction<T extends Defines<T>> =\r\n  | ((pipeline: Pipeline<T>) => number | string | boolean | undefined | null)\r\n  | string;\r\nexport interface SourceFragments<T extends Defines<T>> {\r\n  strings: TemplateStringsArray;\r\n  expressions: (ShaderFunction<T> | string)[];\r\n}\r\n\r\nexport function shader<T extends Defines<T>>(\r\n  strings: TemplateStringsArray,\r\n  ...expr: ShaderFunction<T>[]\r\n): SourceFragments<T> {\r\n  return {\r\n    strings,\r\n    expressions: expr,\r\n  };\r\n}\r\n\r\nexport function shaderBuilder<T extends Defines<T>>(sourceFragments: SourceFragments<T>, pipeline: Pipeline<T>) {\r\n  let str = \"\";\r\n  sourceFragments.strings.forEach((string, i) => {\r\n    if (typeof sourceFragments.expressions[i] === \"string\" || typeof sourceFragments.expressions[i] === \"number\")\r\n      str += string + (sourceFragments.expressions[i] || \"\");\r\n    else if (sourceFragments.expressions[i]) {\r\n      const fnOrText = sourceFragments.expressions[i];\r\n      if (typeof fnOrText === \"string\") {\r\n        str += string + fnOrText;\r\n      } else {\r\n        const expressionReturn = fnOrText(pipeline);\r\n\r\n        if (typeof expressionReturn === \"string\") {\r\n          str += string + expressionReturn;\r\n        } else if (typeof expressionReturn === \"number\") {\r\n          str += string + expressionReturn.toString();\r\n        } else {\r\n          str += string;\r\n        }\r\n      }\r\n    } else {\r\n      str += string;\r\n    }\r\n  });\r\n  return str;\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","import wasmFile from \"../../build/untouched.wasm\";\r\nimport type * as MyModule from \"../../build/types\";\r\nimport { createBindingsGPU, bindExports } from \"./AppBindings\";\r\nimport loader, { ASUtil, ResultObject } from \"@assemblyscript/loader\";\r\n\r\nimport { GameManager } from \"./core/GameManager\";\r\n\r\nexport type ExportType = ResultObject & { exports: ASUtil & typeof MyModule };\r\nexport type WasmInterface = ASUtil & typeof MyModule;\r\n\r\n// Creating WASM with Linear memory\r\nconst memory = new WebAssembly.Memory({ initial: 100 });\r\nconst importObject: WebAssembly.Imports = {\r\n  env: {\r\n    memory: memory,\r\n    seed: Date.now,\r\n    abort: (...args: any[]) => {\r\n      console.log(\"abort\");\r\n      console.log((importObject.env as any).getString(args[0]));\r\n    },\r\n    getString: (string_index: number) => {\r\n      const buffer = (importObject.env as any).memory.buffer;\r\n      const U32 = new Uint32Array(buffer);\r\n      const id_addr = string_index / 4 - 2;\r\n      const id = U32[id_addr];\r\n      if (id !== 0x01) throw Error(`not a string index=${string_index} id=${id}`);\r\n      const len = U32[id_addr + 1];\r\n      const str = new TextDecoder(\"utf-16\").decode(buffer.slice(string_index, string_index + len));\r\n      return str;\r\n    },\r\n  },\r\n};\r\n\r\nconst gameManager = new GameManager(\"canvas\");\r\ncreateBindingsGPU(importObject, gameManager);\r\n\r\nasync function init() {\r\n  // Load the wasm file\r\n  const obj = await loader.instantiateStreaming<typeof MyModule>(fetch(wasmFile), importObject);\r\n  const message = document.querySelector(\"#message\") as HTMLElement;\r\n\r\n  // Bind the newly created export file\r\n  bindExports(obj);\r\n\r\n  try {\r\n    await gameManager.init(obj.exports);\r\n  } catch (err: unknown) {\r\n    message.style.display = \"initial\";\r\n    message.innerHTML = (err as Error).message;\r\n  }\r\n\r\n  (document.querySelector(\"#apply\") as HTMLButtonElement).addEventListener(\"click\", () => {\r\n    (document.querySelector(\"#input\") as HTMLInputElement).value;\r\n  });\r\n}\r\n\r\ninit();\r\n"],"sourceRoot":""}