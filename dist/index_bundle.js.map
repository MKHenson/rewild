{"version":3,"file":"index_bundle.js","mappings":"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,EAAElN,CAAC,IAAIA,CAAC,CAACwD,OAAF,CAAU2J,SAAV,GAAsBnN,CAAC,CAAClF,iBAAF,CAAoBxI,sEAApB,EAA0C,QAA1C,EAAqD0I,QAArD,CAA8DkS,aAApF,GAAoG,EAAG;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAER,oEAAc;AAChB,EAAEC,oEAAc;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI3M,CAAC,IAAIA,CAAC,CAACwD,OAAF,CAAU5L,UAAV,IACN;AACH,4CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,IAAIoI,CAAC,IAAIA,CAAC,CAACwD,OAAF,CAAU4J,YAAV,IACJ;AACL,yCACG;AACH;AACA;AACA;AACA;AACA,IAAIpN,CAAC,IAAIA,CAAC,CAACwD,OAAF,CAAU6J,YAAV,IACJ;AACL,yCACG;AACH;AA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ADH;AAAA,QACoB,SADpB;AAAA,aACgC,cAAaA,KAAK,CAACK,OAAQ,EAD3D;AAAA;;AAAA,QAC8D,KAD9D;AAAA,aACqE;AAAEyB,QAAAA,SAAS,EAAE9B,KAAK,CAAC+B;AAAnB,OADrE;AAAA;;AAAA;AAAA,aAEK/B,KAAK,CAACO,QAFX;AAAA;;AAAA;AAKD,CANM;AAQP,MAAMyB,gBAAgB,GAAGnD,+DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA9CA;;;;;;;;;;;;;;ACjBO,MAAMoD,KAAmB,GAAG;AACjCC,EAAAA,MAAM,EAAE;AACNC,IAAAA,OAAO,EAAE;AADH;AADyB,CAA5B;;;;;;;;;;;;;;ACFP,iEAAe,qBAAuB,mBAAmB;;;;;;;;;;;;;;;;;;ACAzD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C;AACA,yDAAyD;AACzD,0BAA0B,wBAAwB,KAAK,wBAAwB,GAAG,KAAK,GAAG,KAAK;AAC/F;AACA;AACA;AACA,0BAA0B,uBAAuB,EAAE,aAAa,EAAE,4BAA4B;AAC9F;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;;AAEA;AACA;AACA;AACA,wFAAwF,GAAG,UAAU,KAAK;AAC1G;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D;AACA;;AAEA;AACA;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA,iEAAiE;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,uDAAuD,IAAI;AAC3D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,KAAK;AACjC,4BAA4B,KAAK;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACO,+CAA+C;AACtD;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACO,6CAA6C;AACpD;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACO,wDAAwD;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACO,+CAA+C;AACtD;AACA,kBAAkB;AAClB,0EAA0E,WAAW;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,iDAAiD,UAAU,qCAAqC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD,yBAAyB,4BAA4B;AACrD;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU,OAAO;AACjB,4CAA4C;AAC5C;AACA;AACA,WAAW;AACX;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe;AACf;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;;;;;ACtbF,OAAO,QAAQ,8JAA8J,2BAA2B,yBAAyB,oBAAoB,mBAAmB,yCAAyC,KAAK,OAAO,OAAO,IAAI,6CAA6C,mBAAmB,gBAAgB,WAAW,gCAAgC,0BAA0B,wBAAwB,kOAAkO,GAAG,mBAAmB,MAAM,OAAO,KAAK,OAAO,uBAAuB,SAAS,4BAA4B,SAAS,SAAS,iBAAiB,8BAA8B,aAAa,KAAK,WAAW,+BAA+B,aAAa,MAAM,UAAU,mBAAmB,WAAW,EAAE,KAAK,0BAA0B,wDAAwD,kBAAkB,YAAY,KAAK,UAAU,oBAAoB,eAAe,iBAAiB,oDAAoD,cAAc,+BAA+B,WAAW,cAAc,6DAA6D,+DAA+D,0BAA0B,KAAK,cAAc,cAAc,mBAAmB,mHAAmH,6BAA6B,oBAAoB,IAAI,YAAY,IAAI,EAAE,oBAAoB,kBAAkB,gBAAgB,eAAe,kBAAkB,gBAAgB,gBAAgB,sBAAsB,+BAA+B,mBAAmB,aAAa,6EAA6E,QAAQ,0DAA0D,iBAAkG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACA/mE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4BAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW,wBAAwB,EAAE,6BAA6B;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,CAAO;AAC1D;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW,IAAI,YAAY;AACvD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wIAAwI;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB,EAAE,6BAA6B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,iDAAiD;AACjD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,wDAAwD;AACpK;AACA;AACA;AACA;AACA,kHAAkH;AAClH;AACA,IAAI,4DAA4D;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,0BAA0B;AAC1B;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA,GAAG,SAAS;AACZ;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,kDAAkD,KAAK,GAAG,IAAI;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,YAAY,IAAa;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH;AACrH;AACA,4CAA4C;AAC5C,MAAM;AACN,0CAA0C;AAC1C;AACA,2CAA2C,kBAAkB,GAAG,qCAAqC;AACrG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG,EAAE;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA,2BAA2B;AAC3B;AACA;AACA,cAAc,gBAAgB;AAC9B,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,yCAAyC;AACzC,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA,gDAAgD;AAChD,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA,IAAI;AACJ,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC,YAAY,YAAY;AACxB;AACA,qCAAqC;AACrC;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA,mCAAmC,mBAAmB,GAAG,UAAU,mBAAmB;AACtF,mDAAmD;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,qDAAqD,iDAAiD;AACtG,iDAAiD,oEAAoE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,EAAE,YAAY,UAAU,UAAU;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;;AAE4pB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3jD/f;AACU;;AAEvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,oDAAU;AACnB;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,UAAU;AACV,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE,oDAAU;AACZ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mIAAmI,YAAY,MAAM,KAAK;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB,gBAAgB,KAAK;AACrB,MAAM,eAAe,KAAK;AAC1B,IAAI;AACJ;AACA,IAAI;AACJ;AACA,yCAAyC;AACzC,2CAA2C;AAC3C;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAkB;AACtB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG,0DAAoB;AACvB;AACA;AACA;AACA;AACA,EAAE,4DAAkB;AACpB;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,EAAE,4DAAsB;AACxB,EAAE,yDAAmB;AACrB,EAAE,uDAAiB;AACnB,EAAE,yDAAmB;AACrB,EAAE,2DAAqB;AACvB,EAAE,0DAAoB;AACtB;AACA;AACA;AACA;AACA;AACA,EAAE,0DAAoB;AACtB;AACA;AACA;AACA;AACA,OAAO,0DAAoB,aAAa,+DAAyB;AACjE;AACA;AACA,MAAM,4DAAsB,EAAE,gEAA0B;AACxD,EAAE,qEAA4B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0DAAoB;AAC1B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,yDAAmB,KAAK,gEAA0B;AACxD;AACA;AACA;AACA;AACA,QAAQ,EAAE,kDAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gEAA0B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ,4EAA4E;AAC5E,IAAI;AACJ;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,IAAI,4DAAkB;AACtB;AACA,EAAE,4DAAkB;AACpB;AACA;AACA;AACA,MAAM,0DAAoB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ,QAAQ,0DAAoB;AAC5B;AACA,IAAI;AACJ,IAAI,4DAAkB;AACtB;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA,MAAM,4DAAkB;AACxB;AACA;AACA,QAAQ,0DAAoB;AAC5B,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ,QAAQ,0DAAoB;AAC5B;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA,MAAM,4DAA4D;AAClE;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,0GAA0G;AAC1G,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA,uCAAuC,+DAAyB;AAChE;AACA;AACA;AACA,kBAAkB,0DAAoB;AACtC,YAAY,WAAW,EAAE,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS,0DAAoB;AAC7B;;AAEA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,yDAAe;AACjB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,QAAQ,0DAAoB;AAC5B,uBAAuB,sDAAY;AACnC;AACA;AACA,MAAM;AACN;AACA;AACA,8BAA8B,sDAAY;AAC1C;AACA,IAAI,oDAAU;AACd,IAAI,mDAAS;AACb,UAAU,0DAAoB,0BAA0B;AACxD,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI,mDAAS;AACb;AACA;AACA;AACA;AACA,sBAAsB,oDAAU;AAChC,SAAS,oDAAU;AACnB;AACA;AACA;AACA;AACA,WAAW,8CAAQ;AACnB,SAAS;AACT,eAAe,iDAAO;AACtB;AACA;AACA,mBAAmB,0DAAoB;AACvC;AACA;AACA;AACA,GAAG;AACH;;AAE8mB;;;;;;;;;;;;;;;;;;;;;;;;;;ACljB3jB;AAQjC;AAC8C;AACN;AACnD;AACP,EAAE,6CAAW;AACb;AACA,qBAAqB,uDAAa;AAC3B;AACP,SAAS,yDAAe;AACxB;AACA;AACA;AACA;AACA,GAAG;AACH;AACO;AACP,SAAS,oDAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAU;AAC9B,wBAAwB,oDAAU,UAAU,OAAO;AACnD,oBAAoB,oDAAU;AAC9B;AACA;AACA;AACA;AACA,0BAA0B,6CAAS;AACnC,cAAc,yDAAyD;AACvE;AACA;AACA;AACA;AACA,OAAO;AACP,gCAAgC,oDAAU;AAC1C;AACA;AACA;AACA;AACA,QAAQ,SAAS,kDAAQ;AACzB,gCAAgC,oDAAU;AAC1C,aAAa,iDAAG;AAChB,eAAe,WAAW,aAAa,UAAU;AACjD,UAAU,uDAAS;AACnB;AACA;AACA,QAAQ;AACR;AACA,QAAQ,oDAAM;AACd;AACA;AACA;AACA;AACA,aAAa,iDAAO;AACpB,eAAe,6CAAS,GAAG,0CAA0C;AACrE,OAAO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,GAAG;AACH,CAAC;AACD;AACO;AACP,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;;;;;;;UCpFA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AAEArU,QAAQ,CAAC1H,gBAAT,CAA0B,kBAA1B,EAA+C4H,CAAD,IAAO;AACnD,MAAIF,QAAQ,CAACuU,UAAT,KAAwB,aAAxB,IAAyCvU,QAAQ,CAACuU,UAAT,KAAwB,UAArE,EAAiF;AAC/ErgB,IAAAA,oDAAM,CACJ,MAAM,8DACH,kEADH;AACiB,WADjB,EACwBigB,4CADxB;;AAAA;AAAA,6EAEK,oEAFL;AAAA;;AAAA,MADI,EAMJnU,QAAQ,CAACyR,aAAT,CAAuB,cAAvB,CANI,CAAN;AAQD;AACF,CAXD,E","sources":["webpack://main/webpack/universalModuleDefinition","webpack://main/./src/common/Commands.ts","webpack://main/./src/common/GroupType.ts","webpack://main/./src/common/PipelineType.ts","webpack://main/./src/common/ResourceType.ts","webpack://main/./src/ts/AppBindings.ts","webpack://main/./src/ts/core/GameManager.ts","webpack://main/./src/ts/core/InputManager.ts","webpack://main/./src/ts/core/RenderQueueManager.ts","webpack://main/./src/ts/core/Texture.ts","webpack://main/./src/ts/core/Utils.ts","webpack://main/./src/ts/core/WasmManager.ts","webpack://main/./src/ts/core/pipelines/DefaultPipelineDescriptor.ts","webpack://main/./src/ts/core/pipelines/Pipeline.ts","webpack://main/./src/ts/core/pipelines/debug-pipeline/index.ts","webpack://main/./src/ts/core/pipelines/resources/LightingResource.ts","webpack://main/./src/ts/core/pipelines/resources/MaterialResource.ts","webpack://main/./src/ts/core/pipelines/resources/MemoryUtils.ts","webpack://main/./src/ts/core/pipelines/resources/PipelineResourceInstance.ts","webpack://main/./src/ts/core/pipelines/resources/PipelineResourceTemplate.ts","webpack://main/./src/ts/core/pipelines/resources/TextureResource.ts","webpack://main/./src/ts/core/pipelines/resources/TransformResource.ts","webpack://main/./src/ts/core/pipelines/shader-lib/MathFunctions.ts","webpack://main/./src/ts/core/pipelines/shader-lib/Utils.ts","webpack://main/./src/ts/ui/application/Application.tsx","webpack://main/./src/ts/ui/common/Button.tsx","webpack://main/./src/ts/ui/common/Modal.tsx","webpack://main/./src/ts/ui/common/Pane3D.tsx","webpack://main/./src/ts/ui/common/Typography.tsx","webpack://main/./src/ts/ui/theme.tsx","webpack://main/./build/untouched.wasm","webpack://main/./node_modules/@assemblyscript/loader/index.js","webpack://main/./node_modules/goober/dist/goober.modern.js","webpack://main/./node_modules/solid-js/dist/dev.js","webpack://main/./node_modules/solid-js/web/dist/dev.js","webpack://main/./node_modules/solid-styled-components/src/index.js","webpack://main/webpack/bootstrap","webpack://main/webpack/runtime/define property getters","webpack://main/webpack/runtime/global","webpack://main/webpack/runtime/hasOwnProperty shorthand","webpack://main/webpack/runtime/make namespace object","webpack://main/webpack/runtime/publicPath","webpack://main/./src/ts/index.tsx"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"main\"] = factory();\n\telse\n\t\troot[\"main\"] = factory();\n})(self, function() {\nreturn ","export enum Commands {\r\n  CLEAR,\r\n  RENDER_VAO,\r\n  ACTIVATE_SHADER,\r\n  UMATRIX4FV,\r\n  UTEXTURE2D,\r\n  GL_DEPTH_MASK,\r\n  GL_DEPTH_FUNC,\r\n  GL_CLEAR_DEPTH,\r\n  GL_ENABLE,\r\n  GL_DISABLE,\r\n  GL_STENCIL_MASK,\r\n  GL_STENCIL_FUNC,\r\n  GL_STENCIL_OP,\r\n  GL_CLEAR_STENCIL,\r\n  GL_POLYGON_OFFSET,\r\n  GL_CULLFACE,\r\n  GL_COLOR_MASK,\r\n  GL_CLEAR_COLOR,\r\n  GL_FRONT_FACE,\r\n  GL_BLEND_EQUATION,\r\n  GL_BLEND_FUNC,\r\n  GL_BLEND_EQUATION_SEPARATE,\r\n  GL_BLEND_FUNC_SEPARATE,\r\n}\r\n\r\nexport enum GPUCommands {\r\n  SET_PIPELINE,\r\n  SET_TRANSFORM,\r\n  SETUP_LIGHTING,\r\n  SET_INDEX_BUFFER,\r\n  SET_BUFFER,\r\n  START_PASS,\r\n  SET_BIND_GROUP,\r\n  END_PASS,\r\n  DRAW_INDEXED,\r\n}\r\n","export enum GroupType {\r\n  Transform,\r\n  Material,\r\n}\r\n","export enum PipelineType {\r\n  Mesh,\r\n}\r\n","export enum ResourceType {\r\n  Transform,\r\n  Material,\r\n  Lighting,\r\n  Texture,\r\n}\r\n","import { GPUBufferUsageFlags } from \"../common/GPUEnums\";\nimport { GameManager } from \"./core/GameManager\";\nimport { ExportType } from \"./core/WasmManager\";\n\ntype Import = WebAssembly.Imports;\nexport const vaos: WebGLVertexArrayObject[] = [];\nexport const buffers: WebGLBuffer[] = [];\nlet wasmExports: ExportType;\n\nexport function bindExports(exports: ExportType) {\n  wasmExports = exports;\n}\n\nexport function createBindingsGPU(importObject: Import, gameManager: GameManager) {\n  if (!importObject.env.memory) throw new Error(\"You need to set memory in your importObject\");\n\n  const binding = {\n    print(stringIndex: number) {\n      if (wasmExports) console.log(wasmExports.exports.__getString(stringIndex));\n    },\n    createBufferFromF32(data: number, usage: GPUBufferUsageFlags) {\n      const buffer = wasmExports.exports.__getFloat32Array(data);\n      return gameManager.createBufferF32(buffer, usage);\n    },\n    createIndexBuffer(data: number, usage: GPUBufferUsageFlags) {\n      const buffer = wasmExports.exports.__getUint32Array(data);\n      return gameManager.createIndexBuffer(buffer, usage);\n    },\n    render(commandsIndex: number) {\n      const commandBuffer = wasmExports.exports.__getArray(commandsIndex) as Array<number>;\n      gameManager.renderQueueManager.run(commandBuffer);\n    },\n  };\n\n  importObject.Imports = binding;\n}\n","import { InputManager } from \"./InputManager\";\nimport { GPUBufferUsageFlags } from \"../../common/GPUEnums\";\nimport { PipelineType } from \"../../common/PipelineType\";\nimport { DebugPipeline } from \"./pipelines/debug-pipeline\";\nimport { Pipeline } from \"./pipelines/Pipeline\";\nimport { createBuffer, createIndexBuffer } from \"./Utils\";\nimport { RenderQueueManager } from \"./RenderQueueManager\";\nimport { Texture } from \"./Texture\";\nimport { GroupType } from \"../../common/GroupType\";\nimport { ResourceType } from \"../../common/ResourceType\";\nimport { MeshPipeline } from \"build/types\";\nimport { WasmManager } from \"./WasmManager\";\n\nconst meshPipelineInstances: MeshPipeline[] = [];\nconst sampleCount = 4;\n\nexport class GameManager {\n  canvas: HTMLCanvasElement;\n  device: GPUDevice;\n  context: GPUCanvasContext;\n  format: GPUTextureFormat;\n  inputManager: InputManager;\n  wasmManager: WasmManager;\n\n  buffers: GPUBuffer[];\n  pipelines: Pipeline<any>[];\n  samplers: GPUSampler[];\n  textures: Texture[];\n\n  onResizeHandler: () => void;\n  onFrameHandler: () => void;\n  disposed: boolean;\n  renderQueueManager: RenderQueueManager;\n\n  renderTargetView: GPUTextureView;\n  renderTarget: GPUTexture;\n  depthTexture: GPUTexture;\n\n  currentPass: GPURenderPassEncoder | null;\n  currentCommandEncoder: GPUCommandEncoder;\n  private presentationSize: [number, number];\n\n  constructor(canvas: HTMLCanvasElement) {\n    this.canvas = canvas;\n    this.buffers = [];\n    this.textures = [];\n    this.samplers = [];\n    this.disposed = false;\n    this.currentPass = null;\n    this.onFrameHandler = this.onFrame.bind(this);\n  }\n\n  async init(wasmManager: WasmManager) {\n    this.wasmManager = wasmManager;\n    this.renderQueueManager = new RenderQueueManager(this, wasmManager);\n    const wasmExports = wasmManager.exports;\n\n    const hasGPU = this.hasWebGPU();\n    if (!hasGPU) throw new Error(\"Your current browser does not support WebGPU!\");\n\n    this.inputManager = new InputManager(this.canvas, wasmManager);\n\n    const adapter = await navigator.gpu?.requestAdapter();\n    const device = (await adapter?.requestDevice()) as GPUDevice;\n    const context = this.canvas.getContext(\"webgpu\") as unknown as GPUCanvasContext;\n    const format = context.getPreferredFormat(adapter!);\n\n    context.configure({\n      device: device,\n      format: format,\n      size: this.canvasSize(),\n      compositingAlphaMode: \"premultiplied\",\n    });\n\n    this.device = device;\n    this.context = context;\n    this.format = format;\n\n    this.samplers = [\n      device.createSampler({\n        minFilter: \"linear\",\n        magFilter: \"linear\",\n      }),\n    ];\n\n    // TEXTURES\n    const texturePaths = [\n      { name: \"grid\", path: \"./dist/media/uv-grid.jpg\" },\n      { name: \"crate\", path: \"./dist/media/crate-wooden.jpg\" },\n      { name: \"earth\", path: \"./dist/media/earth-day-2k.jpg\" },\n    ];\n\n    this.textures = await Promise.all(\n      texturePaths.map((tp, index) => {\n        const texture = new Texture(tp.name, tp.path);\n        wasmExports.TextureFactory.createTexture(wasmExports.__newString(tp.name), index);\n        return texture.load(device);\n      })\n    );\n\n    // PIPELINES\n    this.pipelines = [\n      new DebugPipeline(\"textured\", { diffuseMap: this.textures[1], NUM_DIR_LIGHTS: 0 }),\n      new DebugPipeline(\"simple\", { NUM_DIR_LIGHTS: 0 }),\n      new DebugPipeline(\"earth\", { diffuseMap: this.textures[2], NUM_DIR_LIGHTS: 0 }),\n    ];\n\n    const size = this.canvasSize();\n    this.onResize(size, false);\n\n    // Initialize the wasm module\n    wasmExports.AsSceneManager.init(this.canvas.width, this.canvas.height);\n\n    this.initRuntime();\n\n    // Setup events\n    window.addEventListener(\"resize\", this.onResizeHandler);\n    window.requestAnimationFrame(this.onFrameHandler);\n    // window.addEventListener(\"click\", (e) => {\n    //   const pipelines = this.pipelines as DebugPipeline[];\n    //   pipelines.forEach((p) => {\n    //     if (p.defines.diffuseMap) {\n    //       delete p.defines.diffuseMap;\n    //       p.defines = p.defines;\n    //     } else {\n    //       p.defines.diffuseMap = this.textures[1];\n    //       p.defines = p.defines;\n    //     }\n    //   });\n    // });\n  }\n\n  getTexture(name: string) {\n    return this.textures.find((t) => t.name === name) || null;\n  }\n\n  initRuntime() {\n    const wasm = this.wasmManager.exports;\n    const runime = wasm.Runtime.wrap(wasm.AsSceneManager.getRuntime());\n\n    this.pipelines.forEach((p) => {\n      p.build(this);\n      p.initialize(this);\n    });\n\n    const containerLvl1Ptr = wasm.__pin(wasm.createLevel1());\n    const containerLvl1 = wasm.Level1.wrap(containerLvl1Ptr);\n    containerLvl1.addAsset(this.createMesh(1, \"sphere\", \"simple\"));\n    containerLvl1.addAsset(this.createMesh(1, \"box\", \"textured\"));\n    containerLvl1.addAsset(this.createMesh(1, \"box\", \"textured\"));\n    wasm.__unpin(containerLvl1Ptr);\n\n    const containerMainMenuPtr = wasm.__pin(wasm.createMainMenu());\n    const containerMainMenu = wasm.MainMenu.wrap(containerMainMenuPtr);\n    containerMainMenu.addAsset(this.createMesh(1, \"sphere\", \"earth\"));\n    wasm.__unpin(containerMainMenuPtr);\n\n    runime.addContainer(containerLvl1Ptr, false);\n    runime.addContainer(containerMainMenuPtr, true);\n  }\n\n  createMesh(size: number, type: \"box\" | \"sphere\", pipelineName: string) {\n    // Get the pipeline\n    const debugPipeline = this.getPipeline(pipelineName)!;\n    const pipelineIndex = this.pipelines.indexOf(debugPipeline);\n    const wasmExports = this.wasmManager.exports;\n\n    // Create an instance in WASM\n    const pipelineInsPtr = wasmExports.PipelineFactory.createPipeline(\n      wasmExports.__newString(debugPipeline.name),\n      pipelineIndex,\n      PipelineType.Mesh\n    );\n    const meshPipelineIns = wasmExports.MeshPipeline.wrap(pipelineInsPtr);\n\n    meshPipelineInstances.push(meshPipelineIns);\n\n    // Assign a transform buffer to the intance\n    meshPipelineIns.transformGroupId = debugPipeline.getTemplateByType(ResourceType.Transform)!.template.group;\n    meshPipelineIns.transformResourceIndex = debugPipeline.addResourceInstance(this, GroupType.Transform);\n\n    const geometryPtr =\n      type === \"box\" ? wasmExports.GeometryFactory.createBox(size) : wasmExports.GeometryFactory.createSphere(size);\n    const meshPtr = wasmExports.createMesh(geometryPtr, pipelineInsPtr);\n    return meshPtr;\n  }\n\n  dispose() {\n    this.disposed = true;\n    window.removeEventListener(\"resize\", this.onResizeHandler);\n    this.inputManager?.dispose();\n  }\n\n  private onResize(newSize: [number, number], updateWasm = true) {\n    if (this.renderTarget) {\n      // Destroy the previous render target\n      this.renderTarget.destroy();\n      this.depthTexture.destroy();\n    }\n\n    this.presentationSize = newSize;\n\n    // Reconfigure the canvas size.\n    this.context.configure({\n      device: this.device,\n      format: this.format,\n      size: this.presentationSize,\n      compositingAlphaMode: \"premultiplied\",\n    });\n\n    this.renderTarget = this.device.createTexture({\n      size: this.presentationSize,\n      sampleCount,\n      format: this.format,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    this.depthTexture = this.device.createTexture({\n      size: this.presentationSize,\n      format: \"depth24plus\",\n      sampleCount: sampleCount,\n      usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    this.renderTargetView = this.renderTarget.createView();\n\n    if (updateWasm) this.wasmManager.exports.AsSceneManager.resize(this.canvas.width, this.canvas.height);\n  }\n\n  private onFrame() {\n    window.requestAnimationFrame(this.onFrameHandler);\n    if (this.disposed) return;\n\n    // Check if we need to resize\n    const [w, h] = this.presentationSize;\n    const newSize = this.canvasSize();\n    if (newSize[0] !== w || newSize[1] !== h) {\n      this.onResize(newSize);\n    }\n\n    this.wasmManager.exports.AsSceneManager.update(performance.now());\n  }\n\n  canvasSize() {\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const size: [number, number] = [\n      this.canvas.clientWidth * devicePixelRatio,\n      this.canvas.clientHeight * devicePixelRatio,\n    ];\n    return size;\n  }\n\n  hasWebGPU() {\n    if (!navigator.gpu) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  getPipeline(name: string) {\n    return this.pipelines.find((p) => p.name === name);\n  }\n\n  startPass() {\n    const device = this.device;\n    const commandEncoder = device.createCommandEncoder();\n    const renderPass = commandEncoder.beginRenderPass({\n      colorAttachments: [\n        {\n          view: this.renderTargetView,\n          resolveTarget: this.context.getCurrentTexture().createView(),\n          clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, //background color\n          storeOp: \"store\",\n          loadOp: \"clear\",\n        },\n      ],\n      depthStencilAttachment: {\n        view: this.depthTexture.createView(),\n        depthLoadOp: \"clear\",\n        depthStoreOp: \"store\",\n        depthClearValue: 1,\n      },\n    });\n\n    this.currentPass = renderPass;\n    this.currentCommandEncoder = commandEncoder;\n  }\n\n  endPass() {\n    this.currentPass!.end();\n    this.device.queue.submit([this.currentCommandEncoder.finish()]);\n  }\n\n  createBufferF32(\n    data: Float32Array,\n    usageFlag: GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST\n  ) {\n    const buffer = createBuffer(this.device, data, usageFlag);\n    this.buffers.push(buffer);\n    return this.buffers.length - 1;\n  }\n\n  createIndexBuffer(\n    data: Uint32Array,\n    usageFlag: GPUBufferUsageFlags = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST\n  ) {\n    const buffer = createIndexBuffer(this.device, data, usageFlag);\n    this.buffers.push(buffer);\n    return this.buffers.length - 1;\n  }\n}\n","import { WasmManager } from \"./WasmManager\";\n\nexport enum MouseEventType {\n  MouseDown,\n  MouseUp,\n  MouseMove,\n  MouseWheel,\n}\n\nexport enum KeyEventType {\n  KeyDown,\n  KeyUp,\n}\n\nexport class InputManager {\n  canvas: HTMLCanvasElement;\n  wasmManager: WasmManager;\n\n  private onDownHandler: (e: MouseEvent) => void;\n  private onUpHandler: (e: MouseEvent) => void;\n  private onKeyDownHandler: (e: KeyboardEvent) => void;\n  private onKeyUpHandler: (e: KeyboardEvent) => void;\n  private onMoveHandler: (e: MouseEvent) => void;\n  private onWheelHandler: (e: WheelEvent) => void;\n  private canvasBounds: DOMRect;\n\n  constructor(canvas: HTMLCanvasElement, wasm: WasmManager) {\n    this.wasmManager = wasm;\n    this.canvas = canvas;\n    this.canvasBounds = canvas.getBoundingClientRect();\n\n    this.onDownHandler = this.onDown.bind(this);\n    this.onUpHandler = this.onUp.bind(this);\n    this.onKeyDownHandler = this.onKeyDown.bind(this);\n    this.onKeyUpHandler = this.onKeyUp.bind(this);\n    this.onMoveHandler = this.onMove.bind(this);\n    this.onWheelHandler = this.onWheel.bind(this);\n\n    this.canvas.addEventListener(\"mousedown\", this.onDownHandler);\n    window.addEventListener(\"wheel\", this.onWheelHandler);\n    window.addEventListener(\"mouseup\", this.onUpHandler);\n    window.addEventListener(\"mousemove\", this.onMoveHandler);\n    document.addEventListener(\"keydown\", this.onKeyDownHandler);\n    document.addEventListener(\"keyup\", this.onKeyUpHandler);\n\n    this.reset();\n  }\n\n  reset() {\n    this.canvasBounds = this.canvas.getBoundingClientRect();\n  }\n\n  private onUp(e: MouseEvent) {\n    this.sendMouseEvent(MouseEventType.MouseUp, e, this.canvasBounds, 0);\n  }\n\n  private onMove(e: MouseEvent) {\n    this.sendMouseEvent(MouseEventType.MouseMove, e, this.canvasBounds, 0);\n  }\n\n  private onDown(e: MouseEvent) {\n    e.preventDefault();\n    this.sendMouseEvent(MouseEventType.MouseDown, e, this.canvasBounds, 0);\n  }\n\n  private onKeyDown(e: KeyboardEvent) {\n    this.sendKeyEvent(KeyEventType.KeyDown, e);\n  }\n\n  private onKeyUp(e: KeyboardEvent) {\n    e.preventDefault();\n    this.sendKeyEvent(KeyEventType.KeyUp, e);\n  }\n\n  private onWheel(e: WheelEvent) {\n    this.sendMouseEvent(MouseEventType.MouseWheel, e, this.canvasBounds, e.deltaY);\n  }\n\n  private createMouseEvent(e: MouseEvent, bounds: DOMRect, delta: number = 0) {\n    const wasmExports = this.wasmManager.exports;\n    const mouseEventPtr = wasmExports.__pin(\n      wasmExports.ASInputManager.createMouseEvent(\n        e.clientX,\n        e.clientY,\n        e.pageX,\n        e.pageY,\n        e.ctrlKey,\n        e.shiftKey,\n        e.altKey,\n        e.button,\n        e.buttons,\n        bounds.x,\n        bounds.y,\n        bounds.width,\n        bounds.height,\n        delta\n      )\n    );\n\n    return mouseEventPtr;\n  }\n\n  private sendMouseEvent(type: MouseEventType, event: MouseEvent, bounds: DOMRect, delta: number): void {\n    const wasmExports = this.wasmManager.exports;\n    const manager = wasmExports.ASInputManager.InputManager.wrap(wasmExports.ASInputManager.getInputManager());\n    const wasmEvent = this.createMouseEvent(event, bounds, delta);\n\n    if (type === MouseEventType.MouseUp) manager.onMouseUp(wasmEvent);\n    else if (type === MouseEventType.MouseMove) manager.onMouseMove(wasmEvent);\n    else if (type === MouseEventType.MouseDown) manager.onMouseDown(wasmEvent);\n    else if (type === MouseEventType.MouseWheel) manager.onWheel(wasmEvent);\n\n    wasmExports.__unpin(wasmEvent);\n  }\n\n  private sendKeyEvent(type: KeyEventType, event: KeyboardEvent): void {\n    const wasmExports = this.wasmManager.exports;\n    const manager = wasmExports.ASInputManager.InputManager.wrap(wasmExports.ASInputManager.getInputManager());\n    const wasmEvent = wasmExports.__pin(\n      wasmExports.ASInputManager.createKeyboardEvent(wasmExports.__newString(event.code))\n    );\n\n    if (type === KeyEventType.KeyUp) manager.onKeyUp(wasmEvent);\n    else if (type === KeyEventType.KeyDown) manager.onKeyDown(wasmEvent);\n\n    wasmExports.__unpin(wasmEvent);\n  }\n\n  dispose() {\n    this.canvas.removeEventListener(\"mousedown\", this.onDownHandler);\n    window.removeEventListener(\"mouseup\", this.onUpHandler);\n    window.removeEventListener(\"wheel\", this.onWheelHandler);\n    window.removeEventListener(\"mousemove\", this.onMoveHandler);\n    document.removeEventListener(\"keydown\", this.onKeyDownHandler);\n    document.removeEventListener(\"keyup\", this.onKeyUpHandler);\n  }\n}\n","import { GroupType } from \"../../common/GroupType\";\nimport { ResourceType } from \"../../common/ResourceType\";\nimport { GPUCommands } from \"../../common/Commands\";\nimport { GameManager } from \"./GameManager\";\nimport { Pipeline } from \"./pipelines/Pipeline\";\nimport { LightingResource } from \"./pipelines/resources/LightingResource\";\nimport { PipelineResourceInstance } from \"./pipelines/resources/PipelineResourceInstance\";\nimport { WasmManager } from \"./WasmManager\";\n\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst normalAs4x4 = new Float32Array(12);\n\nexport class RenderQueueManager {\n  manager: GameManager;\n  wasmManager: WasmManager;\n\n  constructor(manager: GameManager, wasmManager: WasmManager) {\n    this.manager = manager;\n    this.wasmManager = wasmManager;\n  }\n\n  run(commandBuffer: Array<number>) {\n    const manager = this.manager;\n    const device = manager.device;\n    const { wasmArrayBuffer, wasmMemoryBlock } = this.wasmManager;\n\n    const getPtrIndex = function (ptr: number) {\n      return wasmArrayBuffer[(ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET) >>> 2];\n    };\n    getPtrIndex;\n\n    let pipeline: Pipeline<any>, buffer: GPUBuffer, instances: PipelineResourceInstance[], resourceIndex: number;\n\n    let pass = manager.currentPass!;\n\n    for (let i = 0, l = commandBuffer.length; i < l; i++) {\n      const command = commandBuffer[i];\n\n      switch (command) {\n        case GPUCommands.SETUP_LIGHTING:\n          const numDirectionLights = commandBuffer[i + 1];\n\n          if (LightingResource.numDirLights !== numDirectionLights) {\n            LightingResource.numDirLights = numDirectionLights;\n            LightingResource.rebuildDirectionLights = true;\n            this.manager.pipelines.forEach((p) => {\n              if (p.getTemplateByType(ResourceType.Material)) {\n                p.defines = { ...p.defines, NUM_DIR_LIGHTS: numDirectionLights };\n              }\n            });\n          }\n\n          buffer = LightingResource.lightingConfig;\n          if (buffer) {\n            const info = getPtrIndex(commandBuffer[i + 2]);\n            device.queue.writeBuffer(buffer, 0, wasmMemoryBlock, info, 4);\n          }\n\n          buffer = LightingResource.sceneLightingBuffer;\n          if (buffer) {\n            const ambientLights = getPtrIndex(commandBuffer[i + 3]);\n            device.queue.writeBuffer(buffer, 0, wasmMemoryBlock, ambientLights, 4 * 4);\n          }\n\n          buffer = LightingResource.directionLightsBuffer;\n          if (buffer) {\n            const dirLights = getPtrIndex(commandBuffer[i + 4]);\n            device.queue.writeBuffer(buffer, 0, wasmMemoryBlock, dirLights, numDirectionLights * 4 * 4 * 2);\n          }\n\n          i += 4;\n          break;\n\n        case GPUCommands.SET_TRANSFORM:\n          instances = pipeline!.groupInstances.get(GroupType.Transform)!;\n          resourceIndex = commandBuffer[i + 1];\n          const projMatrixPtr = getPtrIndex(commandBuffer[i + 2]);\n          const mvMatrixPtr = getPtrIndex(commandBuffer[i + 3]);\n          const normMatrixPtr = getPtrIndex(commandBuffer[i + 4]);\n\n          const mat3x3 = new Float32Array(wasmMemoryBlock, normMatrixPtr, 9);\n\n          // TODO: Make this neater\n          normalAs4x4[0] = mat3x3[0];\n          normalAs4x4[1] = mat3x3[1];\n          normalAs4x4[2] = mat3x3[2];\n\n          normalAs4x4[4] = mat3x3[3];\n          normalAs4x4[5] = mat3x3[4];\n          normalAs4x4[6] = mat3x3[5];\n\n          normalAs4x4[8] = mat3x3[6];\n          normalAs4x4[9] = mat3x3[7];\n          normalAs4x4[10] = mat3x3[8];\n\n          const transformBuffer = instances[resourceIndex].buffers![0];\n          device.queue.writeBuffer(transformBuffer, 0, wasmMemoryBlock, projMatrixPtr, 64);\n          device.queue.writeBuffer(transformBuffer, 64, wasmMemoryBlock, mvMatrixPtr, 64);\n          device.queue.writeBuffer(transformBuffer, 128, normalAs4x4);\n          i += 4;\n          break;\n\n        case GPUCommands.SET_INDEX_BUFFER:\n          buffer = manager.buffers[commandBuffer[i + 1]];\n          pass.setIndexBuffer(buffer, \"uint32\");\n          i += 1;\n          break;\n\n        case GPUCommands.SET_BUFFER:\n          const slot = commandBuffer[i + 1];\n          buffer = manager.buffers[commandBuffer[i + 2]];\n          pass.setVertexBuffer(slot, buffer);\n          i += 2;\n          break;\n\n        case GPUCommands.DRAW_INDEXED:\n          const indexCount = commandBuffer[i + 1];\n          pass.drawIndexed(indexCount);\n          i += 1;\n          break;\n\n        case GPUCommands.SET_PIPELINE:\n          const newPipeline = manager.pipelines[commandBuffer[i + 1]];\n\n          if (newPipeline.rebuild) {\n            newPipeline.build(manager);\n            newPipeline.initialize(manager);\n          }\n\n          if (newPipeline === pipeline!) {\n            i += 1;\n            break;\n          }\n\n          pipeline = newPipeline;\n\n          pass.setPipeline(pipeline.renderPipeline!);\n          i += 1;\n          break;\n\n        case GPUCommands.SET_BIND_GROUP:\n          instances = pipeline!.groupInstances.get(commandBuffer[i + 1])!;\n          const instance = instances?.[commandBuffer[i + 2]];\n          if (instance) pass.setBindGroup(instance.group, instance.bindGroup);\n\n          i += 2;\n          break;\n\n        case GPUCommands.START_PASS:\n          manager.startPass();\n          pass = manager.currentPass!;\n          break;\n\n        case GPUCommands.END_PASS:\n          manager.endPass();\n          break;\n      }\n    }\n  }\n}\n","export class Texture {\r\n  name: string;\r\n  path: string;\r\n  gpuTexture: GPUTexture;\r\n  imageData: ImageBitmap;\r\n\r\n  constructor(name: string, path: string) {\r\n    this.name = name;\r\n    this.path = path;\r\n  }\r\n\r\n  async load(device: GPUDevice) {\r\n    let gpuTexture: GPUTexture;\r\n    const img = document.createElement(\"img\");\r\n    img.src = this.path;\r\n    await img.decode();\r\n    this.imageData = await createImageBitmap(img);\r\n\r\n    gpuTexture = device.createTexture({\r\n      size: [this.imageData.width, this.imageData.height, 1],\r\n      format: \"rgba8unorm\",\r\n      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\r\n    });\r\n\r\n    device.queue.copyExternalImageToTexture({ source: this.imageData }, { texture: gpuTexture }, [\r\n      this.imageData.width,\r\n      this.imageData.height,\r\n    ]);\r\n\r\n    this.gpuTexture = gpuTexture;\r\n    return this;\r\n  }\r\n}\r\n","import { GPUBufferUsageFlags } from \"../../common/GPUEnums\";\r\n\r\nexport function createBuffer(\r\n  device: GPUDevice,\r\n  data: Float32Array,\r\n  usageFlag: GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST\r\n) {\r\n  const buffer = device.createBuffer({\r\n    size: data.byteLength,\r\n    usage: usageFlag,\r\n    // mappedAtCreation is true so we can interact with it via the CPU\r\n    mappedAtCreation: true,\r\n  });\r\n  new Float32Array(buffer.getMappedRange()).set(data);\r\n  buffer.unmap();\r\n  return buffer;\r\n}\r\n\r\nexport function createIndexBuffer(\r\n  device: GPUDevice,\r\n  data: Uint32Array,\r\n  usageFlag: GPUBufferUsageFlags = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST\r\n) {\r\n  const buffer = device.createBuffer({\r\n    size: data.byteLength,\r\n    usage: usageFlag,\r\n    // mappedAtCreation is true so we can interact with it via the CPU\r\n    mappedAtCreation: true,\r\n  });\r\n  new Uint32Array(buffer.getMappedRange()).set(data);\r\n  buffer.unmap();\r\n  return buffer;\r\n}\r\n","import type * as MyModule from \"../../../build/types\";\nimport wasmFile from \"../../../build/untouched.wasm\";\nimport { createBindingsGPU, bindExports } from \"../AppBindings\";\nimport loader, { ASUtil, ResultObject } from \"@assemblyscript/loader\";\nimport { GameManager } from \"./GameManager\";\n\nexport type IWasmExports = ASUtil & typeof MyModule;\nexport type ExportType = ResultObject & { exports: IWasmExports };\n\nexport class WasmManager {\n  memory: WebAssembly.Memory;\n  importObject: WebAssembly.Imports;\n  exports: IWasmExports;\n\n  wasmArrayBuffer: Uint32Array;\n  wasmDataView: DataView;\n  wasmMemoryBlock: ArrayBuffer;\n\n  constructor() {}\n\n  async load(gameManager: GameManager) {\n    // Creating WASM with Linear memory\n    this.memory = new WebAssembly.Memory({ initial: 100 });\n    this.importObject = {\n      env: {\n        memory: this.memory,\n        seed: Date.now,\n        abort: (...args: any[]) => {\n          console.error((this.importObject.env as any).getString(args[0]));\n          console.error((this.importObject.env as any).getString(args[1]));\n        },\n        getString: (string_index: number) => {\n          const buffer = (this.importObject.env as any).memory.buffer;\n          const U32 = new Uint32Array(buffer);\n          const id_addr = string_index / 4 - 2;\n          const id = U32[id_addr];\n          if (id !== 0x01) throw Error(`not a string index=${string_index} id=${id}`);\n          const len = U32[id_addr + 1];\n          const str = new TextDecoder(\"utf-16\").decode(buffer.slice(string_index, string_index + len));\n          return str;\n        },\n      },\n    };\n\n    createBindingsGPU(this.importObject, gameManager);\n\n    const obj = await loader.instantiateStreaming<typeof MyModule>(fetch(wasmFile), this.importObject);\n    this.exports = obj.exports;\n\n    // Bind the newly created export file\n    bindExports(obj);\n    this.wasmMemoryBlock = obj.exports.memory!.buffer;\n    this.wasmArrayBuffer = new Uint32Array(this.wasmMemoryBlock);\n    this.wasmDataView = new DataView(this.exports.memory.buffer);\n  }\n}\n","export const defaultPipelineDescriptor: Partial<GPURenderPipelineDescriptor> = {\r\n  primitive: {\r\n    topology: \"triangle-list\",\r\n    cullMode: \"back\",\r\n    frontFace: \"ccw\",\r\n  },\r\n  depthStencil: {\r\n    format: \"depth24plus\",\r\n    depthWriteEnabled: true,\r\n    depthCompare: \"less\",\r\n  },\r\n  multisample: {\r\n    count: 4,\r\n  },\r\n};\r\n","import { GameManager } from \"../GameManager\";\r\nimport { BindingData, PipelineResourceTemplate } from \"./resources/PipelineResourceTemplate\";\r\nimport { PipelineResourceInstance } from \"./resources/PipelineResourceInstance\";\r\nimport { GroupType } from \"../../../common/GroupType\";\r\nimport { ResourceType } from \"../../../common/ResourceType\";\r\nimport \"./shader-lib/Utils\";\r\nimport { Defines, SourceFragments } from \"./shader-lib/Utils\";\r\n\r\nexport class GroupMapping {\r\n  index: number;\r\n  bindingCount: number;\r\n\r\n  constructor(index: number) {\r\n    this.index = index;\r\n    this.bindingCount = 0;\r\n  }\r\n\r\n  getBinding(): number {\r\n    const toRet = this.bindingCount;\r\n    this.bindingCount++;\r\n    return toRet;\r\n  }\r\n}\r\n\r\nexport abstract class Pipeline<T extends Defines<T>> {\r\n  name: string;\r\n  renderPipeline: GPURenderPipeline | null;\r\n  fragmentSource: SourceFragments<T>;\r\n  vertexSource: SourceFragments<T>;\r\n  private _defines: Defines<T>;\r\n  private resourceTemplates: PipelineResourceTemplate[];\r\n  groupInstances: Map<GroupType, PipelineResourceInstance[]>;\r\n  rebuild: boolean;\r\n\r\n  groupMapping: Map<GroupType, GroupMapping>;\r\n  private groups: number;\r\n\r\n  constructor(name: string, vertexSource: SourceFragments<T>, fragmentSource: SourceFragments<T>, defines: Defines<T>) {\r\n    this.name = name;\r\n    this.renderPipeline = null;\r\n    this.vertexSource = vertexSource;\r\n    this.fragmentSource = fragmentSource;\r\n    this.resourceTemplates = [];\r\n    this.groupInstances = new Map();\r\n    this.defines = defines;\r\n    this.rebuild = true;\r\n\r\n    this.groupMapping = new Map();\r\n    this.groups = 0;\r\n  }\r\n\r\n  set defines(defines: T) {\r\n    this._defines = defines;\r\n    this.rebuild = true;\r\n  }\r\n\r\n  get defines(): T {\r\n    return this._defines;\r\n  }\r\n\r\n  groupIndex(type: GroupType): number {\r\n    if (this.groupMapping.has(type)) return this.groupMapping.get(type)!.index;\r\n    else {\r\n      const groupMapping = new GroupMapping(this.groups);\r\n      this.groupMapping.set(type, groupMapping);\r\n      this.groups++;\r\n      return groupMapping.index;\r\n    }\r\n  }\r\n\r\n  bindingIndex(type: GroupType): number {\r\n    if (this.groupMapping.has(type)) {\r\n      const groupMapping = this.groupMapping.get(type)!;\r\n      return groupMapping.getBinding();\r\n    } else {\r\n      const groupMapping = new GroupMapping(this.groups);\r\n      this.groupMapping.set(type, groupMapping);\r\n      this.groups++;\r\n      return groupMapping.getBinding();\r\n    }\r\n  }\r\n\r\n  /** Use this function to add resource templates */\r\n  abstract onAddResources(): void;\r\n\r\n  getTemplateByType(type: ResourceType, id?: string) {\r\n    if (id) return this.resourceTemplates.find((t) => t.resourceType === type && id === t.id);\r\n    else return this.resourceTemplates.find((t) => t.resourceType === type);\r\n  }\r\n\r\n  getTemplateByGroup(type: GroupType) {\r\n    return this.resourceTemplates.find((t) => t.groupType === type);\r\n  }\r\n\r\n  addTemplate(template: PipelineResourceTemplate) {\r\n    this.resourceTemplates.push(template);\r\n    return this;\r\n  }\r\n\r\n  build(gameManager: GameManager): void {\r\n    this.rebuild = false;\r\n\r\n    const groupInstanceMap = this.groupInstances;\r\n    const templates = this.resourceTemplates;\r\n\r\n    // Destroy previous instances\r\n    templates.forEach((template) => {\r\n      const resourceInstances = groupInstanceMap.get(template.groupType);\r\n      resourceInstances?.forEach((i) => {\r\n        i.dispose();\r\n      });\r\n    });\r\n\r\n    // Reset\r\n    templates.splice(0, templates.length);\r\n    this.groupMapping.clear();\r\n    this.groups = 0;\r\n\r\n    this.onAddResources();\r\n\r\n    let curBinding = 0;\r\n    const binds: Map<number, number> = new Map();\r\n\r\n    templates.forEach((resourceTemplate) => {\r\n      const groupIndex = this.groupIndex(resourceTemplate.groupType);\r\n      if (!binds.has(groupIndex)) binds.set(groupIndex, 0);\r\n\r\n      curBinding = binds.get(groupIndex)!;\r\n\r\n      const template = resourceTemplate.build(gameManager, this, curBinding);\r\n\r\n      curBinding += template.bindings.length;\r\n      binds.set(groupIndex, curBinding);\r\n\r\n      resourceTemplate.template = template;\r\n    });\r\n  }\r\n\r\n  initialize(gameManager: GameManager): void {\r\n    const templates = this.resourceTemplates;\r\n    const groupInstances = this.groupInstances;\r\n    const prevGroupKeys = Array.from(this.groupInstances.keys());\r\n    const uniqueNewGroupKeys = templates\r\n      .map((r) => r.groupType)\r\n      .filter((value, index, self) => self.indexOf(value) === index);\r\n    const groupCache: Map<GroupType, { numInstances: number; bindData: Map<number, BindingData[]> }> = new Map();\r\n\r\n    // Remove any unused instances\r\n    prevGroupKeys.forEach((key) => {\r\n      if (!uniqueNewGroupKeys.includes(key)) groupInstances.delete(key);\r\n    });\r\n\r\n    // Initialize temp cache maps\r\n    for (const newKey of uniqueNewGroupKeys) {\r\n      let numInstancesToCreate = 0;\r\n      let instances: PipelineResourceInstance[];\r\n\r\n      // If we previously had instances, then save the number of them\r\n      // as we have to re-create the same amount as before. Otherwise just create 1;\r\n      if (groupInstances.has(newKey)) {\r\n        instances = groupInstances.get(newKey)!;\r\n        numInstancesToCreate = instances.length;\r\n        instances.splice(0, instances.length);\r\n      } else {\r\n        numInstancesToCreate = 1;\r\n        instances = [];\r\n        groupInstances.set(newKey, instances);\r\n      }\r\n\r\n      groupCache.set(newKey, { bindData: new Map(), numInstances: numInstancesToCreate });\r\n    }\r\n\r\n    // Initialize each template\r\n    templates.forEach((resourceTemplate) => {\r\n      const { bindData, numInstances } = groupCache.get(resourceTemplate.groupType)!;\r\n\r\n      for (let i = 0; i < numInstances; i++)\r\n        if (bindData.has(i)) {\r\n          bindData.get(i)!.push(resourceTemplate.getBindingData(gameManager, this.renderPipeline!));\r\n        } else {\r\n          bindData.set(i, [resourceTemplate.getBindingData(gameManager, this.renderPipeline!)]);\r\n        }\r\n    });\r\n\r\n    // Create the instances & bind groups\r\n    groupCache.forEach((cache, groupType) => {\r\n      const instances: PipelineResourceInstance[] = new Array(cache.numInstances);\r\n      const groupIndex = this.groupIndex(groupType);\r\n\r\n      for (let i = 0; i < cache.numInstances; i++) {\r\n        let buffers: GPUBuffer[] | null = null;\r\n\r\n        // Join all the entries from each template\r\n        // Also join all the collect each of the buffers we want to cache for the render queue\r\n        const entries: GPUBindGroupEntry[] = cache.bindData.get(i)!.reduce((accumulator, cur) => {\r\n          if (cur.buffer) {\r\n            if (!buffers) buffers = [cur.buffer];\r\n            else buffers.push(cur.buffer);\r\n          }\r\n\r\n          accumulator.push(...cur.binds);\r\n          return accumulator;\r\n        }, [] as GPUBindGroupEntry[]);\r\n\r\n        const bindGroup = gameManager.device.createBindGroup({\r\n          label: GroupType[groupType],\r\n          layout: this.renderPipeline!.getBindGroupLayout(groupIndex),\r\n          entries,\r\n        });\r\n\r\n        instances[i] = new PipelineResourceInstance(groupIndex, bindGroup, buffers);\r\n      }\r\n\r\n      groupInstances.set(groupType, instances);\r\n    });\r\n  }\r\n\r\n  addResourceInstance(manager: GameManager, type: GroupType) {\r\n    const template = this.getTemplateByGroup(type);\r\n\r\n    if (template) {\r\n      const bindingData = template.getBindingData(manager, this.renderPipeline!);\r\n      const groupIndex = this.groupIndex(type);\r\n\r\n      const bindGroup = manager.device.createBindGroup({\r\n        label: GroupType[type],\r\n        layout: this.renderPipeline!.getBindGroupLayout(groupIndex),\r\n        entries: bindingData.binds,\r\n      });\r\n\r\n      const instances = new PipelineResourceInstance(\r\n        groupIndex,\r\n        bindGroup,\r\n        bindingData.buffer ? [bindingData.buffer] : null\r\n      );\r\n\r\n      const instanceArray = this.groupInstances.get(type)!;\r\n      instanceArray.push(instances);\r\n      return instanceArray.length - 1;\r\n    } else throw new Error(\"Pipeline does not use resource type\");\r\n  }\r\n}\r\n","import { ResourceType } from \"../../../../common/ResourceType\";\nimport { GameManager } from \"../../GameManager\";\nimport { Texture } from \"../../Texture\";\nimport { defaultPipelineDescriptor } from \"../DefaultPipelineDescriptor\";\nimport { Pipeline } from \"../Pipeline\";\nimport { LightingResource } from \"../resources/LightingResource\";\nimport { MaterialResource } from \"../resources/MaterialResource\";\nimport { TextureResource } from \"../resources/TextureResource\";\nimport { TransformResource } from \"../resources/TransformResource\";\nimport { mathConstants, mathFunctions } from \"../shader-lib/MathFunctions\";\nimport { shader, shaderBuilder } from \"../shader-lib/Utils\";\n\n// prettier-ignore\nconst vertexShader = shader<DebugDefines>`\n${e => e.getTemplateByType(ResourceType.Transform)!.template.vertexBlock }\n\nstruct Output {\n    @builtin(position) Position : vec4<f32>;\n    @location(0) vFragUV : vec2<f32>;\n    @location(1) vNormal : vec3<f32>;\n    @location(2) vViewPosition : vec3<f32>;\n};\n\n@stage(vertex)\nfn main(@location(0) pos: vec4<f32>, @location(1) norm: vec3<f32>, @location(2) uv: vec2<f32>) -> Output {\n    var output: Output;\n    var mvPosition = vec4<f32>( pos.xyz, 1.0 );\n\n    mvPosition = uniforms.modelViewMatrix * mvPosition;\n\n    output.vViewPosition = - mvPosition.xyz;\n    output.Position = uniforms.projMatrix * mvPosition;\n    output.vFragUV = uv;\n\n    var transformedNormal = uniforms.normalMatrix * norm.xyz;\n    output.vNormal = normalize( transformedNormal );\n\n    return output;\n}\n`;\n\n// prettier-ignore\nconst fragmentShader = shader<DebugDefines>`\n\n${e => e.getTemplateByType(ResourceType.Lighting)!.template.fragmentBlock}\n${e => e.getTemplateByType(ResourceType.Material)!.template.fragmentBlock}\n${e => e.defines.diffuseMap ? e.getTemplateByType(ResourceType.Texture, 'diffuse')!.template.fragmentBlock : ''}\n${e => e.defines.normalMap ? e.getTemplateByType(ResourceType.Texture, 'normal')!.template.fragmentBlock : ''}\n\n// INTERNAL STRUCTS\nstruct IncidentLight {\n  color: vec3<f32>;\n  direction: vec3<f32>;\n  visible: bool;\n};\n\nstruct ReflectedLight {\n  directDiffuse: vec3<f32>;\n  directSpecular: vec3<f32>;\n  indirectDiffuse: vec3<f32>;\n  indirectSpecular: vec3<f32>;\n};\n\nstruct PhysicalMaterial {\n  diffuseColor: vec3<f32>;\n  specularColor: vec3<f32>;\n  roughness: f32;\n  specularF90: f32;\n};\n\nstruct GeometricContext {\n  position: vec3<f32>;\n  normal: vec3<f32>;\n  viewDir: vec3<f32>;\n};\n\nstruct DirectionalLight {\n  direction: vec3<f32>;\n  color: vec3<f32>;\n};\n\n${mathConstants}\n${mathFunctions}\n\nfn packNormalToRGB( normal: vec3<f32> ) -> vec3<f32> {\n  return normalize( normal ) * 0.5 + 0.5;\n}\n\nfn getDirectionalLightInfo( directionalLight: DirectionalLight, geometry: GeometricContext, light: ptr<function, IncidentLight> ) {\n  (*light).color = directionalLight.color;\n  (*light).direction = directionalLight.direction;\n  (*light).visible = true;\n}\n\nfn BRDF_Lambert( diffuseColor: vec3<f32> ) -> vec3<f32> {\n  return RECIPROCAL_PI * diffuseColor;\n}\n\nfn F_Schlick( f0: vec3<f32>, f90: f32, dotVH: f32  ) -> vec3<f32> {\n  var fresnel: f32 = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n  return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\n\nfn V_GGX_SmithCorrelated( alpha: f32, dotNL: f32, dotNV: f32 ) -> f32 {\n  var a2: f32 = pow2( alpha );\n  var gv: f32 = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n  var gl: f32 = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n  return 0.5 / max( gv + gl, EPSILON );\n}\n\nfn D_GGX( alpha: f32, dotNH: f32 ) -> f32 {\n  var a2: f32 = pow2( alpha );\n  var denom: f32 = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n  return RECIPROCAL_PI * a2 / pow2( denom );\n}\n\nfn BRDF_GGX( lightDir: vec3<f32>, viewDir: vec3<f32>, normal: vec3<f32>, f0: vec3<f32>, f90: f32, roughness: f32 ) -> vec3<f32> {\n  var alpha: f32 = pow2( roughness );\n  var halfDir: vec3<f32> = normalize( lightDir + viewDir );\n  var dotNL: f32 = saturate( dot( normal, lightDir ) );\n  var dotNV: f32 = saturate( dot( normal, viewDir ) );\n  var dotNH: f32 = saturate( dot( normal, halfDir ) );\n  var dotVH: f32 = saturate( dot( viewDir, halfDir ) );\n  var F: vec3<f32> = F_Schlick( f0, f90, dotVH );\n  var V: f32 = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n  var D: f32 = D_GGX( alpha, dotNH );\n  return F * ( V * D );\n}\n\nfn DFGApprox( normal: vec3<f32>, viewDir: vec3<f32>, roughness: f32 ) -> vec2<f32> {\n  var dotNV = saturate( dot( normal, viewDir ) );\n  var c0 = vec4<f32>( -1.0, - 0.0275, - 0.572, 0.022 );\n  var c1 = vec4<f32>( 1.0, 0.0425, 1.04, - 0.04 );\n  var r = roughness * c0 + c1;\n  var a004: f32 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n  var fab = vec2<f32>( - 1.04, 1.04 ) * a004 + r.zw;\n  return fab;\n}\n\nfn computeMultiscattering( normal: vec3<f32>, viewDir: vec3<f32>, specularColor: vec3<f32>, specularF90: f32, roughness: f32, singleScatter: ptr<function, vec3<f32>>, multiScatter: ptr<function, vec3<f32>> ) {\n  var fab = DFGApprox( normal, viewDir, roughness );\n  var FssEss = specularColor * fab.x + specularF90 * fab.y;\n  var Ess = fab.x + fab.y;\n  var Ems = 1.0 - Ess;\n  var Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\n  var Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n  (*singleScatter) = (*singleScatter) + FssEss;\n  (*multiScatter) = (*multiScatter) + (Fms * Ems);\n}\n\nfn RE_Direct_Physical( directLight: IncidentLight, geometry: GeometricContext, material: PhysicalMaterial, reflectedLight: ptr<function, ReflectedLight> ) {\n  var dotNL: f32 = saturate( dot( geometry.normal, directLight.direction ) );\n  var irradiance: vec3<f32> = dotNL * directLight.color;\n  // #ifdef USE_CLEARCOAT\n  //     var dotNLcc: f32 = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n  //     var ccIrradiance: vec3<f32> = dotNLcc * directLight.color;\n  //     clearcoatSpecular = clearcoatSpecular + ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n  // #endif\n  // #ifdef USE_SHEEN\n  //     (*reflectedLight).directSpecular = (*reflectedLight).directSpecular + irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n  // #endif\n  (*reflectedLight).directSpecular = (*reflectedLight).directSpecular + irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n  (*reflectedLight).directDiffuse = (*reflectedLight).directDiffuse + irradiance * BRDF_Lambert( material.diffuseColor );\n}\n\nfn RE_IndirectDiffuse_Physical( irradiance: vec3<f32>, geometry: GeometricContext, material: PhysicalMaterial, reflectedLight: ptr<function, ReflectedLight> ) {\n  (*reflectedLight).indirectDiffuse = (*reflectedLight).indirectDiffuse + (irradiance * BRDF_Lambert( material.diffuseColor ));\n}\n\nfn RE_IndirectSpecular_Physical( radiance: vec3<f32>, irradiance: vec3<f32>, clearcoatRadiance: vec3<f32>, geometry: GeometricContext, material: PhysicalMaterial, reflectedLight: ptr<function, ReflectedLight> ) {\n  // #ifdef USE_CLEARCOAT\n  //     clearcoatSpecular = clearcoatSpecular + (clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness ));\n  // #endif\n  var singleScattering = vec3<f32>( 0.0 );\n  var multiScattering = vec3<f32>( 0.0 );\n  var cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n  computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, &singleScattering, &multiScattering );\n  var diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n  (*reflectedLight).indirectSpecular = (*reflectedLight).indirectSpecular + (radiance * singleScattering);\n  (*reflectedLight).indirectSpecular = (*reflectedLight).indirectSpecular + (multiScattering * cosineWeightedIrradiance);\n  (*reflectedLight).indirectDiffuse = (*reflectedLight).indirectDiffuse + (diffuse * cosineWeightedIrradiance);\n}\n\nfn changeDiffuseToRed( colorPtr: ptr<function, vec4<f32>> ) {\n  (*colorPtr).g = 0.0;\n  (*colorPtr).b = 0.0;\n}\n\n@stage(fragment)\nfn main(\n  @location(0) vFragUV: vec2<f32>,\n  @location(1) vNormal : vec3<f32>,\n  @location(2) vViewPosition : vec3<f32>\n) -> @location(0) vec4<f32> {\n\n  var normal = normalize( vNormal );\n  var geometryNormal = normal;\n\n  var totalEmissiveRadiance: vec3<f32> = materialData.emissive.xyz;\n  var diffuseColor = vec4<f32>( materialData.diffuse.xyz, materialData.opacity );\n  var reflectedLight: ReflectedLight = ReflectedLight( vec3<f32>( 0.0 ), vec3<f32>( 0.0 ), vec3<f32>( 0.0 ), vec3<f32>( 0.0 ) );\n\n  ${e => e.defines.diffuseMap &&\n  `var texelColor = textureSample(diffuseTexture, diffuseSampler, vFragUV);\n  diffuseColor = diffuseColor * texelColor;`}\n\n  // TODO: Alpha test - discard early\n\n  // Metalness\n  var metalnessFactor: f32 = materialData.metalness;\n  // TODO:\n  ${e => e.defines.metalnessMap &&\n    `vec4 texelMetalness = = textureSample(metalnessMap, mySampler, vFragUV);\n    metalnessFactor *= texelMetalness.b;`\n  }\n\n  // Roughness\n  var roughnessFactor: f32 = materialData.roughness;\n  // TODO:\n  ${e => e.defines.roughnessMap &&\n    `vec4 texelRoughness = textureSample(roughnessMap, mySampler, vFragUV);\n    roughnessFactor *= texelRoughness.b;`\n  }\n\n  var isOrthographic = false;\n  var geometry: GeometricContext;\n  geometry.position = -vViewPosition;\n  geometry.normal = normal;\n  geometry.viewDir =  select(normalize( vViewPosition ), vec3<f32>( 0.0, 0.0, 1.0 ), isOrthographic ); // Same as ternary operator (select( false, true, condition ))\n\n  var directLight: IncidentLight;\n  var material: PhysicalMaterial;\n\n  material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\n  var dxy: vec3<f32> = max( abs( dpdx( geometryNormal ) ), abs( dpdy( geometryNormal ) ) );\n  var geometryRoughness: f32 = max( max( dxy.x, dxy.y ), dxy.z );\n\n  material.roughness = max( roughnessFactor, 0.0525 );\n  material.roughness = material.roughness + geometryRoughness;\n  material.roughness = min( material.roughness, 1.0 );\n\n  // #ifdef IOR\n  //     #ifdef SPECULAR\n  //         float specularIntensityFactor = specularIntensity;\n  //         vec3 specularColorFactor = specularColor;\n  //         #ifdef USE_SPECULARINTENSITYMAP\n  //             specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n  //         #endif\n  //         #ifdef USE_SPECULARCOLORMAP\n  //             specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n  //         #endif\n  //         material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n  //     #else\n  //         float specularIntensityFactor = 1.0;\n  //         vec3 specularColorFactor = vec3( 1.0 );\n  //         material.specularF90 = 1.0;\n  //     #endif\n  //     material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n  // #else\n      material.specularColor = mix( vec3<f32>( 0.04 ), diffuseColor.rgb, metalnessFactor );\n      material.specularF90 = 1.0;\n  // #endif\n\n\n  // Lighting\n  // ========\n  var numDirectionalLights = lightingConfigUniform.numDirectionalLights;\n\n  ${e => e.defines.NUM_DIR_LIGHTS ? `\n  for (var i : u32 = 0u; i < numDirectionalLights; i = i + 1u) {\n    var directionalLight: DirectionalLight;\n    directionalLight.direction = directionLightsUniform.directionalLights[i].direction.xyz;\n    directionalLight.color = directionLightsUniform.directionalLights[i].color.xyz;\n\n    getDirectionalLightInfo( directionalLight, geometry, &directLight );\n    RE_Direct_Physical( directLight, geometry, material, &reflectedLight );\n  }` : ''}\n\n  // #if defined( RE_IndirectDiffuse )\n  var iblIrradiance = vec3<f32>( 0.0 );\n  var irradiance = sceneLightingUniform.ambientLightColor.xyz;\n\n  // TODO\n  // irradiance = irradiance + getLightProbeIrradiance( lightProbe, geometry.normal );\n\n  // #if defined( RE_IndirectSpecular )\n  var radiance = vec3<f32>( 0.0 );\n  var clearcoatRadiance = vec3<f32>( 0.0 );\n\n  // #if defined( RE_IndirectDiffuse )\n    // #ifdef USE_LIGHTMAP\n    //   vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n    //   vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n    //   #ifndef PHYSICALLY_CORRECT_LIGHTS\n    //       lightMapIrradiance *= PI;\n    //   #endif\n    //   irradiance = irradiance + lightMapIrradiance;\n    // #endif\n    // #if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n    //   iblIrradiance = iblIrradiance + getIBLIrradiance( geometry.normal );\n    // #endif\n  // #endif\n\n  // #if defined( RE_IndirectDiffuse )\n    RE_IndirectDiffuse_Physical( irradiance, geometry, material, &reflectedLight );\n  // #endif\n  // #if defined( RE_IndirectSpecular )\n    RE_IndirectSpecular_Physical( radiance, iblIrradiance, clearcoatRadiance, geometry, material, &reflectedLight );\n  // #endif\n\n  var totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n  var totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n  var outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n  return vec4<f32>( outgoingLight.xyz, 1.0);\n}\n`;\n\ninterface DebugDefines {\n  diffuseMap?: Texture;\n  normalMap?: Texture;\n  metalnessMap?: Texture;\n  roughnessMap?: Texture;\n  NUM_DIR_LIGHTS: number;\n}\n\nexport class DebugPipeline extends Pipeline<DebugDefines> {\n  constructor(name: string, defines: DebugDefines) {\n    super(name, vertexShader, fragmentShader, defines);\n  }\n\n  onAddResources(): void {\n    const transformResource = new TransformResource();\n    this.addTemplate(transformResource);\n\n    const materialResource = new MaterialResource();\n    this.addTemplate(materialResource);\n\n    const lightingResource = new LightingResource();\n    this.addTemplate(lightingResource);\n\n    if (this.defines.diffuseMap) {\n      const resource = new TextureResource(this.defines.diffuseMap, \"diffuse\");\n      this.addTemplate(resource);\n    }\n\n    if (this.defines.normalMap) {\n      const resource = new TextureResource(this.defines.normalMap, \"normal\");\n      this.addTemplate(resource);\n    }\n  }\n\n  build(gameManager: GameManager): void {\n    super.build(gameManager);\n\n    // Build the shaders - should go after adding the resources as we might use those in the shader source\n    const vertSource = shaderBuilder(this.vertexSource, this);\n    const fragSource = shaderBuilder(this.fragmentSource, this);\n\n    this.renderPipeline = gameManager.device.createRenderPipeline({\n      ...defaultPipelineDescriptor,\n      label: \"Debug Pipeline\",\n      vertex: {\n        module: gameManager.device.createShaderModule({\n          code: vertSource,\n        }),\n        entryPoint: \"main\",\n        buffers: [\n          {\n            arrayStride: Float32Array.BYTES_PER_ELEMENT * 3, // (3 + 2)\n            attributes: [\n              {\n                shaderLocation: 0,\n                format: \"float32x3\",\n                offset: 0,\n              },\n              // {\n              //   shaderLocation: 1,\n              //   format: \"float32x3\",\n              //   offset: 12,\n              // },\n            ],\n          },\n          {\n            arrayStride: Float32Array.BYTES_PER_ELEMENT * 3,\n            attributes: [\n              {\n                shaderLocation: 1,\n                format: \"float32x3\",\n                offset: 0,\n              },\n            ],\n          },\n          {\n            arrayStride: Float32Array.BYTES_PER_ELEMENT * 2,\n            attributes: [\n              {\n                shaderLocation: 2,\n                format: \"float32x2\",\n                offset: 0,\n              },\n            ],\n          },\n        ],\n      },\n      fragment: {\n        module: gameManager.device.createShaderModule({\n          code: fragSource,\n        }),\n        entryPoint: \"main\",\n        targets: [{ format: gameManager.format }],\n      },\n    });\n  }\n}\n","import { GameManager } from \"../../GameManager\";\nimport { UNIFORM_TYPES_MAP } from \"./MemoryUtils\";\nimport { BindingData, PipelineResourceTemplate, Template } from \"./PipelineResourceTemplate\";\nimport { GroupType } from \"../../../../common/GroupType\";\nimport { ResourceType } from \"../../../../common/ResourceType\";\nimport { Defines } from \"../shader-lib/Utils\";\nimport { Pipeline } from \"../Pipeline\";\n\nexport class LightingResource extends PipelineResourceTemplate {\n  static lightingConfig: GPUBuffer;\n  static directionLightsBuffer: GPUBuffer;\n  static sceneLightingBuffer: GPUBuffer;\n\n  static numDirLights: number = 0;\n  static rebuildDirectionLights = true;\n\n  directionLightBinding: number;\n  lightingConfigBinding: number;\n  sceneLightingBinding: number;\n\n  constructor() {\n    super(GroupType.Material, ResourceType.Lighting);\n  }\n\n  build<T extends Defines<T>>(manager: GameManager, pipeline: Pipeline<T>, curBindIndex: number): Template {\n    this.lightingConfigBinding = curBindIndex;\n    this.sceneLightingBinding = curBindIndex + 1;\n    this.directionLightBinding = pipeline.defines.NUM_DIR_LIGHTS ? curBindIndex + 2 : -1;\n    const group = pipeline.groupIndex(this.groupType);\n\n    if (!LightingResource.lightingConfig) {\n      const LIGHTING_CONFIG_SIZE = UNIFORM_TYPES_MAP[\"u32\"];\n      const SCENE_LIGHTING_BUFFER = UNIFORM_TYPES_MAP[\"vec4<f32>\"];\n\n      LightingResource.lightingConfig = manager.device.createBuffer({\n        label: \"lightingConfigUniform\",\n        size: LIGHTING_CONFIG_SIZE,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n      });\n\n      LightingResource.sceneLightingBuffer = manager.device.createBuffer({\n        label: \"sceneLightingBuffer\",\n        size: SCENE_LIGHTING_BUFFER,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n      });\n\n      // Defaults for lighting info\n      // prettier-ignore\n      const lightInofoDefaults = new Uint32Array([\n        0, // Num Directional lights\n      ]);\n\n      // Defaults for scene lights buffer\n      // prettier-ignore\n      const sceneLightingBufferDefaults = new  Float32Array([\n        0.0, 0.0, 0.0, 0, // Ambient Light Color\n      ]);\n\n      // Set defaults\n      new Float32Array(LightingResource.lightingConfig.getMappedRange()).set(lightInofoDefaults);\n      LightingResource.lightingConfig.unmap();\n\n      new Float32Array(LightingResource.sceneLightingBuffer.getMappedRange()).set(sceneLightingBufferDefaults);\n      LightingResource.sceneLightingBuffer.unmap();\n    }\n\n    if (LightingResource.rebuildDirectionLights && LightingResource.numDirLights > 0) {\n      LightingResource.rebuildDirectionLights = false;\n\n      if (LightingResource.directionLightsBuffer) LightingResource.directionLightsBuffer.destroy();\n\n      LightingResource.directionLightsBuffer = manager.device.createBuffer({\n        label: \"dirLightsBuffer\",\n        size: UNIFORM_TYPES_MAP[\"vec4<f32>\"] * 2 * LightingResource.numDirLights,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      });\n    }\n\n    // prettier-ignore\n    return {\n      group,\n      bindings: [ { buffer: LightingResource.lightingConfig, }, { buffer: LightingResource.sceneLightingBuffer },\n      ].concat(LightingResource.numDirLights ? { buffer: LightingResource.directionLightsBuffer } : []),\n\n      fragmentBlock: `struct SceneLightingUniform {\n        ambientLightColor: vec4<f32>;\n      };\n\n      struct LightingConfigUniform {\n        numDirectionalLights: u32;\n      };\n\n      @group(${group}) @binding(${this.lightingConfigBinding})\n      var<uniform> lightingConfigUniform: LightingConfigUniform;\n\n      @group(${group}) @binding(${this.sceneLightingBinding})\n      var<uniform> sceneLightingUniform: SceneLightingUniform;\n\n\n      ${pipeline.defines.NUM_DIR_LIGHTS ? `\n      struct DirectionLightUniform {\n        direction : vec4<f32>;\n        color : vec4<f32>;\n      };\n\n      struct DirectionLightsUniform {\n        directionalLights: array<DirectionLightUniform>;\n      };\n\n      @group(${group}) @binding(${this.directionLightBinding})\n      var<storage, read> directionLightsUniform: DirectionLightsUniform;\n      ` : ''}\n      `,\n      vertexBlock: null,\n    };\n  }\n\n  getBindingData(manager: GameManager, pipeline: GPURenderPipeline): BindingData {\n    return {\n      binds: [\n        {\n          binding: this.lightingConfigBinding,\n          resource: {\n            buffer: LightingResource.lightingConfig,\n          },\n        },\n        {\n          binding: this.sceneLightingBinding,\n          resource: {\n            buffer: LightingResource.sceneLightingBuffer,\n          },\n        },\n      ].concat(\n        LightingResource.numDirLights\n          ? {\n              binding: this.directionLightBinding,\n              resource: {\n                buffer: LightingResource.directionLightsBuffer,\n              },\n            }\n          : []\n      ),\n      buffer: null,\n    };\n  }\n}\n","import { GameManager } from \"../../GameManager\";\nimport { BindingData, PipelineResourceTemplate, Template } from \"./PipelineResourceTemplate\";\nimport { Defines } from \"../shader-lib/Utils\";\nimport { Pipeline } from \"../Pipeline\";\nimport { GroupType } from \"../../../../common/GroupType\";\nimport { ResourceType } from \"../../../../common/ResourceType\";\n\nexport class MaterialResource extends PipelineResourceTemplate {\n  binding: number;\n\n  constructor() {\n    super(GroupType.Material, ResourceType.Material);\n  }\n\n  build<T extends Defines<T>>(manager: GameManager, pipeline: Pipeline<T>, curBindIndex: number): Template {\n    this.binding = curBindIndex;\n    const group = pipeline.groupIndex(this.groupType);\n\n    // prettier-ignore\n    const initialValues = new Float32Array([\n      1, 1, 1, 0,         // Diffuse\n      0.0, 0.0, 0.0, 0,   // Emissive\n      1,                  // Alpha\n      0,                  // Metalness\n      0.5                 // Roughness\n    ]);\n    const SIZE = Float32Array.BYTES_PER_ELEMENT * initialValues.length;\n\n    const buffer = manager.device.createBuffer({\n      label: \"materialData\",\n      size: SIZE,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n\n    // Set defaults\n    new Float32Array(buffer.getMappedRange()).set(initialValues);\n    buffer.unmap();\n\n    const resource: GPUBindingResource = {\n      buffer: buffer,\n      offset: 0,\n      size: SIZE,\n    };\n\n    return {\n      group,\n      bindings: [resource],\n      // prettier-ignore\n      fragmentBlock: `\n      struct MaterialData {\n        diffuse: vec4<f32>;\n        emissive: vec4<f32>;\n        opacity: f32;\n        metalness: f32;\n        roughness: f32;\n      };\n\n      @group(${group}) @binding(${curBindIndex})\n      var<uniform> materialData: MaterialData;\n      `,\n      vertexBlock: null,\n    };\n  }\n\n  getBindingData(manager: GameManager, pipeline: GPURenderPipeline): BindingData {\n    // prettier-ignore\n    const initialValues = new Float32Array([\n      1, 1, 1, 0,         // Diffuse\n      0.0, 0.0, 0.0, 0,   // Emissive\n      1,                  // Alpha\n      0,                  // Metalness\n      0.5                 // Roughness\n    ]);\n    const SIZE = Float32Array.BYTES_PER_ELEMENT * initialValues.length;\n\n    const buffer = manager.device.createBuffer({\n      label: \"materialData\",\n      size: SIZE,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n      mappedAtCreation: true,\n    });\n\n    // Set defaults\n    new Float32Array(buffer.getMappedRange()).set(initialValues);\n    buffer.unmap();\n\n    const resource: GPUBindingResource = {\n      buffer: buffer,\n      offset: 0,\n      size: SIZE,\n    };\n\n    return {\n      binds: [\n        {\n          binding: this.binding,\n          resource,\n        },\n      ],\n      buffer,\n    };\n  }\n}\n","export const UNIFORM_TYPES_MAP = {\r\n  \"mat4x4<f32>\": 16 * Float32Array.BYTES_PER_ELEMENT,\r\n  \"mat3x3<f32>\": 12 * Float32Array.BYTES_PER_ELEMENT,\r\n  \"vec4<f32>\": 4 * Float32Array.BYTES_PER_ELEMENT,\r\n  \"vec3<f32>\": 3 * Float32Array.BYTES_PER_ELEMENT,\r\n  \"vec2<f32>\": 2 * Float32Array.BYTES_PER_ELEMENT,\r\n  f32: 1 * Float32Array.BYTES_PER_ELEMENT,\r\n  i32: 1 * Int32Array.BYTES_PER_ELEMENT,\r\n  u32: 1 * Uint32Array.BYTES_PER_ELEMENT,\r\n  i16: 1 * Int16Array.BYTES_PER_ELEMENT,\r\n  u16: 1 * Uint16Array.BYTES_PER_ELEMENT,\r\n};\r\n","export class PipelineResourceInstance {\r\n  group: number;\r\n  bindGroup: GPUBindGroup;\r\n  buffers: GPUBuffer[] | null;\r\n\r\n  constructor(group: number, bindGroup: GPUBindGroup, buffer: GPUBuffer[] | null = null) {\r\n    this.group = group;\r\n    this.bindGroup = bindGroup;\r\n    this.buffers = buffer;\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.buffers) this.buffers!.forEach((b) => b.destroy());\r\n  }\r\n}\r\n","import { GameManager } from \"../../GameManager\";\r\nimport { Pipeline } from \"../Pipeline\";\r\nimport { GroupType } from \"../../../../common/GroupType\";\r\nimport { ResourceType } from \"../../../../common/ResourceType\";\r\nimport { Defines } from \"../shader-lib/Utils\";\r\n\r\nexport type Template = {\r\n  group: number;\r\n  bindings: GPUBindingResource[];\r\n  fragmentBlock: string | null;\r\n  vertexBlock: string | null;\r\n};\r\n\r\nexport type BindingData = {\r\n  binds: GPUBindGroupEntry[];\r\n  buffer: GPUBuffer | null;\r\n};\r\n\r\nexport abstract class PipelineResourceTemplate {\r\n  template: Template;\r\n  groupType: GroupType;\r\n  resourceType: ResourceType;\r\n  id?: string;\r\n\r\n  constructor(groupType: GroupType, groupSubType: ResourceType, id?: string) {\r\n    this.groupType = groupType;\r\n    this.resourceType = groupSubType;\r\n    this.id = id;\r\n  }\r\n\r\n  /** Creates the resource. Must return a group index*/\r\n  abstract build<T extends Defines<T>>(manager: GameManager, pipeline: Pipeline<T>, curBindIndex: number): Template;\r\n  abstract getBindingData(manager: GameManager, pipeline: GPURenderPipeline): BindingData;\r\n}\r\n","import { GameManager } from \"../../GameManager\";\nimport { Texture } from \"../../Texture\";\nimport { BindingData, PipelineResourceTemplate, Template } from \"./PipelineResourceTemplate\";\nimport { Pipeline } from \"../Pipeline\";\nimport { Defines } from \"../shader-lib/Utils\";\nimport { GroupType } from \"../../../../common/GroupType\";\nimport { ResourceType } from \"../../../../common/ResourceType\";\n\nexport class TextureResource extends PipelineResourceTemplate {\n  texture: Texture;\n  textureBind: number;\n  samplerBind: number;\n\n  constructor(texture: Texture, id: string) {\n    super(GroupType.Material, ResourceType.Texture, id);\n    this.texture = texture;\n  }\n\n  build<T extends Defines<T>>(manager: GameManager, pipeline: Pipeline<T>, curBindIndex: number): Template {\n    this.samplerBind = curBindIndex;\n    this.textureBind = curBindIndex + 1;\n    const group = pipeline.groupIndex(this.groupType);\n\n    // prettier-ignore\n    return {\n      group,\n      bindings: [manager.samplers[0], this.texture!.gpuTexture.createView()],\n      fragmentBlock: `\n      ${pipeline.defines.diffuseMap && `\n      @group(${group}) @binding(${this.samplerBind})\n      var ${this.id}Sampler: sampler;\n      @group(${group}) @binding(${this.textureBind})\n      var ${this.id}Texture: texture_2d<f32>;`\n      }`,\n      vertexBlock: null,\n    };\n  }\n\n  getBindingData(manager: GameManager, pipeline: GPURenderPipeline): BindingData {\n    return {\n      binds: [\n        {\n          binding: this.samplerBind,\n          resource: manager.samplers[0],\n        },\n        {\n          binding: this.textureBind,\n          resource: this.texture!.gpuTexture.createView(),\n        },\n      ],\n      buffer: null,\n    };\n  }\n}\n","import { GameManager } from \"../../GameManager\";\nimport { UNIFORM_TYPES_MAP } from \"./MemoryUtils\";\nimport { BindingData, PipelineResourceTemplate, Template } from \"./PipelineResourceTemplate\";\nimport { Pipeline } from \"../Pipeline\";\nimport { Defines } from \"../shader-lib/Utils\";\nimport { GroupType } from \"../../../../common/GroupType\";\nimport { ResourceType } from \"../../../../common/ResourceType\";\n\nexport class TransformResource extends PipelineResourceTemplate {\n  binding: number;\n\n  constructor() {\n    super(GroupType.Transform, ResourceType.Transform);\n  }\n\n  build<T extends Defines<T>>(manager: GameManager, pipeline: Pipeline<T>, curBindIndex: number): Template {\n    this.binding = curBindIndex;\n    const group = pipeline.groupIndex(this.groupType);\n\n    const SIZEOF_MATRICES = UNIFORM_TYPES_MAP[\"mat4x4<f32>\"] * 2 + UNIFORM_TYPES_MAP[\"mat3x3<f32>\"];\n\n    const buffer = manager.device.createBuffer({\n      label: \"transform\",\n      size: SIZEOF_MATRICES,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n\n    return {\n      group,\n      bindings: [\n        {\n          buffer,\n        },\n      ],\n      fragmentBlock: null,\n      // prettier-ignore\n      vertexBlock: `\n      struct TransformUniform {\n        projMatrix: mat4x4<f32>;\n        modelViewMatrix: mat4x4<f32>;\n        normalMatrix: mat3x3<f32>;\n      };\n      @group(${group}) @binding(${curBindIndex})\n      var<uniform> uniforms: TransformUniform;\n      `,\n    };\n  }\n\n  getBindingData(manager: GameManager, pipeline: GPURenderPipeline): BindingData {\n    const SIZEOF_MATRICES = UNIFORM_TYPES_MAP[\"mat4x4<f32>\"] * 2 + UNIFORM_TYPES_MAP[\"mat3x3<f32>\"];\n\n    const buffer = manager.device.createBuffer({\n      label: \"transform\",\n      size: SIZEOF_MATRICES,\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n\n    return {\n      binds: [\n        {\n          binding: this.binding,\n          resource: {\n            buffer: buffer,\n            offset: 0,\n            size: SIZEOF_MATRICES,\n          },\n        },\n      ],\n      buffer,\n    };\n  }\n}\n","export const mathConstants = /* wgsl */ `\r\nlet PI: f32 = 3.141592653589793;\r\nlet PI2: f32 = 6.283185307179586;\r\nlet PI_HALF: f32 = 1.5707963267948966;\r\nlet RECIPROCAL_PI: f32 = 0.3183098861837907;\r\nlet RECIPROCAL_PI2: f32 = 0.15915494309189535;\r\nlet EPSILON: f32 = 0.000001;\r\n`;\r\n\r\nexport const mathFunctions = /* wgsl */ `\r\nfn saturate( a: f32 ) -> f32 {\r\n    return clamp( a, 0.0, 1.0 );\r\n}\r\n\r\nfn whiteComplement( a: f32 ) -> f32 {\r\n    return ( 1.0 - saturate( a ) );\r\n}\r\n\r\nfn pow2( x: f32 ) -> f32 {\r\n    return x*x;\r\n}\r\n\r\nfn pow3( x: f32 ) -> f32 {\r\n    return x*x*x;\r\n}\r\n\r\nfn pow4( x: f32 ) -> f32 {\r\n    var x2 = x*x;\r\n    return x2*x2;\r\n}\r\n\r\nfn max3( v: vec3<f32> ) -> f32 {\r\n    return max( max( v.x, v.y ), v.z );\r\n}\r\n\r\nfn average( color: vec3<f32> )-> f32 {\r\n    return dot( color, vec3( 0.3333 ) );\r\n}\r\n\r\nfn rand( uv: vec2<f32> ) -> f32 {\r\n    var a: f32 = 12.9898;\r\n    var b: f32 = 78.233;\r\n    var c: f32 = 43758.5453;\r\n    var dt = dot( uv.xy, vec2<f32>( a, b ) );\r\n    var sn = dt % PI;\r\n    return fract( sin( sn ) * c );\r\n}\r\n\r\nfn precisionSafeLength( v: vec3<f32> )-> f32 {\r\n    return length( v );\r\n}`;\r\n","import { Texture } from \"../../Texture\";\r\nimport { Pipeline } from \"../Pipeline\";\r\n\r\nexport type Defines<T> = {\r\n  [K in keyof T]: T[K];\r\n} & {\r\n  diffuseMap?: Texture;\r\n  normalMap?: Texture;\r\n  NUM_DIR_LIGHTS: number;\r\n};\r\n\r\nexport type ShaderFunction<T extends Defines<T>> =\r\n  | ((pipeline: Pipeline<T>) => number | string | boolean | undefined | null)\r\n  | string;\r\nexport interface SourceFragments<T extends Defines<T>> {\r\n  strings: TemplateStringsArray;\r\n  expressions: (ShaderFunction<T> | string)[];\r\n}\r\n\r\nexport function shader<T extends Defines<T>>(\r\n  strings: TemplateStringsArray,\r\n  ...expr: ShaderFunction<T>[]\r\n): SourceFragments<T> {\r\n  return {\r\n    strings,\r\n    expressions: expr,\r\n  };\r\n}\r\n\r\nexport function shaderBuilder<T extends Defines<T>>(sourceFragments: SourceFragments<T>, pipeline: Pipeline<T>) {\r\n  let str = \"\";\r\n  sourceFragments.strings.forEach((string, i) => {\r\n    if (typeof sourceFragments.expressions[i] === \"string\" || typeof sourceFragments.expressions[i] === \"number\")\r\n      str += string + (sourceFragments.expressions[i] || \"\");\r\n    else if (sourceFragments.expressions[i]) {\r\n      const fnOrText = sourceFragments.expressions[i];\r\n      if (typeof fnOrText === \"string\") {\r\n        str += string + fnOrText;\r\n      } else {\r\n        const expressionReturn = fnOrText(pipeline);\r\n\r\n        if (typeof expressionReturn === \"string\") {\r\n          str += string + expressionReturn;\r\n        } else if (typeof expressionReturn === \"number\") {\r\n          str += string + expressionReturn.toString();\r\n        } else {\r\n          str += string;\r\n        }\r\n      }\r\n    } else {\r\n      str += string;\r\n    }\r\n  });\r\n  return str;\r\n}\r\n","import { Component, createSignal, onMount } from \"solid-js\";\nimport { styled } from \"solid-styled-components\";\nimport { GameManager } from \"../../core/GameManager\";\nimport { WasmManager } from \"../../core/WasmManager\";\nimport { Button } from \"../common/Button\";\nimport { Modal } from \"../common/Modal\";\nimport { Pane3D } from \"../common/Pane3D\";\nimport { Typography } from \"../common/Typography\";\n\ninterface Props {}\n\nexport const Application: Component<Props> = ({}) => {\n  const [modalOpen, setModalOpen] = createSignal(true);\n\n  let gameManager: GameManager;\n  const wasmManager: WasmManager = new WasmManager();\n\n  onMount(async () => {\n    document.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Escape\") setModalOpen(!modalOpen());\n    });\n  });\n\n  const onCanvasReady = async (canvas: HTMLCanvasElement) => {\n    gameManager = new GameManager(canvas);\n    await wasmManager.load(gameManager);\n    const message = document.querySelector(\"#message\") as HTMLElement;\n    try {\n      await gameManager.init(wasmManager);\n    } catch (err: unknown) {\n      message.style.display = \"initial\";\n      message.innerHTML = (err as Error).message;\n    }\n  };\n\n  const onStart = () => {\n    setModalOpen(false);\n  };\n\n  return (\n    <StyledApplication>\n      <Modal hideConfirmButtons open={modalOpen()} title=\"Hello World\" onClose={() => setModalOpen(false)}>\n        <Typography variant=\"h4\" align=\"center\">\n          Rewild!\n        </Typography>\n        <Typography variant=\"body2\">\n          Welcome to rewild. A game about exploration, natural history and saving the planet\n        </Typography>\n        <StyledButtons>\n          <Button fullWidth variant=\"outlined\" disabled>\n            Options\n          </Button>\n          <Button onClick={onStart} fullWidth variant=\"contained\" color=\"primary\">\n            Start Game\n          </Button>\n        </StyledButtons>\n      </Modal>\n      <Pane3D onCanvasReady={onCanvasReady} />\n    </StyledApplication>\n  );\n};\n\nconst StyledApplication = styled.div`\n  width: 100%;\n  height: 100%;\n  margin: 0;\n`;\n\nconst StyledButtons = styled.div`\n  button {\n    margin: 1rem 0 0 0;\n  }\n`;\n","import { styled } from \"solid-styled-components\";\nimport { Component } from \"solid-js\";\n\nexport type ButtonVariant = \"contained\" | \"outlined\";\nexport type ButtonColor = \"primary\" | \"secondary\" | \"error\";\n\ninterface Props {\n  disabled?: boolean;\n  variant?: ButtonVariant;\n  color?: ButtonColor;\n  fullWidth?: boolean;\n  onClick?: (e: MouseEvent) => void;\n  class?: string;\n}\n\nexport const Button: Component<Props> = (props) => {\n  return (\n    <StyledButton\n      fullWidth={props.fullWidth || false}\n      disabled={props.disabled}\n      onClick={props.onClick}\n      className={`${props.class} ${props.variant || \"contained\"} ${props.color || \"primary\"}`}\n    >\n      {props.children}\n    </StyledButton>\n  );\n};\n\nconst StyledButton = styled.button<{ fullWidth: boolean }>`\n  padding: 0.5rem 1rem;\n  border-radius: 5px;\n  border: none;\n  text-transform: uppercase;\n  font-weight: 500;\n  font-family: var(--font-family);\n  font-weight: 400;\n  cursor: pointer;\n  user-select: none;\n  ${(e) => (e.fullWidth ? \"width: 100%;\" : \"\")}\n  transition: box-shadow 0.25s, background-color 0.25s;\n  display: ${(e) => (e.fullWidth ? \"block\" : \"inline-block\")};\n\n  &[disabled],\n  &[disabled]:hover {\n    opacity: 0.65;\n    pointer-events: none;\n  }\n\n  &.contained {\n    box-shadow: 2px 2px 2px rgb(0 0 0 / 30%);\n  }\n\n  &.contained:hover {\n    box-shadow: 2px 2px 4px rgb(0 0 0 / 40%);\n  }\n\n  &.contained.primary {\n    background: var(--primary-400);\n    color: var(--on-primary-400);\n  }\n  &.contained.primary:hover {\n    background: var(--primary-500);\n    color: var(--on-primary-500);\n  }\n  &.contained.primary:active {\n    background: var(--primary-600);\n    color: var(--on-primary-600);\n  }\n\n  &.contained.secondary {\n    background: var(--secondary-400);\n    color: var(--on-secondary-400);\n  }\n  &.contained.secondary:hover {\n    background: var(--secondary-500);\n    color: var(--on-secondary-500);\n  }\n  &.contained.secondary:active {\n    background: var(--secondary-600);\n    color: var(--on-secondary-600);\n  }\n\n  &.contained.error {\n    background: var(--error-400);\n    color: var(--on-errory-400);\n  }\n  &.contained.error:hover {\n    background: var(--error-500);\n    color: var(--on-error-500);\n  }\n  &.contained.error:active {\n    background: var(--error-600);\n    color: var(--on-error-600);\n  }\n\n  &.outlined {\n    background: transparent;\n  }\n  &.outlined:hover {\n    background: rgba(0, 0, 0, 0.05);\n  }\n  &.outlined:active {\n    background: rgba(0, 0, 0, 0.1);\n  }\n\n  &.outlined.primary {\n    color: var(--primary-400);\n    border: 1px solid var(--primary-400);\n  }\n  &.outlined.secondary {\n    color: var(--secondary-400);\n    border: 1px solid var(--secondary-400);\n  }\n  &.outlined.error {\n    color: var(--errory-400);\n    border: 1px solid var(--errory-400);\n  }\n`;\n","import { styled } from \"solid-styled-components\";\nimport { Portal } from \"solid-js/web\";\nimport { Component } from \"solid-js\";\nimport { Button } from \"./Button\";\n\ninterface Props {\n  title: string;\n  open: boolean;\n  hideConfirmButtons?: boolean;\n  onClose?: () => void;\n  onCancel?: () => void;\n  onOk?: () => void;\n}\n\nexport const Modal: Component<Props> = (props) => {\n  const handleClick = (e: MouseEvent) => {\n    if ((e.target as HTMLElement).classList.contains(\"wrapper\")) {\n      props.onClose && props.onClose();\n    }\n  };\n\n  const handleCancel = (e: MouseEvent) => {\n    props.onCancel && props.onCancel();\n    props.onClose && props.onClose();\n  };\n\n  const handleOk = (e: MouseEvent) => {\n    props.onOk && props.onOk();\n    props.onClose && props.onClose();\n  };\n\n  return (\n    <Portal>\n      <StyledWrapper class=\"wrapper\" onClick={handleClick} visible={props.open}>\n        <StyledModal class=\"modal\">\n          <span class=\"title\">{props.title}</span>\n          <div class=\"content\">{props.children}</div>\n          {props.hideConfirmButtons ? null : (\n            <div class=\"button-container\">\n              <Button onClick={handleCancel} class=\"cancel\" variant=\"outlined\">\n                Cancel\n              </Button>\n              <Button onClick={handleOk} class=\"ok\">\n                Okay\n              </Button>\n            </div>\n          )}\n        </StyledModal>\n      </StyledWrapper>\n    </Portal>\n  );\n};\n\nconst StyledWrapper = styled.div<{ visible: boolean }>`\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.5);\n  opacity: 0;\n  visibility: hidden;\n  transform: scale(1.1);\n  transition: visibility 0s linear 0.25s, opacity 0.25s 0s, transform 0.25s;\n  z-index: 1;\n\n  ${(e) =>\n    e.visible\n      ? `opacity: 1;\n  visibility: visible;\n  transform: scale(1);\n  transition: visibility 0s linear 0s, opacity 0.25s 0s, transform 0.25s;`\n      : \"\"}\n`;\n\nconst StyledModal = styled.div`\n  padding: 1rem;\n  background-color: var(--surface);\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  border-radius: 5px;\n  min-width: 300px;\n  box-shadow: 2px 2px 2px 4px rgba(0, 0, 0, 0.1);\n\n  .title {\n    font-size: 18px;\n  }\n  .button-container {\n    text-align: right;\n  }\n  .button-container > button {\n    margin: 0 0 0 4px;\n  }\n  .content {\n    padding: 0.5rem 0;\n  }\n`;\n","import { styled } from \"solid-styled-components\";\nimport { Component, onCleanup, onMount } from \"solid-js\";\n\ninterface Props {\n  onCanvasReady: (canvas: HTMLCanvasElement) => void;\n}\n\nexport const Pane3D: Component<Props> = (props) => {\n  let parent!: HTMLDivElement;\n\n  const onResizeDelegate = () => {\n    const canvas = parent.firstElementChild as HTMLCanvasElement;\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n  };\n\n  onMount(() => {\n    window.addEventListener(\"resize\", onResizeDelegate);\n    onResizeDelegate();\n  });\n\n  onCleanup(() => {\n    window.removeEventListener(\"resize\", onResizeDelegate);\n  });\n\n  return (\n    <StyledCanvas ref={parent}>\n      <canvas ref={props.onCanvasReady}></canvas>\n    </StyledCanvas>\n  );\n};\n\nconst StyledCanvas = styled.div`\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  display: block;\n`;\n","import { styled } from \"solid-styled-components\";\nimport { Component } from \"solid-js\";\n\nexport type TypographyVariant = \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"body1\" | \"body2\";\nexport type TypographyAlign = \"center\" | \"inherit\" | \"justify\" | \"left\" | \"right\";\n\ninterface Props {\n  variant: TypographyVariant;\n  align?: TypographyAlign;\n}\n\nexport const Typography: Component<Props> = (props) => {\n  return (\n    <StyledTypography className={`typography ${props.variant}`} style={{ textAlign: props.align }}>\n      {props.children}\n    </StyledTypography>\n  );\n};\n\nconst StyledTypography = styled.div`\n  margin: 0;\n  font-family: var(--font-family);\n  margin-bottom: 0.35em;\n\n  .h1 {\n    font-weight: 300;\n    font-size: 6rem;\n    line-height: 1.167;\n    letter-spacing: -0.01562em;\n  }\n\n  .h2 {\n    font-weight: 300;\n    font-size: 3.75rem;\n    line-height: 1.2;\n    letter-spacing: -0.00833em;\n  }\n\n  .h3 {\n    font-weight: 400;\n    font-size: 3rem;\n    line-height: 1.167;\n    letter-spacing: 0em;\n  }\n\n  .h4 {\n    font-weight: 400;\n    font-size: 2.125rem;\n    line-height: 1.235;\n    letter-spacing: 0.00735em;\n  }\n\n  .body1 {\n    font-weight: 400;\n    font-size: 1rem;\n    line-height: 1.5;\n    letter-spacing: 0.00938em;\n  }\n\n  .body2 {\n    font-weight: 400;\n    font-size: 0.875rem;\n    line-height: 1.43;\n    letter-spacing: 0.01071em;\n  }\n`;\n","import { DefaultTheme } from \"solid-styled-components\";\n\nexport const theme: DefaultTheme = {\n  colors: {\n    primary: \"hotpink\",\n  },\n};\n","export default __webpack_public_path__ + \"untouched.wasm\";","// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\n// const ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst STATICARRAY = 1 << 2;\n// const SET = 1 << 3;\n// const MAP = 1 << 4;\nconst VAL_ALIGN_OFFSET = 6;\n// const VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 11;\nconst VAL_FLOAT = 1 << 12;\n// const VAL_NULLABLE = 1 << 13;\nconst VAL_MANAGED = 1 << 14;\n// const KEY_ALIGN_OFFSET = 15;\n// const KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\n// const KEY_SIGNED = 1 << 20;\n// const KEY_FLOAT = 1 << 21;\n// const KEY_NULLABLE = 1 << 22;\n// const KEY_MANAGED = 1 << 23;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\n\nconst STRING_DECODE_THRESHOLD = 32;\nconst decoder = new TextDecoder(\"utf-16le\");\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const len = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2] >>> 1;\n  const arr = new Uint16Array(buffer, ptr, len);\n  if (len <= STRING_DECODE_THRESHOLD) {\n    return String.fromCharCode.apply(String, arr);\n  }\n  return decoder.decode(arr);\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const extendedExports = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(msg, file, line, colm) {\n    const memory = extendedExports.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(`abort: ${getString(memory, msg)} at ${getString(memory, file)}:${line}:${colm}`);\n  };\n  env.trace = env.trace || function trace(msg, n, ...args) {\n    const memory = extendedExports.memory || env.memory;\n    console.log(`trace: ${getString(memory, msg)}${n ? \" \" : \"\"}${args.slice(0, n).join(\", \")}`);\n  };\n  env.seed = env.seed || Date.now;\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return extendedExports;\n}\n\nconst E_NOEXPORTRUNTIME = \"Operation requires compiling with --exportRuntime\";\nconst F_NOEXPORTRUNTIME = function() { throw Error(E_NOEXPORTRUNTIME); };\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(extendedExports, instance) {\n  const exports = instance.exports;\n  const memory = exports.memory;\n  const table = exports.table;\n  const __new = exports.__new || F_NOEXPORTRUNTIME;\n  const __pin = exports.__pin || F_NOEXPORTRUNTIME;\n  const __unpin = exports.__unpin || F_NOEXPORTRUNTIME;\n  const __collect = exports.__collect || F_NOEXPORTRUNTIME;\n  const __rtti_base = exports.__rtti_base;\n  const getRttiCount = __rtti_base\n    ? function (arr) { return arr[__rtti_base >>> 2]; }\n    : F_NOEXPORTRUNTIME;\n\n  extendedExports.__new = __new;\n  extendedExports.__pin = __pin;\n  extendedExports.__unpin = __unpin;\n  extendedExports.__collect = __collect;\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = getRttiCount(U32);\n    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);\n    return U32[(__rtti_base + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets and validate runtime type info for the given id for array like objects */\n  function getArrayInfo(id) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY | STATICARRAY))) throw Error(`not an array: ${id}, flags=${info}`);\n    return info;\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = getRttiCount(U32);\n    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);\n    return U32[(__rtti_base + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  // function getKeyAlign(info) {\n  //   return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  // }\n\n  /** Allocates a new string in the module's memory and returns its pointer. */\n  function __newString(str) {\n    if (str == null) return 0;\n    const length = str.length;\n    const ptr = __new(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  extendedExports.__newString = __newString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    if (!ptr) return null;\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(`not a string: ${ptr}`);\n    return getStringImpl(buffer, ptr);\n  }\n\n  extendedExports.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(`unsupported align: ${alignLog2}`);\n  }\n\n  /** Allocates a new array in the module's memory and returns its pointer. */\n  function __newArray(id, values) {\n    const info = getArrayInfo(id);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = __new(length << align, info & STATICARRAY ? id : ARRAYBUFFER_ID);\n    let result;\n    if (info & STATICARRAY) {\n      result = buf;\n    } else {\n      __pin(buf);\n      const arr = __new(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n      __unpin(buf);\n      const U32 = new Uint32Array(memory.buffer);\n      U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = buf;\n      U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n      U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n      if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n      result = arr;\n    }\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) {\n        const value = values[i];\n        view[(buf >>> align) + i] = value;\n      }\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return result;\n  }\n\n  extendedExports.__newArray = __newArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getArrayInfo(id);\n    const align = getValueAlign(info);\n    let buf = info & STATICARRAY\n      ? arr\n      : U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);\n  }\n\n  extendedExports.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  extendedExports.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  extendedExports.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  /** Attach a set of get TypedArray and View functions to the exports. */\n  function attachTypedArrayFunctions(ctor, name, align) {\n    extendedExports[`__get${name}`] = getTypedArray.bind(null, ctor, align);\n    extendedExports[`__get${name}View`] = getTypedArrayView.bind(null, ctor, align);\n  }\n\n  [\n    Int8Array,\n    Uint8Array,\n    Uint8ClampedArray,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array\n  ].forEach(ctor => {\n    attachTypedArrayFunctions(ctor, ctor.name, 31 - Math.clz32(ctor.BYTES_PER_ELEMENT));\n  });\n\n  if (BIGINT) {\n    [BigUint64Array, BigInt64Array].forEach(ctor => {\n      attachTypedArrayFunctions(ctor, ctor.name.slice(3), 3);\n    });\n  }\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    let id = U32[ptr + ID_OFFSET >>> 2];\n    if (id <= getRttiCount(U32)) {\n      do {\n        if (id == baseId) return true;\n        id = getBase(id);\n      } while (id);\n    }\n    return false;\n  }\n\n  extendedExports.__instanceof = __instanceof;\n\n  // Pull basic exports to extendedExports so code in preInstantiate can use them\n  extendedExports.memory = extendedExports.memory || memory;\n  extendedExports.table  = extendedExports.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(exports, extendedExports);\n}\n\nfunction isResponse(src) {\n  return typeof Response !== \"undefined\" && src instanceof Response;\n}\n\nfunction isModule(src) {\n  return src instanceof WebAssembly.Module;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nexport async function instantiate(source, imports = {}) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  const module = isModule(source) ? source : await WebAssembly.compile(source);\n  const extended = preInstantiate(imports);\n  const instance = await WebAssembly.instantiate(module, imports);\n  const exports = postInstantiate(extended, instance);\n  return { module, instance, exports };\n}\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nexport function instantiateSync(source, imports = {}) {\n  const module = isModule(source) ? source : new WebAssembly.Module(source);\n  const extended = preInstantiate(imports);\n  const instance = new WebAssembly.Instance(module, imports);\n  const exports = postInstantiate(extended, instance);\n  return { module, instance, exports };\n}\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nexport async function instantiateStreaming(source, imports = {}) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  const extended = preInstantiate(imports);\n  const result = await WebAssembly.instantiateStreaming(source, imports);\n  const exports = postInstantiate(extended, result.instance);\n  return { ...result, exports };\n}\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nexport function demangle(exports, extendedExports = {}) {\n  const setArgumentsLength = exports[\"__argumentsLength\"]\n    ? length => { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || (() => { /* nop */ });\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = extendedExports;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      const className = name.substring(0, hash);\n      const classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        const ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf() { return this[THIS]; }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get() { return getter(this[THIS]); },\n            set(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return extendedExports;\n}\n\nexport default {\n  instantiate,\n  instantiateSync,\n  instantiateStreaming,\n  demangle\n};\n","let e={data:\"\"},t=t=>\"object\"==typeof window?((t?t.querySelector(\"#_goober\"):window._goober)||Object.assign((t||document.head).appendChild(document.createElement(\"style\")),{innerHTML:\" \",id:\"_goober\"})).firstChild:t||e,r=e=>{let r=t(e),l=r.data;return r.data=\"\",l},l=/(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\\s*)/g,a=/\\/\\*[^]*?\\*\\/|\\s\\s+|\\n/g,n=(e,t)=>{let r=\"\",l=\"\",a=\"\";for(let o in e){let s=e[o];\"@\"==o[0]?\"i\"==o[1]?r=o+\" \"+s+\";\":l+=\"f\"==o[1]?n(s,o):o+\"{\"+n(s,\"k\"==o[1]?\"\":t)+\"}\":\"object\"==typeof s?l+=n(s,t?t.replace(/([^,])+/g,e=>o.replace(/(^:.*)|([^,])+/g,t=>/&/.test(t)?t.replace(/&/g,e):e?e+\" \"+t:t)):o):null!=s&&(o=/^--/.test(o)?o:o.replace(/[A-Z]/g,\"-$&\").toLowerCase(),a+=n.p?n.p(o,s):o+\":\"+s+\";\")}return r+(t&&a?t+\"{\"+a+\"}\":a)+l},o={},s=e=>{if(\"object\"==typeof e){let t=\"\";for(let r in e)t+=r+s(e[r]);return t}return e},c=(e,t,r,c,i)=>{let u=s(e),p=o[u]||(o[u]=(e=>{let t=0,r=11;for(;t<e.length;)r=101*r+e.charCodeAt(t++)>>>0;return\"go\"+r})(u));if(!o[p]){let t=u!==e?e:(e=>{let t,r=[{}];for(;t=l.exec(e.replace(a,\"\"));)t[4]?r.shift():t[3]?r.unshift(r[0][t[3]]=r[0][t[3]]||{}):r[0][t[1]]=t[2];return r[0]})(e);o[p]=n(i?{[\"@keyframes \"+p]:t}:t,r?\"\":\".\"+p)}return((e,t,r)=>{-1==t.data.indexOf(e)&&(t.data=r?e+t.data:t.data+e)})(o[p],t,c),p},i=(e,t,r)=>e.reduce((e,l,a)=>{let o=t[a];if(o&&o.call){let e=o(r),t=e&&e.props&&e.props.className||/^go/.test(e)&&e;o=t?\".\"+t:e&&\"object\"==typeof e?e.props?\"\":n(e,\"\"):!1===e?\"\":e}return e+l+(null==o?\"\":o)},\"\");function u(e){let r=this||{},l=e.call?e(r.p):e;return c(l.unshift?l.raw?i(l,[].slice.call(arguments,1),r.p):l.reduce((e,t)=>Object.assign(e,t&&t.call?t(r.p):t),{}):l,t(r.target),r.g,r.o,r.k)}let p,d,f,g=u.bind({g:1}),b=u.bind({k:1});function h(e,t,r,l){n.p=t,p=e,d=r,f=l}function m(e,t){let r=this||{};return function(){let l=arguments;function a(n,o){let s=Object.assign({},n),c=s.className||a.className;r.p=Object.assign({theme:d&&d()},s),r.o=/ *go\\d+/.test(c),s.className=u.apply(r,l)+(c?\" \"+c:\"\"),t&&(s.ref=o);let i=e;return e[0]&&(i=s.as||e,delete s.as),f&&i[0]&&f(s),p(i,s)}return t?t(a):a}}export{u as css,r as extractCss,g as glob,b as keyframes,h as setup,m as styled};\n","let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nlet rootCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n        owner = Owner,\n        root = fn.length === 0 && !\"_SOLID_DEV_\" ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner || owner\n  };\n  if (owner) root.name = `${owner.name}-r${rootCount++}`;\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(() => fn(() => cleanNode(root)), true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  if (!options.internal) s.name = registerGraph(options.name || hashValue(value), s);\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE, options );\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE, options );\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE, options ),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : queueMicrotask(() => updateComputation(c));\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0, options ),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0, options );\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  options || (options = {});\n  if (options.globalRefetch !== false) {\n    Resources || (Resources = new Set());\n    Resources.add(load);\n    Owner && onCleanup(() => Resources.delete(load));\n  }\n  const contexts = new Set(),\n        [s, set] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      dynamic = typeof source === \"function\";\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.load) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, e, key) {\n    if (pr === p) {\n      pr = null;\n      if (initP && p === initP && options.onHydrated) options.onHydrated(key, {\n        value: v\n      });\n      initP = null;\n      setError(err = e);\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      set(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = s();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching && scheduled) return;\n    scheduled = false;\n    setError(err = undefined);\n    const lookup = dynamic ? source() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(s));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, {\n      value: s(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: set\n  }];\n}\nlet Resources;\nfunction refetchResources(info) {\n  return Resources && Promise.all([...Resources].map(fn => fn(info)));\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) !== (p !== undefined && fn(key, p))) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE, options );\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn,\noptions) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = [];\n      for (let i = 0; i < deps.length; i++) input.push(deps[i]());\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) console.warn(\"cleanups created outside a `createRoot` or `render` will never be run\");else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) console.warn(\"error handlers created outside a `createRoot` or `render` will never be run\");else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    batch(fn);\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction devComponent(Comp, props) {\n  const c = createComputation(() => untrack(() => {\n    Object.assign(Comp, {\n      [$DEVCOMP]: true\n    });\n    return Comp(props);\n  }), undefined, true);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.state = 0;\n  c.componentName = Comp.name;\n  updateComputation(c);\n  return c.tValue !== undefined ? c.tValue : c.value;\n}\nfunction hashValue(v) {\n  const s = new Set();\n  return `s${typeof v === \"string\" ? hash(v) : hash(JSON.stringify(v, (k, v) => {\n    if (typeof v === \"object\" && v != null) {\n      if (s.has(v)) return;\n      s.add(v);\n      const keys = Object.keys(v);\n      const desc = Object.getOwnPropertyDescriptors(v);\n      const newDesc = keys.reduce((memo, key) => {\n        const value = desc[key];\n        if (!value.get) memo[key] = value;\n        return memo;\n      }, {});\n      v = Object.create({}, newDesc);\n    }\n    if (typeof v === \"bigint\") {\n      return `${v.toString()}n`;\n    }\n    return v;\n  }) || \"\")}`;\n}\nfunction registerGraph(name, value) {\n  let tryName = name;\n  if (Owner) {\n    let i = 0;\n    Owner.sourceMap || (Owner.sourceMap = {});\n    while (Owner.sourceMap[tryName]) tryName = `${name}-${++i}`;\n    Owner.sourceMap[tryName] = value;\n  }\n  return tryName;\n}\nfunction serializeGraph(owner) {\n  owner || (owner = Owner);\n  if (!owner) return {};\n  return { ...serializeValues(owner.sourceMap),\n    ...(owner.owned ? serializeChildren(owner) : {})\n  };\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookDownstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  let TransitionRunning = false;\n  if (Transition) {\n    TransitionRunning = Transition.running;\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n          if (o.pure) Updates.push(o);else Effects.push(o);\n          if (o.observers) markUpstream(o);\n        }\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (\"_SOLID_DEV_\") throw new Error(\"Potential Infinite Loop Detected.\");\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) console.warn(\"computations created outside a `createRoot` or `render` will never be disposed\");else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n    c.name = options && options.name || `${Owner.name || \"c\"}-${(Owner.owned || Owner.tOwned).length}`;\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0) return;\n  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) return lookDownstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookDownstream(node, ancestors[0]);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    return fn();\n  } catch (err) {\n    handleError(err);\n  } finally {\n    completeUpdates(wait);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    res = Transition.resolve;\n    Effects.forEach(e => {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    });\n    Transition = null;\n    batch(() => {\n      sources.forEach(v => {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      });\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n    globalThis._$afterUpdate && globalThis._$afterUpdate();\n  }\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookDownstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookDownstream(source, ignore);\n    }\n  }\n}\nfunction markUpstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markUpstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  fns.forEach(f => f(err));\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\nfunction hash(s) {\n  for (var i = 0, h = 9; i < s.length;) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  return `${h ^ h >>> 9}`;\n}\nfunction serializeValues(sources = {}) {\n  const k = Object.keys(sources);\n  const result = {};\n  for (let i = 0; i < k.length; i++) {\n    const key = k[i];\n    result[key] = sources[key].value;\n  }\n  return result;\n}\nfunction serializeChildren(root) {\n  const result = {};\n  for (let i = 0, len = root.owned.length; i < len; i++) {\n    const node = root.owned[i];\n    result[node.componentName ? `${node.componentName}:${node.name}` : node.name] = { ...serializeValues(node.sourceMap),\n      ...(node.owned ? serializeChildren(node) : {})\n    };\n  }\n  return result;\n}\n\nfunction getSymbol() {\n  const SymbolCopy = Symbol;\n  return SymbolCopy.observable || \"@@observable\";\n}\nfunction observable(input) {\n  const $$observable = getSymbol();\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = \"next\" in observer ? observer.next.bind(observer) : observer;\n      let complete = false;\n      createComputed(() => {\n        if (complete) return;\n        const v = input();\n        untrack(() => handler(v));\n      });\n      return {\n        unsubscribe() {\n          complete = true;\n        }\n      };\n    },\n    [$$observable]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = devComponent(Comp, props) ;\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return devComponent(Comp, props);\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return typeof s === \"function\" ? s() : s;\n}\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default), {\n        globalRefetch: false\n      });\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      Object.assign(Comp, {\n        [$DEVCOMP]: true\n      });\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn());\n}\nfunction ErrorBoundary(props) {\n  let err = undefined;\n  if (sharedConfig.context && sharedConfig.load) {\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count);\n  }\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  let e;\n  return createMemo(() => {\n    if ((e = errored()) != null) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(null))) : f;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let index = 0,\n      suspenseSetter,\n      showContent,\n      showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const registry = [],\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        registry[index++] = {\n          inFallback,\n          showContent,\n          showFallback\n        };\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = registry.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      registry.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = registry.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = registry[n].inFallback();\n      if (!stop && !s) {\n        registry[n].showContent(visibleContent);\n        registry[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          registry[n].showFallback(visibleFallback);\n        } else registry[n].showFallback(false);\n        stop = true;\n        registry[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  if (sharedConfig.context) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    p = sharedConfig.load(key);\n    if (p) {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if (error = err) return set();\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === undefined) setHydrateContext();\n        const rendered = untrack(() => props.children);\n        return createMemo(() => {\n          const inFallback = store.inFallback(),\n                visibleContent = showContent ? showContent() : true,\n                visibleFallback = showFallback ? showFallback() : true;\n          dispose && dispose();\n          if ((!inFallback || p !== undefined) && visibleContent) {\n            store.resolved = true;\n            ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered;\n          }\n          if (!visibleFallback) return;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nlet DEV;\n{\n  DEV = {\n    writeSignal,\n    serializeGraph,\n    registerGraph,\n    hashValue\n  };\n}\nif (globalThis) {\n  if (!globalThis.Solid$$) globalThis.Solid$$ = true;else console.warn(\"You appear to have multiple instances of Solid. This can lead to unexpected behavior.\");\n}\n\nexport { $DEVCOMP, $PROXY, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, refetchResources, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","import { createMemo, createRoot, createRenderEffect, sharedConfig, enableHydration, createSignal, onCleanup, splitProps, $DEVCOMP, untrack } from 'solid-js';\nexport { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, createComponent, createRenderEffect as effect, getOwner, mergeProps } from 'solid-js';\n\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = new Set([\"className\", \"value\", \"readOnly\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = {\n  className: \"class\",\n  htmlFor: \"for\"\n};\nconst PropAliases = {\n  class: \"className\",\n  formnovalidate: \"formNoValidate\",\n  ismap: \"isMap\",\n  nomodule: \"noModule\",\n  playsinline: \"playsInline\",\n  readonly: \"readOnly\"\n};\nconst DelegatedEvents = new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = new Set([\n\"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animate\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"circle\", \"clipPath\", \"color-profile\", \"cursor\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"font\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-src\", \"font-face-uri\", \"foreignObject\", \"g\", \"glyph\", \"glyphRef\", \"hkern\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"missing-glyph\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\",\n\"set\", \"stop\",\n\"svg\", \"switch\", \"symbol\", \"text\", \"textPath\",\n\"tref\", \"tspan\", \"use\", \"view\", \"vkern\"]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\n\nfunction memo(fn, equals) {\n  return createMemo(fn, undefined, !equals ? {\n    equals\n  } : undefined);\n}\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n      aEnd = a.length,\n      bEnd = bLength,\n      aStart = 0,\n      bStart = 0,\n      after = a[aEnd - 1].nextSibling,\n      map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n              sequence = 1,\n              t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : undefined, init);\n  });\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, check, isSVG) {\n  const t = document.createElement(\"template\");\n  t.innerHTML = html;\n  if (check && t.innerHTML.split(\"<\").length - 1 !== check) throw `The browser resolved template HTML does not match JSX input:\\n${t.innerHTML}\\n\\n${html}. Is your HTML properly formed?`;\n  let node = t.content.firstChild;\n  if (isSVG) node = node.firstChild;\n  return node;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);else node.setAttributeNS(namespace, name, value);\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    node.addEventListener(name, e => handler[0](handler[1], e));\n  } else node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n        prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n          classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev = {}) {\n  const nodeStyle = node.style;\n  if (value == null || typeof value === \"string\") return nodeStyle.cssText = value;\n  typeof prev === \"string\" && (prev = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, accessor, isSVG, skipChildren) {\n  if (typeof accessor === \"function\") {\n    createRenderEffect(current => spreadExpression(node, accessor(), current, isSVG, skipChildren));\n  } else spreadExpression(node, accessor, undefined, isSVG, skipChildren);\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}) {\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      assignProp(node, prop, null, prevProps[prop], isSVG);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = globalThis._$HY.load;\n  sharedConfig.gather = root => gatherHydratable(element, root);\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  gatherHydratable(element, options.renderId);\n  const dispose = render(code, element, [...element.childNodes]);\n  sharedConfig.context = null;\n  return dispose;\n}\nfunction getNextElement(template) {\n  let node, key;\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {\n    return template.cloneNode(true);\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n      count = 0,\n      current = [];\n  if (sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"#\") count++;else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const {\n        completed,\n        events\n      } = sharedConfig;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG) {\n  let isCE, isProp, isChildProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    node.addEventListener(prop.slice(3), value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    node.addEventListener(prop.slice(10), value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    addEventListener(node, name, value, delegate);\n    delegate && delegateEvents([name]);\n  } else if ((isChildProp = ChildProperties.has(prop)) || !isSVG && (PropAliases[prop] || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\"))) {\n    if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;else node[PropAliases[prop] || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = e.composedPath && e.composedPath()[0] || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  while (node !== null) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler(data, e) : handler(e);\n      if (e.cancelBubble) return;\n    }\n    node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;\n  }\n}\nfunction spreadExpression(node, props, prevProps = {}, isSVG, skipChildren) {\n  if (!skipChildren && \"children\" in props) {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps));\n  return prevProps;\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  if (sharedConfig.context && !current) current = [...parent.childNodes];\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n        multi = marker !== undefined;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (sharedConfig.context) return current;\n    if (t === \"number\") value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (sharedConfig.context) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    if (normalizeIncomingArray(array, value, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (sharedConfig.context) {\n      for (let i = 0; i < array.length; i++) {\n        if (array[i].parentNode) return current = array;\n      }\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (Array.isArray(current)) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value instanceof Node) {\n    if (sharedConfig.context && value.parentNode) return current = multi ? [value] : value;\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else console.warn(`Unrecognized value. Skipped inserting`, value);\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n        t;\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item) || dynamic;\n    } else if ((t = typeof item) === \"string\") {\n      normalized.push(document.createTextNode(item));\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else normalized.push(document.createTextNode(item.toString()));\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if (!root || key.startsWith(root)) sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nfunction Assets() {\n  return;\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\nfunction ssr(template, ...nodes) {}\nfunction resolveSSRNode(node) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrSpread(accessor) {}\nfunction ssrBoolean(key, value) {}\nfunction ssrHydrationKey() {}\nfunction escape(html) {}\nfunction generateHydrationScript() {}\n\nconst isServer = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props,\n        marker = document.createTextNode(\"\"),\n        mount = props.mount || document.body;\n  function renderPortal() {\n    if (sharedConfig.context) {\n      const [s, set] = createSignal(false);\n      queueMicrotask(() => set(true));\n      return () => s() && props.children;\n    } else return () => props.children;\n  }\n  if (mount instanceof HTMLHeadElement) {\n    const [clean, setClean] = createSignal(false);\n    const cleanup = () => setClean(true);\n    createRoot(dispose => insert(mount, () => !clean() ? renderPortal()() : dispose(), null));\n    onCleanup(() => {\n      if (sharedConfig.context) queueMicrotask(cleanup);else cleanup();\n    });\n  } else {\n    const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n      mode: \"open\"\n    }) : container;\n    Object.defineProperty(container, \"host\", {\n      get() {\n        return marker.parentNode;\n      }\n    });\n    insert(renderRoot, renderPortal());\n    mount.appendChild(container);\n    props.ref && props.ref(container);\n    onCleanup(() => mount.removeChild(container));\n  }\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  return createMemo(() => {\n    const component = p.component;\n    switch (typeof component) {\n      case \"function\":\n        Object.assign(component, {\n          [$DEVCOMP]: true\n        });\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport { Aliases, Assets, ChildProperties, DelegatedEvents, Dynamic, Assets as HydrationScript, NoHydration, Portal, PropAliases, Properties, SVGElements, SVGNamespace, addEventListener, assign, classList, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, generateHydrationScript, getHydrationKey, getNextElement, getNextMarker, getNextMatch, hydrate, innerHTML, insert, isServer, memo, render, renderToStream, renderToString, renderToStringAsync, resolveSSRNode, runHydrationEvents, setAttribute, setAttributeNS, spread, ssr, ssrBoolean, ssrClassList, ssrHydrationKey, ssrSpread, ssrStyle, style, template };\n","import { css, setup as gooberSetup } from \"goober\";\r\nimport {\r\n  mergeProps,\r\n  splitProps,\r\n  createContext,\r\n  useContext,\r\n  createComponent,\r\n  untrack\r\n} from \"solid-js\";\r\nimport { spread, ssr, ssrSpread, isServer } from \"solid-js/web\";\r\nexport { css, glob, extractCss, keyframes } from \"goober\";\r\nexport function setup(prefixer) {\r\n  gooberSetup(null, prefixer);\r\n}\r\nconst ThemeContext = createContext();\r\nexport function ThemeProvider(props) {\r\n  return createComponent(ThemeContext.Provider, {\r\n    value: props.theme,\r\n    get children() {\r\n      return props.children;\r\n    }\r\n  });\r\n}\r\nexport function useTheme() {\r\n  return useContext(ThemeContext);\r\n}\r\n\r\nfunction makeStyled(tag) {\r\n  let _ctx = this || {};\r\n  return (...args) => {\r\n    const Styled = props => {\r\n      const theme = useContext(ThemeContext);\r\n      const withTheme = mergeProps(props, { theme });\r\n      const clone = mergeProps(withTheme, {\r\n        get className() {\r\n          const pClassName = withTheme.className,\r\n            append = \"className\" in withTheme && /^go[0-9]+/.test(pClassName);\r\n          // Call `css` with the append flag and pass the props\r\n          let className = css.apply(\r\n            { target: _ctx.target, o: append, p: withTheme, g: _ctx.g },\r\n            args\r\n          );\r\n          return [pClassName, className].filter(Boolean).join(\" \");\r\n        }\r\n      });\r\n      const [local, newProps] = splitProps(clone, [\"as\"]);\r\n      const createTag = local.as || tag;\r\n      let el;\r\n      if (typeof createTag === \"function\") {\r\n        el = createTag(newProps);\r\n      } else if (isServer) {\r\n        const [local, others] = splitProps(newProps, [\"children\"]);\r\n        el = ssr(\r\n          [`<${createTag} `, \">\", `</${createTag}>`],\r\n          ssrSpread(others),\r\n          local.children || \"\"\r\n        );\r\n      } else {\r\n        el = document.createElement(createTag);\r\n        spread(el, newProps);\r\n      }\r\n      return el;\r\n    };\r\n    Styled.className = props => {\r\n      return untrack(() => {\r\n        return css.apply({ target: _ctx.target, p: props, g: _ctx.g }, args);\r\n      });\r\n    };\r\n    return Styled;\r\n  };\r\n}\r\n\r\nexport const styled = new Proxy(makeStyled, {\r\n  get(target, tag) {\r\n    return target(tag);\r\n  },\r\n})\r\n\r\nexport function createGlobalStyles() {\r\n  const fn = makeStyled.call({ g: 1 }, \"div\").apply(null, arguments);\r\n  return function GlobalStyles(props) {\r\n    fn(props);\r\n    return null;\r\n  };\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","import { Application } from \"./ui/application/Application\";\nimport { ThemeProvider } from \"solid-styled-components\";\nimport { theme } from \"./ui/theme\";\nimport { render } from \"solid-js/web\";\n\ndocument.addEventListener(\"readystatechange\", (e) => {\n  if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n    render(\n      () => (\n        <ThemeProvider theme={theme}>\n          <Application />\n        </ThemeProvider>\n      ),\n      document.querySelector(\"#application\") as HTMLDivElement\n    );\n  }\n});\n"],"names":["Commands","GPUCommands","GroupType","PipelineType","ResourceType","vaos","buffers","wasmExports","bindExports","exports","createBindingsGPU","importObject","gameManager","env","memory","Error","binding","print","stringIndex","console","log","__getString","createBufferFromF32","data","usage","buffer","__getFloat32Array","createBufferF32","createIndexBuffer","__getUint32Array","render","commandsIndex","commandBuffer","__getArray","renderQueueManager","run","Imports","InputManager","DebugPipeline","createBuffer","RenderQueueManager","Texture","meshPipelineInstances","sampleCount","GameManager","constructor","canvas","textures","samplers","disposed","currentPass","onFrameHandler","onFrame","bind","init","wasmManager","hasGPU","hasWebGPU","inputManager","adapter","navigator","gpu","requestAdapter","device","requestDevice","context","getContext","format","getPreferredFormat","configure","size","canvasSize","compositingAlphaMode","createSampler","minFilter","magFilter","texturePaths","name","path","Promise","all","map","tp","index","texture","TextureFactory","createTexture","__newString","load","pipelines","diffuseMap","NUM_DIR_LIGHTS","onResize","AsSceneManager","width","height","initRuntime","window","addEventListener","onResizeHandler","requestAnimationFrame","getTexture","find","t","wasm","runime","Runtime","wrap","getRuntime","forEach","p","build","initialize","containerLvl1Ptr","__pin","createLevel1","containerLvl1","Level1","addAsset","createMesh","__unpin","containerMainMenuPtr","createMainMenu","containerMainMenu","MainMenu","addContainer","type","pipelineName","debugPipeline","getPipeline","pipelineIndex","indexOf","pipelineInsPtr","PipelineFactory","createPipeline","Mesh","meshPipelineIns","MeshPipeline","push","transformGroupId","getTemplateByType","Transform","template","group","transformResourceIndex","addResourceInstance","geometryPtr","GeometryFactory","createBox","createSphere","meshPtr","dispose","removeEventListener","newSize","updateWasm","renderTarget","destroy","depthTexture","presentationSize","GPUTextureUsage","RENDER_ATTACHMENT","renderTargetView","createView","resize","w","h","update","performance","now","devicePixelRatio","clientWidth","clientHeight","startPass","commandEncoder","createCommandEncoder","renderPass","beginRenderPass","colorAttachments","view","resolveTarget","getCurrentTexture","clearValue","r","g","b","a","storeOp","loadOp","depthStencilAttachment","depthLoadOp","depthStoreOp","depthClearValue","currentCommandEncoder","endPass","end","queue","submit","finish","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","length","INDEX","MouseEventType","KeyEventType","canvasBounds","getBoundingClientRect","onDownHandler","onDown","onUpHandler","onUp","onKeyDownHandler","onKeyDown","onKeyUpHandler","onKeyUp","onMoveHandler","onMove","onWheelHandler","onWheel","document","reset","e","sendMouseEvent","MouseUp","MouseMove","preventDefault","MouseDown","sendKeyEvent","KeyDown","KeyUp","MouseWheel","deltaY","createMouseEvent","bounds","delta","mouseEventPtr","ASInputManager","clientX","clientY","pageX","pageY","ctrlKey","shiftKey","altKey","button","buttons","x","y","event","manager","getInputManager","wasmEvent","onMouseUp","onMouseMove","onMouseDown","createKeyboardEvent","code","LightingResource","ARRAYBUFFERVIEW_DATASTART_OFFSET","normalAs4x4","Float32Array","wasmArrayBuffer","wasmMemoryBlock","getPtrIndex","ptr","pipeline","instances","resourceIndex","pass","i","l","command","SETUP_LIGHTING","numDirectionLights","numDirLights","rebuildDirectionLights","Material","defines","lightingConfig","info","writeBuffer","sceneLightingBuffer","ambientLights","directionLightsBuffer","dirLights","SET_TRANSFORM","groupInstances","get","projMatrixPtr","mvMatrixPtr","normMatrixPtr","mat3x3","transformBuffer","SET_INDEX_BUFFER","setIndexBuffer","SET_BUFFER","slot","setVertexBuffer","DRAW_INDEXED","indexCount","drawIndexed","SET_PIPELINE","newPipeline","rebuild","setPipeline","renderPipeline","SET_BIND_GROUP","instance","setBindGroup","bindGroup","START_PASS","END_PASS","gpuTexture","img","createElement","src","decode","imageData","createImageBitmap","TEXTURE_BINDING","copyExternalImageToTexture","source","byteLength","mappedAtCreation","getMappedRange","set","unmap","Uint32Array","wasmFile","loader","WasmManager","WebAssembly","Memory","initial","seed","Date","abort","error","getString","string_index","U32","id_addr","id","len","str","TextDecoder","slice","obj","instantiateStreaming","fetch","wasmDataView","DataView","defaultPipelineDescriptor","primitive","topology","cullMode","frontFace","depthStencil","depthWriteEnabled","depthCompare","multisample","count","PipelineResourceInstance","GroupMapping","bindingCount","getBinding","toRet","Pipeline","vertexSource","fragmentSource","resourceTemplates","Map","groupMapping","groups","_defines","groupIndex","has","bindingIndex","resourceType","getTemplateByGroup","groupType","addTemplate","groupInstanceMap","templates","resourceInstances","splice","clear","onAddResources","curBinding","binds","resourceTemplate","bindings","prevGroupKeys","Array","from","keys","uniqueNewGroupKeys","filter","value","self","groupCache","key","includes","delete","newKey","numInstancesToCreate","bindData","numInstances","getBindingData","cache","entries","reduce","accumulator","cur","createBindGroup","label","layout","getBindGroupLayout","bindingData","instanceArray","MaterialResource","TextureResource","TransformResource","mathConstants","mathFunctions","shader","shaderBuilder","vertexShader","vertexBlock","fragmentShader","Lighting","fragmentBlock","normalMap","metalnessMap","roughnessMap","transformResource","materialResource","lightingResource","resource","vertSource","fragSource","createRenderPipeline","vertex","module","createShaderModule","entryPoint","arrayStride","BYTES_PER_ELEMENT","attributes","shaderLocation","offset","fragment","targets","UNIFORM_TYPES_MAP","PipelineResourceTemplate","curBindIndex","lightingConfigBinding","sceneLightingBinding","directionLightBinding","LIGHTING_CONFIG_SIZE","SCENE_LIGHTING_BUFFER","UNIFORM","lightInofoDefaults","sceneLightingBufferDefaults","STORAGE","concat","initialValues","SIZE","f32","i32","Int32Array","u32","i16","Int16Array","u16","Uint16Array","groupSubType","samplerBind","textureBind","SIZEOF_MATRICES","strings","expr","expressions","sourceFragments","string","fnOrText","expressionReturn","toString","createSignal","onMount","styled","Button","Modal","Pane3D","Typography","Application","modalOpen","setModalOpen","onCanvasReady","message","querySelector","err","style","display","innerHTML","onStart","StyledApplication","div","StyledButtons","props","fullWidth","disabled","onClick","class","variant","color","children","StyledButton","Portal","handleClick","target","classList","contains","onClose","handleCancel","onCancel","handleOk","onOk","open","title","hideConfirmButtons","StyledWrapper","visible","StyledModal","onCleanup","parent","onResizeDelegate","firstElementChild","StyledCanvas","textAlign","align","StyledTypography","theme","colors","primary","ThemeProvider","readyState"],"sourceRoot":""}