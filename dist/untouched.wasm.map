{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","src/as/core/Event.ts","~lib/rt.ts","~lib/util/error.ts","~lib/memory.ts","~lib/util/memory.ts","src/as/exports/io/InputManager.ts","~lib/arraybuffer.ts","~lib/util/hash.ts","~lib/map.ts","src/as/core/EventDispatcher.ts","src/common/GPUEnums.ts","src/as/exports/ui/uiSignalManager.ts","src/as/math/MathUtils.ts","~lib/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/util/number.ts","~lib/util/sort.ts","~lib/string.ts","~lib/array.ts","~lib/math.ts","src/as/math/Color.ts","src/common/GLEnums.ts","src/as/math/Vector3.ts","src/as/core/BufferAttribute.ts","src/as/math/Vector2.ts","src/as/math/Quaternion.ts","src/as/math/Line.ts","src/as/math/Plane.ts","src/as/math/Matrix3.ts","src/as/utils.ts","~lib/typedarray.ts","src/as/math/Box3.ts","src/as/math/Sphere.ts","src/as/math/Triangle.ts","src/as/core/BufferGeometry.ts","src/as/math/Matrix4.ts","src/as/core/Object.ts","src/as/math/Euler.ts","~lib/util/casemap.ts","~lib/staticarray.ts","src/as/core/Layers.ts","~lib/symbol.ts","src/as/pipelines/Pipeline.ts","src/as/materials/Material.ts","src/as/textures/Texture.ts","src/as/objects/Mesh.ts","src/as/math/Ray.ts","src/as/core/InterleavedBufferAttribute.ts","src/as/objects/Sprite.ts","src/as/math/Frustum.ts","src/as/lights/LightShadow.ts","src/as/renderers/WebGPULights.ts","src/as/renderers/WebGPURenderQueue.ts","src/as/renderers/WebGPURenderer.ts","src/as/objects/routing/core/Container.ts","src/as/exports/AsSceneManager.ts","src/as/renderers/WebGPUGeometries.ts","src/as/core/RenderLoop.ts","src/as/objects/routing/core/Runtime.ts","src/as/objects/routing/core/Node.ts","src/as/cameras/Camera.ts","src/as/exports/TextureFactory.ts","src/as/exports/PipelineFactory.ts","src/as/extras/OrbitController.ts","src/as/objects/routing/custom/Level1.ts","src/as/index.ts","~lib/builtins.ts","src/as/exports/io/MouseEvent.ts","src/as/exports/io/KeyboardEvent.ts","src/as/exports/ui/UIEvent.ts","src/as/math/Vector4.ts","src/as/scenes/Scene.ts","src/as/cameras/PerspectiveCamera.ts","src/as/geometries/BoxGeometry.ts","src/as/exports/GeometryFactory.ts","src/as/geometries/PlaneGeometry.ts","src/as/geometries/SphereGeometry.ts","src/as/pipelines/MeshPipeline.ts","src/as/exports/MeshFactory.ts","src/as/core/BridgeManager.ts","src/as/objects/routing/core/Portal.ts","src/as/objects/routing/core/Link.ts","src/as/lights/Light.ts","src/as/lights/DirectionalLight.ts","src/as/cameras/OrthographicCamera.ts","src/as/lights/DirectionalLightShadow.ts","src/as/lights/AmbientLight.ts","src/as/math/Spherical.ts","src/as/objects/routing/custom/MainMenu.ts","src/as/scenes/Fog.ts","src/as/cameras/ViewProperties.ts","~lib/function.ts"],"names":[],"mappings":"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","sourceRoot":"./untouched.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - 2 * BLOCK_OVERHEAD;\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  var root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  var memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n  var blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  var newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy var white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy var total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy var state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var iter: Object; // null\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    var rtId = this.rtId;\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    var next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    var prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  var pn = pinSpace;\n  var iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  var ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  var obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  var ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  var newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  var child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy var threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  var budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\"└ GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\"└ GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","import { EventTargetable } from \"./EventTargetable\";\nimport { EventAttachable } from \"./EventAttachable\";\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Joe Pea / http://github.com/trusktr\n * @author corruptedzulu / http://github.com/corruptedzulu\n */\n\nexport class Event {\n  type: string;\n  target: EventTargetable;\n  attachment: EventAttachable;\n\n  constructor(\n    type: string,\n    target: EventTargetable = new EventTargetable(),\n    attachment: EventAttachable = new EventAttachable()\n  ) {\n    this.type = type;\n    this.target = target;\n    this.attachment = attachment;\n  }\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { OBJECT, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ptr: usize, classId: u32): bool { // keyword\n  var id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;\n  var rttiBase = __rtti_base;\n  if (id <= load<u32>(rttiBase)) {\n    do if (id == classId) return true;\n    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  var buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  var buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  var array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare var __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n;\n    store<u8>(dest, c);\n    store<u8>(dend - 1, c);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend - 2, c);\n    store<u8>(dend - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n;\n    store<u32>(dest, c32);\n    store<u32>(dend - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend - 12, c32);\n    store<u32>(dend - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend - 28, c32);\n    store<u32>(dend - 24, c32);\n    store<u32>(dend - 20, c32);\n    store<u32>(dend - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","import { Event } from \"../../core/Event\";\nimport { MouseEvent } from \"./MouseEvent\";\nimport { EventDispatcher } from \"../../core/EventDispatcher\";\nimport { KeyboardEvent } from \"./KeyboardEvent\";\n\nconst moveEventDown: Event = new Event(\"mousedown\");\nconst moveEventUp: Event = new Event(\"mouseup\");\nconst moveEventMove: Event = new Event(\"mousemove\");\nconst moveEventWheel: Event = new Event(\"wheel\");\nconst keyDownEvent: Event = new Event(\"keydown\");\nconst keyUpEvent: Event = new Event(\"keyup\");\n\nexport class InputManager extends EventDispatcher {\n  onWheel(event: MouseEvent): void {\n    moveEventWheel.target = this;\n    moveEventWheel.attachment = event;\n    this.dispatchEvent(moveEventWheel);\n  }\n\n  onMouseDown(event: MouseEvent): void {\n    moveEventDown.target = this;\n    moveEventDown.attachment = event;\n    this.dispatchEvent(moveEventDown);\n  }\n\n  onMouseUp(event: MouseEvent): void {\n    moveEventUp.target = this;\n    moveEventUp.attachment = event;\n    this.dispatchEvent(moveEventUp);\n  }\n\n  onMouseMove(event: MouseEvent): void {\n    moveEventMove.target = this;\n    moveEventMove.attachment = event;\n    this.dispatchEvent(moveEventMove);\n  }\n\n  onKeyDown(event: KeyboardEvent): void {\n    keyDownEvent.target = this;\n    keyDownEvent.attachment = event;\n    this.dispatchEvent(keyDownEvent);\n  }\n\n  onKeyUp(event: KeyboardEvent): void {\n    keyUpEvent.target = this;\n    keyUpEvent.attachment = event;\n    this.dispatchEvent(keyUpEvent);\n  }\n}\n\nexport function getInputManager(): InputManager {\n  return inputManager;\n}\n\nexport const inputManager = new InputManager();\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (value === null) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (key === null) return XXH32_SEED;\n\n  var h: u32 = key.length << 1;\n  var len: usize = h;\n  var pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  var end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) !== null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var keys = new Array<K>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        keys[length++] = entry.key;\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<V>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.value;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","/**\n * @author mrdoob / http://mrdoob.com/\n * @author Joe Pea / http://github.com/trusktr\n * @author corruptedzulu / http://github.com/corruptedzulu\n */\n\nimport { Event } from \"./Event\";\nimport { EventTargetable } from \"./EventTargetable\";\n\nexport interface Listener {\n  onEvent(event: Event): void;\n}\n\nexport type ListenerArray = Array<Listener>;\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\nexport class EventDispatcher extends EventTargetable {\n  private _listeners: Map<string, ListenerArray> = new Map();\n\n  /**\n   * Adds a listener to an event type.\n   * @param type The type of event to listen to.\n   * @param listener The function that gets called when the event is fired.\n   */\n  addEventListener(type: string, listener: Listener): void {\n    const listeners = this._listeners;\n\n    if (!listeners.has(type)) {\n      listeners.set(type, new Array<Listener>());\n    }\n\n    if (listeners.get(type).indexOf(listener) === -1) {\n      listeners.get(type).push(listener);\n    }\n  }\n\n  /**\n   * Checks if listener is added to an event type.\n   * @param type The type of event to listen to.\n   * @param listener The function that gets called when the event is fired.\n   */\n  hasEventListener(type: string, listener: Listener): bool {\n    const listeners = this._listeners;\n\n    return listeners.has(type) && listeners.get(type).includes(listener);\n  }\n\n  /**\n   * Removes a listener from an event type.\n   * @param type The type of the listener that gets removed.\n   * @param listener The listener function that gets removed.\n   */\n  removeEventListener(type: string, listener: Listener): void {\n    const listeners = this._listeners;\n\n    if (listeners.has(type)) {\n      const listenerArray = listeners.get(type);\n      const index = listenerArray.indexOf(listener);\n\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Fire an event type.\n   * @param type The type of event that gets fired.\n   */\n  dispatchEvent(event: Event): void {\n    const listeners = this._listeners;\n\n    if (listeners.has(event.type)) {\n      const listenerArray = listeners.get(event.type);\n\n      event.target = this;\n\n      // clone the array, in case listeners are added or removed during the\n      // following iteration\n      const array: Listener[] = listenerArray.slice(0);\n\n      for (let i: i32 = 0, l: i32 = array.length; i < l; i++) {\n        let theListener: Listener = array[i];\n        // theListener(event) // no type error here. Why?????\n        theListener.onEvent(event);\n      }\n    }\n  }\n}\n","export enum GPUBufferUsageFlags {\n  MAP_READ = 0x0001,\n  MAP_WRITE = 0x0002,\n  COPY_SRC = 0x0004,\n  COPY_DST = 0x0008,\n  INDEX = 0x0010,\n  VERTEX = 0x0020,\n  UNIFORM = 0x0040,\n  STORAGE = 0x0080,\n  INDIRECT = 0x0100,\n  QUERY_RESOLVE = 0x0200,\n}\n\n// side\nexport enum Side {\n  FrontSide,\n  BackSide,\n  DoubleSide,\n}\n","import { Event } from \"../../core/Event\";\nimport { UIEvent } from \"./UIEvent\";\nimport { UIEventType } from \"../../../common/UIEventType\";\nimport { EventDispatcher } from \"../../core/EventDispatcher\";\nimport { onSignalReceived } from \"../../Imports\";\n\nconst uiEvent: Event = new Event(\"uievent\");\n\nexport class UISignalManager extends EventDispatcher {\n  onSignalEvent(eventType: UIEventType): void {\n    uiEvent.target = this;\n    uiEvent.attachment = new UIEvent(eventType);\n    this.dispatchEvent(uiEvent);\n  }\n\n  signalClientEvent(eventType: UIEventType): void {\n    uiEvent.target = this;\n    uiEvent.attachment = new UIEvent(eventType);\n    onSignalReceived(eventType, uiEvent);\n  }\n}\n\nexport function getSignalManager(): UISignalManager {\n  return uiSignaller;\n}\n\nexport const uiSignaller = new UISignalManager();\n","import { Quaternion } from \"./Quaternion\";\n\nconst _lut: string[] = [];\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? \"0\" : \"\") + i.toString(16);\n}\n\nlet _seed = 1234567;\n\nexport const DEG2RAD: f32 = Mathf.PI / 180;\nexport const RAD2DEG: f32 = 180 / Mathf.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nexport function generateUUID(): string {\n  const d0: u32 = u32(Mathf.random() * 0xffffffff) | 0;\n  const d1: u32 = u32(Mathf.random() * 0xffffffff) | 0;\n  const d2: u32 = u32(Mathf.random() * 0xffffffff) | 0;\n  const d3: u32 = u32(Mathf.random() * 0xffffffff) | 0;\n\n  const uuid: string =\n    _lut[d0 & 0xff] +\n    _lut[(d0 >> 8) & 0xff] +\n    _lut[(d0 >> 16) & 0xff] +\n    _lut[(d0 >> 24) & 0xff] +\n    \"-\" +\n    _lut[d1 & 0xff] +\n    _lut[(d1 >> 8) & 0xff] +\n    \"-\" +\n    _lut[((d1 >> 16) & 0x0f) | 0x40] +\n    _lut[(d1 >> 24) & 0xff] +\n    \"-\" +\n    _lut[(d2 & 0x3f) | 0x80] +\n    _lut[(d2 >> 8) & 0xff] +\n    \"-\" +\n    _lut[(d2 >> 16) & 0xff] +\n    _lut[(d2 >> 24) & 0xff] +\n    _lut[d3 & 0xff] +\n    _lut[(d3 >> 8) & 0xff] +\n    _lut[(d3 >> 16) & 0xff] +\n    _lut[(d3 >> 24) & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase();\n}\n\nexport function clamp(value: f32, min: f32, max: f32): f32 {\n  return Mathf.max(min, Mathf.min(max, value));\n}\n\n// compute euclidian modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nexport function euclideanModulo(n: f32, m: f32): f32 {\n  return ((n % m) + m) % m;\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nexport function mapLinear(x: f32, a1: f32, a2: f32, b1: f32, b2: f32): f32 {\n  return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nexport function inverseLerp(x: f32, y: f32, value: f32): f32 {\n  if (x !== y) {\n    return (value - x) / (y - x);\n  } else {\n    return 0;\n  }\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nexport function lerp(x: f32, y: f32, t: f32): f32 {\n  return (1 - t) * x + t * y;\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nexport function damp(x: f32, y: f32, lambda: f32, dt: f32): f32 {\n  return lerp(x, y, 1 - Mathf.exp(-lambda * dt));\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nexport function pingpong(x: f32, length: f32 = 1): f32 {\n  return length - Mathf.abs(euclideanModulo(x, length * 2) - length);\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nexport function smoothstep(x: f32, min: f32, max: f32): f32 {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n\n  x = (x - min) / (max - min);\n\n  return x * x * (3 - 2 * x);\n}\n\nexport function smootherstep(x: f32, min: f32, max: f32): f32 {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n\n  x = (x - min) / (max - min);\n\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\n\n// Random integer from <low, high> interval\nexport function randInt(low: f32, high: f32): f32 {\n  return low + Mathf.floor(Mathf.random() * (high - low + 1));\n}\n\n// Random float from <low, high> interval\nexport function randFloat(low: f32, high: f32): f32 {\n  return low + Mathf.random() * (high - low);\n}\n\n// Random float from <-range/2, range/2> interval\nexport function randFloatSpread(range: f32): f32 {\n  return range * (0.5 - Mathf.random());\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nexport function seededRandom(s: f32): f32 {\n  if (s !== undefined) _seed = s % 2147483647;\n\n  // Park-Miller algorithm\n\n  _seed = (_seed * 16807) % 2147483647;\n\n  return (_seed - 1) / 2147483646;\n}\n\nexport function degToRad(degrees: f32): f32 {\n  return degrees * DEG2RAD;\n}\n\nexport function radToDeg(radians: f32): f32 {\n  return radians * RAD2DEG;\n}\n\nexport function isPowerOfTwo(value: f32): boolean {\n  return (value & (value - 1)) === 0 && value !== 0;\n}\n\nexport function ceilPowerOfTwo(value: f32): f32 {\n  return Mathf.pow(2, Mathf.ceil(Mathf.log(value) / Mathf.LN2));\n}\n\nexport function floorPowerOfTwo(value: f32): f32 {\n  return Mathf.pow(2, Mathf.floor(Mathf.log(value) / Mathf.LN2));\n}\n\nexport function setQuaternionFromProperEuler(q: Quaternion, a: f32, b: f32, c: f32, order: string): void {\n  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n  // rotations are applied to the axes in the order specified by 'order'\n  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n  // angles are in radians\n\n  const cos = Mathf.cos;\n  const sin = Mathf.sin;\n\n  const c2 = cos(b / 2);\n  const s2 = sin(b / 2);\n\n  const c13 = cos((a + c) / 2);\n  const s13 = sin((a + c) / 2);\n\n  const c1_3 = cos((a - c) / 2);\n  const s1_3 = sin((a - c) / 2);\n\n  const c3_1 = cos((c - a) / 2);\n  const s3_1 = sin((c - a) / 2);\n\n  switch (order) {\n    case \"XYX\":\n      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n      break;\n\n    case \"YZY\":\n      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n      break;\n\n    case \"ZXZ\":\n      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n      break;\n\n    case \"XZX\":\n      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n      break;\n\n    case \"YXY\":\n      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n      break;\n\n    case \"ZYZ\":\n      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n      break;\n\n    default:\n      console.warn(\"THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: \" + order);\n  }\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  var kd = xd + shift;\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  var z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  var kd = <f64>(z + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = z - (kd - shift);\n  var s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  var top  = tmp & 0xFF800000;\n  var iz   = ux - top;\n  var k    = <i32>tmp >> 23;\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y  = A1 * r + A2;\n  var p  = A3 * r + y0;\n  var r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ux - 0x3F330000;\n  var i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  var k   = <i32>tmp >> 23;\n  var iz  = ux - (tmp & 0x1FF << 23);\n\n  var invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  var z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  var r = z * invc - 1;\n  var y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  var r2 = r * r;\n  var y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  var e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = <usize>((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  var top  = tmp & 0xFF800000;\n  var uz   = ux - top;\n  var k    = <i32>(<i32>top >> 23);\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y = A0 * r + A1;\n  var p = A2 * r + A3;\n  var q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  var kd = <f64>(xd + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  var signBias: u32 = 0;\n  var ix = reinterpret<u32>(x);\n  var iy = reinterpret<u32>(y);\n  var ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return iy >> 31 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (ix >> 31) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  var logx = log2f_inline(ix);\n  var ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  var scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  var y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7FF);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      return select<f64>(0, Infinity, ux >> 63);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  var z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // var kd = z + shift;\n  // var ki = reinterpret<u64>(kd) >> 16;\n  // var kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  var kd = z + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  var r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  var scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  var y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7ff);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (!(ux >> 63)) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  var kd = x + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  var r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\n  //            invc                  ,                logc\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\n  //              chi                 ,                 clo\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  var top = <u32>(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & 0xFFF0000000000000);\n\n  var invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n  var kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  var chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  var clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  var r   = (z - chi - clo) * invc;\n  var rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  var rlo = r - rhi;\n  var t1  = rhi * InvLn2hi;\n  var t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  var t3 = kd + logc;\n  var hi = t3 + t1;\n  var lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  var p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\n  //              invc                ,                 logc\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\n  //               chi                ,                  clo\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  var top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  var invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  var r = (z - chi - clo) * invc;\n  // #endif\n  var kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  var w  = kd * Ln2hi + logc;\n  var hi = w + r;\n  var lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\n  //             invc                 ,pad,               logc                 ,               logctail\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  var e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy var log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ix - 0x3fE6955500000000;\n  var i   = <usize>((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  var k   = <i64>tmp >> 52;\n  var iz  = ix - (tmp & u64(0xFFF) << 52);\n  var z   = reinterpret<f64>(iz);\n  var kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  var invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  var logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  var logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  var zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  var zlo = z - zhi;\n  var rhi = zhi * invc - 1.0;\n  var rlo = zlo * invc;\n  var r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  var t1  = kd * Ln2hi + logc;\n  var t2  = t1 + r;\n  var lo1 = kd * Ln2lo + logctail;\n  var lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var ar  = A0 * r; // A[0] = -0.5\n  var ar2 = r * ar;\n  var ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  var arhi  = A0  * rhi;\n  var arhi2 = rhi * arhi;\n  var hi    = t2  + arhi2;\n  var lo3   = rlo * (ar + arhi);\n  var lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  var p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  var lo = lo1 + lo2 + lo3 + lo4 + p;\n  var y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var abstop: u32;\n  var ki: u64, top: u64, sbits: u64;\n  var idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  var kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  var ux = reinterpret<u64>(x);\n  abstop = <u32>(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return ux >> 63 ? uflow(sign_bias) : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = <usize>((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var sign_bias: u32 = 0;\n  var ix = reinterpret<u64>(x);\n  var iy = reinterpret<u64>(y);\n  var topx = ix >> 52;\n  var topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return iy >> 63 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (ix >> 63) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  var hi = log_inline(ix);\n  var lo = log_tail;\n  var ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  var yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  var ylo = y - yhi;\n  var lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  var llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa, itoa_buffered, dtoa_buffered, MAX_DOUBLE_LENGTH } from \"./number\";\nimport { ipow32 } from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    // @ts-ignore: cast\n    return ((c | 0x80) == 0xA0) | (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  var found = false;\n  var pos = index;\n  var minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  var maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  var c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  var sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (!num) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len(\"false\")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    // @ts-ignore: type\n    if (value !== null) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (value !== null) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (value !== null) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value !== null ? value.toString() : \"\";\n  }\n  var result = \"\";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value !== null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value !== null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy var __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  var b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  var base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = value >>> 31;\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = u32(value >>> 63);\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy var _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp, exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n\n  var p1 = u32(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var size = dtoa_core(dtoa_buf, value) << 1;\n  var result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  var sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      value = changetype<T>(-value);\n      store<u16>(buffer, CharCode.MINUS);\n    }\n  }\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  var decimals = sign;\n  if (sizeof<T>() <= 4) {\n    decimals += decimalCount32(value);\n    utoa32_dec_core(buffer, value, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals += decimalCount32(val32);\n      utoa32_dec_core(buffer, val32, decimals);\n    } else {\n      decimals += decimalCount64High(value);\n      utoa64_dec_core(buffer, value, decimals);\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        var ia = reinterpret<i32>(f32(a));\n        var ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        var ia = reinterpret<i64>(f64(a));\n        var ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (a === b || a === null || b === null) return 0;\n      var alen = changetype<string>(a).length;\n      var blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  var lgPlus2         = log2u(len) + 2;\n  var lgPlus2Size     = lgPlus2 << alignof<u32>();\n  var leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  var leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  var buffer = __alloc(len << alignof<T>());\n\n  var hi   = len - 1;\n  var endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  var lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  var top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  var n: u64 = right - left + 1;\n  var s = startB - (left << 1);\n  var l = startA + s;\n  var r = endB   + s + 1;\n  var a = (<u64>l << 30) / n;\n  var b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  var j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  var i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    var hasSur = surr > 0;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    var length = units.length;\n    var out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    var ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    var hasSur = <u32>code > 0xFFFF;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    var len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    var len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (left === right) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return false;\n    var rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (left === right) return false;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (other === this) return 0; // compare pointers\n    var len: isize = this.length;\n    var otherLen: isize = other.length;\n    if (otherLen != len) return select(1, -1, len > otherLen);\n    if (!otherLen) return 0; // \"\" == \"\"\n    // @ts-ignore: string <-> String\n    return compareImpl(this, 0, other, 0, otherLen);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    var size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    var size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    var len = this.length;\n    var size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var thisLen: usize = this.length;\n    var searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    var replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    var out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (separator === null) return [this];\n    var length: isize = this.length;\n    var sepLen = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    var result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    var specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    var specialsLen = SPECIALS_UPPER.length;\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      var bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      var strEnd = str + (<usize>len << 1);\n      var bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      var strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      var size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      var str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_ILLEGALGENTYPE, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  var oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    if (newData !== oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? builtin_isArray(value) && value !== null : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    var array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    var bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    var buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    var len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var ptr = this.dataStart;\n    var len = this.length_;\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        store<usize>(ptr + (<usize>start << alignof<T>()), changetype<usize>(value));\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          ptr + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(ptr + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    var ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    var ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var oldLen = this.length_;\n    var len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, other.length_, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var ptr = this.dataStart;\n    var len = this.length_;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    var len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    var val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var len = this.length_;\n    var out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    var outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    var len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    var ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    var result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): this {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var ptr = this.dataStart;\n    var len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      throw new TypeError(E_ILLEGALGENTYPE);\n    }\n    // Get the length and data start values\n    var ptr = this.dataStart;\n    var len = this.length_;\n\n    // calculate the end size with an initial pass\n    var size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    var byteLength = <usize>size << align;\n    var outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    var outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    var resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","import * as JSMath from \"./bindings/Math\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy var rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of π/2 * |x|\n *\n * y = π/4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of π/4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  var shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  var lo = umuldi(p1, q1);\n  var hi = res128_hi;\n\n  var ahi = hi >> 11;\n  var alo = lo >> 11 | hi << 53;\n  var blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  var u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  var magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  var offset = (magnitude >> 52) - 1045;\n  var shift  = offset & 63;\n  var tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  var s0: u64, s1: u64, s2: u64;\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 / π with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  var significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2π)\n  var blo = umuldi(s1, significand);\n  var bhi = res128_hi;\n\n  var ahi = s0 * significand;\n  var clo = (s2 >> 32) * (significand >> 32);\n  var plo = blo + clo;\n  var phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  var rlo = plo << 2;\n  var rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  var slo = <i64>rhi >> 63;\n  var shi = slo >> 1;\n  var q   = (<i64>phi >> 62) - slo;\n\n  var shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  var signbit = (u ^ rhi) & 0x8000000000000000;\n  var coeff   = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  var ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  var q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  var z = x * x;\n  var w = z * z;\n  var r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  var v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  var z = x * x;\n  var w = z * z;\n  var r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  var hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  var z: f64, r: f64, v: f64, w: f64, s: f64;\n  var hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  var ix = hx & 0x7FFFFFFF; // high word of |x|\n  var big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  var a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, u >> 63);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy var random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy var random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    var s: f64, w: f64, z: f64;\n    if (hx >> 31) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    var c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    var u = reinterpret<u64>(x);\n    // Prevent propagation for all input values less than 1.0.\n    // Note musl lib didn't fix this yet.\n    if (<i64>u < 0x3FF0000000000000) return (x - x) / 0.0;\n    var e = u >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z);\n    var r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    if (hx >> 31) return -x;\n    return x;\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var lx = <u32>u;\n    u = reinterpret<u64>(y);\n    var iy = <u32>(u >> 32);\n    var ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    var z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    var t = reinterpret<f64>(u);\n    var r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    var s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n      let hx = <u32>(reinterpret<u64>(x) >> 32);\n      let sign_ = <i32>(hx >> 31);\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign_ << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\n    var k = 0, sign_ = <i32>(u >> 63);\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    var c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    var hfx = 0.5 * x;\n    var hxs = x * hfx;\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    var hxq = hxs * hxs;\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    var twopk = reinterpret<f64>(u);\n    var y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    var ex = <i32>(ux >> 52);\n    var ey = <i32>(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    var z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    var c = x * SPLIT;\n    var h = x - c + c;\n    var l = x - h;\n    var hx = x * x;\n    var lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    var hy = y * y;\n    var ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = <u32>(u >> 32);\n      let k = 0;\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (hx >> 31)    return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = <u32>(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln10hi;\n    var dk = <f64>k;\n    var y = dk * log10_2hi;\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 1;\n    var c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = <u32>(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = <i32>(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = <u32>(u >> 32);\n      let k = 0;\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (hx >> 31) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = <u32>(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += <i32>(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n\n      let u_ = reinterpret<u64>(x);\n      let hx = <i32>(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = <i32>(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = <u32>(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = <u32>(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    // Instead zero seed use golden ratio:\n    // phi = (1 + sqrt(5)) / 2\n    // trunc(2^64 / phi) = 0x9e3779b97f4a7c15\n    if (value == 0) value = 0x9e3779b97f4a7c15;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    random_seeded = true;\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    var s1 = random_state0_64;\n    var s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    var r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f64): f64 {\n    let roundUp = builtin_ceil<f64>(x);\n    return select<f64>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return <bool>(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    var a = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(a);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    var u = reinterpret<u64>(x);\n    var ix = <i32>(u >> 32);\n    var sign = ix >>> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    var n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n\n    var y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = ux >> 63;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u64>-1 >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    var shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = <i32>(ux >> 63);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    var uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= <u64>-1 >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    var q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3FE921FB) {  // |x| ~<= π/4\n      if (ix < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    var n = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n    var s = sin_kern(y0, y1, 1);\n    var c = cos_kern(y0, y1);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n\n  var p = z * (pS0 + z * (pS1 + z * pS2));\n  var q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\n\n  var offset = (u >> 23) - 152;\n  var shift  = <u64>(offset & 63);\n  var tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  var hi = (b1 >> (64 - shift)) | (b0 << shift);\n  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  var product = mantissa * hi + (mantissa * lo >> 32);\n  var r: i64 = product << 2;\n  var q = <i32>((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { // π * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  var q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  var z = x * x;\n  var w = z * z;\n  var r = S3 + z * S4;\n  var s = z * x;\n  return <f32>((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  var z = x * x;\n  var w = z * z;\n  var r = C2 + z * C3;\n  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n  const\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  var z = x * x;\n  var r = T4 + z * T5;\n  var t = T2 + z * T3;\n  var w = z * z;\n  var s = z * x;\n  var u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return <f32>(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  var i = reinterpret<i64>(x);\n  var exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  var xx = x * x;\n  var y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  var n = nearest(x);\n  x -= n;\n  var xx = x * x;\n  var y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    var hx = reinterpret<u32>(x);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    var z: f32, w: f32, s: f32;\n    if (hx >> 31) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\n    var c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x);\n    var a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    }\n    // x >= 0x1p12 or x <= -2 or NaN\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    var sx = x;\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z); // sic\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\n\n    var ix = reinterpret<u32>(x);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\n    var s2 = w * (aT1 + w * aT3);\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    var u = reinterpret<u32>(x);\n    var y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var ix = reinterpret<u32>(x);\n    var iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    var z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    var t = <f64>reinterpret<f32>(u);\n    var r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {  // |x| ~<= 5π/4\n        if (ix > 0x4016CBE3) { // |x|  ~> 3π/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ix <= 0x40E231D5) {  // |x| ~<= 9π/4\n        if (ix > 0x40AFEDDF) { // |x|  ~> 7π/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n      let hx = reinterpret<u32>(x);\n      let sign_ = <i32>(hx >> 31);\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign_) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign_ << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    var sign_ = <i32>(u >> 31);\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign_) return -1;\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    var c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    var hfx: f32 = 0.5 * x;\n    var hxs: f32 = x * hfx;\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    var twopk = reinterpret<f32>(u);\n    var y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    var z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      if (u < 0x00800000 || <bool>(u >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (u >> 31) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += <u32>(<i32>u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n    var ix = reinterpret<u32>(x);\n    var k = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) {\n      return x;\n    } else if (ix == 0x3F800000) {\n      return 0;\n    }\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    ix = reinterpret<u32>(hi);\n    ix &= 0xFFFFF000;\n    hi = reinterpret<f32>(ix);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n\n    var ix = reinterpret<u32>(x);\n    var c: f32 = 0, f: f32 = 0;\n    var k: i32 = 1;\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = <i32>(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n      let ix = reinterpret<u32>(x);\n      let k: i32 = 0;\n      if (ix < 0x00800000 || <bool>(ix >> 31)) {\n        if (ix << 1 == 0) return -1 / (x * x);\n        if (ix >> 31) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ix = reinterpret<u32>(x);\n      } else if (ix >= 0x7F800000) {\n        return x;\n      } else if (ix == 0x3F800000) {\n        return 0;\n      }\n      ix += 0x3F800000 - 0x3F3504F3;\n      k += <i32>(ix >> 23) - 0x7F;\n      ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ix);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = uy >> 31 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = uy >> 31 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    var s0 = random_state0_32;\n    var s1 = random_state1_32;\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f32): f32 {\n    let roundUp = builtin_ceil<f32>(x);\n    return select<f32>(roundUp, roundUp - 1.0, roundUp - 0.5 <= x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var a = reinterpret<f32>(u);\n    var h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(a);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3π/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    // argument reduction\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    var t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n\n    var y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sm = ux & 0x80000000;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    var shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = <i32>(ux >> 31);\n    var uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= <u32>-1 >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    var q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5π/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3π/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9π/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7π/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    var s = sin_kernf(y);\n    var c = cos_kernf(y);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  var out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  var out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","import * as MathUtils from \"./MathUtils\";\n\nexport class Colors {\n  static aliceblue: i32 = 0xf0f8ff;\n  static antiquewhite: i32 = 0xfaebd7;\n  static aqua: i32 = 0x00ffff;\n  static aquamarine: i32 = 0x7fffd4;\n  static azure: i32 = 0xf0ffff;\n  static beige: i32 = 0xf5f5dc;\n  static bisque: i32 = 0xffe4c4;\n  static black: i32 = 0x000000;\n  static blanchedalmond: i32 = 0xffebcd;\n  static blue: i32 = 0x0000ff;\n  static blueviolet: i32 = 0x8a2be2;\n  static brown: i32 = 0xa52a2a;\n  static burlywood: i32 = 0xdeb887;\n  static cadetblue: i32 = 0x5f9ea0;\n  static chartreuse: i32 = 0x7fff00;\n  static chocolate: i32 = 0xd2691e;\n  static coral: i32 = 0xff7f50;\n  static cornflowerblue: i32 = 0x6495ed;\n  static cornsilk: i32 = 0xfff8dc;\n  static crimson: i32 = 0xdc143c;\n  static cyan: i32 = 0x00ffff;\n  static darkblue: i32 = 0x00008b;\n  static darkcyan: i32 = 0x008b8b;\n  static darkgoldenrod: i32 = 0xb8860b;\n  static darkgray: i32 = 0xa9a9a9;\n  static darkgreen: i32 = 0x006400;\n  static darkgrey: i32 = 0xa9a9a9;\n  static darkkhaki: i32 = 0xbdb76b;\n  static darkmagenta: i32 = 0x8b008b;\n  static darkolivegreen: i32 = 0x556b2f;\n  static darkorange: i32 = 0xff8c00;\n  static darkorchid: i32 = 0x9932cc;\n  static darkred: i32 = 0x8b0000;\n  static darksalmon: i32 = 0xe9967a;\n  static darkseagreen: i32 = 0x8fbc8f;\n  static darkslateblue: i32 = 0x483d8b;\n  static darkslategray: i32 = 0x2f4f4f;\n  static darkslategrey: i32 = 0x2f4f4f;\n  static darkturquoise: i32 = 0x00ced1;\n  static darkviolet: i32 = 0x9400d3;\n  static deeppink: i32 = 0xff1493;\n  static deepskyblue: i32 = 0x00bfff;\n  static dimgray: i32 = 0x696969;\n  static dimgrey: i32 = 0x696969;\n  static dodgerblue: i32 = 0x1e90ff;\n  static firebrick: i32 = 0xb22222;\n  static floralwhite: i32 = 0xfffaf0;\n  static forestgreen: i32 = 0x228b22;\n  static fuchsia: i32 = 0xff00ff;\n  static gainsboro: i32 = 0xdcdcdc;\n  static ghostwhite: i32 = 0xf8f8ff;\n  static gold: i32 = 0xffd700;\n  static goldenrod: i32 = 0xdaa520;\n  static gray: i32 = 0x808080;\n  static green: i32 = 0x008000;\n  static greenyellow: i32 = 0xadff2f;\n  static grey: i32 = 0x808080;\n  static honeydew: i32 = 0xf0fff0;\n  static hotpink: i32 = 0xff69b4;\n  static indianred: i32 = 0xcd5c5c;\n  static indigo: i32 = 0x4b0082;\n  static ivory: i32 = 0xfffff0;\n  static khaki: i32 = 0xf0e68c;\n  static lavender: i32 = 0xe6e6fa;\n  static lavenderblush: i32 = 0xfff0f5;\n  static lawngreen: i32 = 0x7cfc00;\n  static lemonchiffon: i32 = 0xfffacd;\n  static lightblue: i32 = 0xadd8e6;\n  static lightcoral: i32 = 0xf08080;\n  static lightcyan: i32 = 0xe0ffff;\n  static lightgoldenrodyellow: i32 = 0xfafad2;\n  static lightgray: i32 = 0xd3d3d3;\n  static lightgreen: i32 = 0x90ee90;\n  static lightgrey: i32 = 0xd3d3d3;\n  static lightpink: i32 = 0xffb6c1;\n  static lightsalmon: i32 = 0xffa07a;\n  static lightseagreen: i32 = 0x20b2aa;\n  static lightskyblue: i32 = 0x87cefa;\n  static lightslategray: i32 = 0x778899;\n  static lightslategrey: i32 = 0x778899;\n  static lightsteelblue: i32 = 0xb0c4de;\n  static lightyellow: i32 = 0xffffe0;\n  static lime: i32 = 0x00ff00;\n  static limegreen: i32 = 0x32cd32;\n  static linen: i32 = 0xfaf0e6;\n  static magenta: i32 = 0xff00ff;\n  static maroon: i32 = 0x800000;\n  static mediumaquamarine: i32 = 0x66cdaa;\n  static mediumblue: i32 = 0x0000cd;\n  static mediumorchid: i32 = 0xba55d3;\n  static mediumpurple: i32 = 0x9370db;\n  static mediumseagreen: i32 = 0x3cb371;\n  static mediumslateblue: i32 = 0x7b68ee;\n  static mediumspringgreen: i32 = 0x00fa9a;\n  static mediumturquoise: i32 = 0x48d1cc;\n  static mediumvioletred: i32 = 0xc71585;\n  static midnightblue: i32 = 0x191970;\n  static mintcream: i32 = 0xf5fffa;\n  static mistyrose: i32 = 0xffe4e1;\n  static moccasin: i32 = 0xffe4b5;\n  static navajowhite: i32 = 0xffdead;\n  static navy: i32 = 0x000080;\n  static oldlace: i32 = 0xfdf5e6;\n  static olive: i32 = 0x808000;\n  static olivedrab: i32 = 0x6b8e23;\n  static orange: i32 = 0xffa500;\n  static orangered: i32 = 0xff4500;\n  static orchid: i32 = 0xda70d6;\n  static palegoldenrod: i32 = 0xeee8aa;\n  static palegreen: i32 = 0x98fb98;\n  static paleturquoise: i32 = 0xafeeee;\n  static palevioletred: i32 = 0xdb7093;\n  static papayawhip: i32 = 0xffefd5;\n  static peachpuff: i32 = 0xffdab9;\n  static peru: i32 = 0xcd853f;\n  static pink: i32 = 0xffc0cb;\n  static plum: i32 = 0xdda0dd;\n  static powderblue: i32 = 0xb0e0e6;\n  static purple: i32 = 0x800080;\n  static rebeccapurple: i32 = 0x663399;\n  static red: i32 = 0xff0000;\n  static rosybrown: i32 = 0xbc8f8f;\n  static royalblue: i32 = 0x4169e1;\n  static saddlebrown: i32 = 0x8b4513;\n  static salmon: i32 = 0xfa8072;\n  static sandybrown: i32 = 0xf4a460;\n  static seagreen: i32 = 0x2e8b57;\n  static seashell: i32 = 0xfff5ee;\n  static sienna: i32 = 0xa0522d;\n  static silver: i32 = 0xc0c0c0;\n  static skyblue: i32 = 0x87ceeb;\n  static slateblue: i32 = 0x6a5acd;\n  static slategray: i32 = 0x708090;\n  static slategrey: i32 = 0x708090;\n  static snow: i32 = 0xfffafa;\n  static springgreen: i32 = 0x00ff7f;\n  static steelblue: i32 = 0x4682b4;\n  static tan: i32 = 0xd2b48c;\n  static teal: i32 = 0x008080;\n  static thistle: i32 = 0xd8bfd8;\n  static tomato: i32 = 0xff6347;\n  static turquoise: i32 = 0x40e0d0;\n  static violet: i32 = 0xee82ee;\n  static wheat: i32 = 0xf5deb3;\n  static white: i32 = 0xffffff;\n  static whitesmoke: i32 = 0xf5f5f5;\n  static yellow: i32 = 0xffff00;\n  static yellowgreen: i32 = 0x9acd32;\n}\nexport class HSL {\n  h: f32 = 0;\n  s: f32 = 0;\n  l: f32 = 0;\n}\n\nconst _hslA: HSL = new HSL();\nconst _hslB: HSL = new HSL();\n\nfunction hue2rgb(p: f32, q: f32, t: f32): f32 {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n  return p;\n}\n\nfunction SRGBToLinear(c: f32): f32 {\n  return c < 0.04045 ? c * 0.0773993808 : Mathf.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n}\n\nfunction LinearToSRGB(c: f32): f32 {\n  return c < 0.0031308 ? c * 12.92 : 1.055 * Mathf.pow(c, 0.41666) - 0.055;\n}\n\nexport class Color {\n  r: f32;\n  b: f32;\n  g: f32;\n\n  constructor(r: f32 = 1, g: f32 = 1, b: f32 = 1) {\n    this.setRGB(r, g, b);\n  }\n\n  setFromColor(value: Color): Color {\n    this.copy(value);\n    return this;\n  }\n\n  setFromF32(value: f32): Color {\n    this.setHex(value);\n    return this;\n  }\n\n  // TODO: As doesnt support regex yet\n  //   setFromString(value: string) {\n  //     this.setStyle(value);\n  //     return this;\n  //   }\n\n  setScalar(scalar: f32): Color {\n    this.r = scalar;\n    this.g = scalar;\n    this.b = scalar;\n\n    return this;\n  }\n\n  setHex(hex: f32): Color {\n    hex = Mathf.floor(hex);\n\n    this.r = ((hex >> 16) & 255) / 255;\n    this.g = ((hex >> 8) & 255) / 255;\n    this.b = (hex & 255) / 255;\n\n    return this;\n  }\n\n  setRGB(r: f32, g: f32, b: f32): Color {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n\n    return this;\n  }\n\n  setHSL(h: f32, s: f32, l: f32): Color {\n    // h,s,l ranges are in 0.0 - 1.0\n    h = MathUtils.euclideanModulo(h, 1);\n    s = MathUtils.clamp(s, 0, 1);\n    l = MathUtils.clamp(l, 0, 1);\n\n    if (s === 0) {\n      this.r = this.g = this.b = l;\n    } else {\n      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n      const q = 2 * l - p;\n\n      this.r = hue2rgb(q, p, h + 1 / 3);\n      this.g = hue2rgb(q, p, h);\n      this.b = hue2rgb(q, p, h - 1 / 3);\n    }\n\n    return this;\n  }\n\n  // TODO: regex is not in AS yet\n  //   setStyle(style: string) {\n  //     function handleAlpha(string: string) {\n  //       if (parseFloat(string) < 1) {\n  //         console.warn(\n  //           \"THREE.Color: Alpha component of \" + style + \" will be ignored.\"\n  //         );\n  //       }\n  //     }\n\n  //     let m;\n\n  //     if ((m = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec(style))) {\n  //       // rgb / hsl\n\n  //       let color;\n  //       const name = m[1];\n  //       const components = m[2];\n\n  //       switch (name) {\n  //         case \"rgb\":\n  //         case \"rgba\":\n  //           if (\n  //             (color =\n  //               /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\n  //                 components\n  //               ))\n  //           ) {\n  //             // rgb(255,0,0) rgba(255,0,0,0.5)\n  //             this.r = Mathf.min(255, parseInt(color[1], 10)) / 255;\n  //             this.g = Mathf.min(255, parseInt(color[2], 10)) / 255;\n  //             this.b = Mathf.min(255, parseInt(color[3], 10)) / 255;\n\n  //             handleAlpha(color[4]);\n\n  //             return this;\n  //           }\n\n  //           if (\n  //             (color =\n  //               /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\n  //                 components\n  //               ))\n  //           ) {\n  //             // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n  //             this.r = Mathf.min(100, parseInt(color[1], 10)) / 100;\n  //             this.g = Mathf.min(100, parseInt(color[2], 10)) / 100;\n  //             this.b = Mathf.min(100, parseInt(color[3], 10)) / 100;\n\n  //             handleAlpha(color[4]);\n\n  //             return this;\n  //           }\n\n  //           break;\n\n  //         case \"hsl\":\n  //         case \"hsla\":\n  //           if (\n  //             (color =\n  //               /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(\n  //                 components\n  //               ))\n  //           ) {\n  //             // hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n  //             const h = parseFloat(color[1]) / 360;\n  //             const s = parseInt(color[2], 10) / 100;\n  //             const l = parseInt(color[3], 10) / 100;\n\n  //             handleAlpha(color[4]);\n\n  //             return this.setHSL(h, s, l);\n  //           }\n\n  //           break;\n  //       }\n  //     } else if ((m = /^\\#([A-Fa-f\\d]+)$/.exec(style))) {\n  //       // hex color\n\n  //       const hex = m[1];\n  //       const size = hex.length;\n\n  //       if (size === 3) {\n  //         // #ff0\n  //         this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n  //         this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n  //         this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n\n  //         return this;\n  //       } else if (size === 6) {\n  //         // #ff0000\n  //         this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n  //         this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n  //         this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n\n  //         return this;\n  //       }\n  //     }\n\n  //     if (style && style.length > 0) {\n  //       return this.setColorName(style);\n  //     }\n\n  //     return this;\n  //   }\n\n  // setColorName(style: string): Color {\n  //   // color keywords\n  //   const hex: u32 = Colors[style.toLowerCase()];\n\n  //   if (hex !== undefined) {\n  //     // red\n  //     this.setHex(hex);\n  //   } else {\n  //     // unknown color\n  //     console.warn(\"THREE.Color: Unknown color \" + style);\n  //   }\n\n  //   return this;\n  // }\n\n  clone(): Color {\n    return new Color(this.r, this.g, this.b);\n  }\n\n  copy(color: Color): Color {\n    this.r = color.r;\n    this.g = color.g;\n    this.b = color.b;\n\n    return this;\n  }\n\n  copyGammaToLinear(color: Color, gammaFactor: f32 = 2.0): Color {\n    this.r = Mathf.pow(color.r, gammaFactor);\n    this.g = Mathf.pow(color.g, gammaFactor);\n    this.b = Mathf.pow(color.b, gammaFactor);\n\n    return this;\n  }\n\n  copyLinearToGamma(color: Color, gammaFactor: f32 = 2.0): Color {\n    const safeInverse: f32 = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;\n\n    this.r = Mathf.pow(color.r, safeInverse);\n    this.g = Mathf.pow(color.g, safeInverse);\n    this.b = Mathf.pow(color.b, safeInverse);\n\n    return this;\n  }\n\n  convertGammaToLinear(gammaFactor: f32): Color {\n    this.copyGammaToLinear(this, gammaFactor);\n\n    return this;\n  }\n\n  convertLinearToGamma(gammaFactor: f32): Color {\n    this.copyLinearToGamma(this, gammaFactor);\n\n    return this;\n  }\n\n  copySRGBToLinear(color: Color): Color {\n    this.r = SRGBToLinear(color.r);\n    this.g = SRGBToLinear(color.g);\n    this.b = SRGBToLinear(color.b);\n\n    return this;\n  }\n\n  copyLinearToSRGB(color: Color): Color {\n    this.r = LinearToSRGB(color.r);\n    this.g = LinearToSRGB(color.g);\n    this.b = LinearToSRGB(color.b);\n\n    return this;\n  }\n\n  convertSRGBToLinear(): Color {\n    this.copySRGBToLinear(this);\n\n    return this;\n  }\n\n  convertLinearToSRGB(): Color {\n    this.copyLinearToSRGB(this);\n\n    return this;\n  }\n\n  getHex(): i32 {\n    return ((this.r * 255) << 16) ^ ((this.g * 255) << 8) ^ ((this.b * 255) << 0);\n  }\n\n  getHexString(): string {\n    return (\"000000\" + this.getHex().toString(16)).slice(-6);\n  }\n\n  getHSL(target: HSL): HSL {\n    // h,s,l ranges are in 0.0 - 1.0\n    const r: f32 = this.r,\n      g: f32 = this.g,\n      b: f32 = this.b;\n\n    let max: f32 = Mathf.max(r, g);\n    max = Mathf.max(max, b);\n    let min: f32 = Mathf.min(r, g);\n    min = Mathf.min(min, b);\n\n    let hue!: f32, saturation: f32;\n    const lightness: f32 = (min + max) / 2.0;\n\n    if (min === max) {\n      hue = 0;\n      saturation = 0;\n    } else {\n      const delta = max - min;\n\n      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n      switch (max) {\n        case r:\n          hue = (g - b) / delta + (g < b ? 6 : 0);\n          break;\n        case g:\n          hue = (b - r) / delta + 2;\n          break;\n        case b:\n          hue = (r - g) / delta + 4;\n          break;\n      }\n\n      hue /= 6;\n    }\n\n    target.h = hue;\n    target.s = saturation;\n    target.l = lightness;\n\n    return target;\n  }\n\n  getStyle(): string {\n    return \"rgb(\" + ((this.r * 255) | 0) + \",\" + ((this.g * 255) | 0) + \",\" + ((this.b * 255) | 0) + \")\";\n  }\n\n  offsetHSL(h: f32, s: f32, l: f32): Color {\n    this.getHSL(_hslA);\n\n    _hslA.h += h;\n    _hslA.s += s;\n    _hslA.l += l;\n\n    this.setHSL(_hslA.h, _hslA.s, _hslA.l);\n\n    return this;\n  }\n\n  add(color: Color): Color {\n    this.r += color.r;\n    this.g += color.g;\n    this.b += color.b;\n\n    return this;\n  }\n\n  addColors(color1: Color, color2: Color): Color {\n    this.r = color1.r + color2.r;\n    this.g = color1.g + color2.g;\n    this.b = color1.b + color2.b;\n\n    return this;\n  }\n\n  addScalar(s: f32): Color {\n    this.r += s;\n    this.g += s;\n    this.b += s;\n\n    return this;\n  }\n\n  sub(color: Color): Color {\n    this.r = Mathf.max(0, this.r - color.r);\n    this.g = Mathf.max(0, this.g - color.g);\n    this.b = Mathf.max(0, this.b - color.b);\n\n    return this;\n  }\n\n  multiply(color: Color): Color {\n    this.r *= color.r;\n    this.g *= color.g;\n    this.b *= color.b;\n\n    return this;\n  }\n\n  multiplyScalar(s: f32): Color {\n    this.r *= s;\n    this.g *= s;\n    this.b *= s;\n\n    return this;\n  }\n\n  lerp(color: Color, alpha: f32): Color {\n    this.r += (color.r - this.r) * alpha;\n    this.g += (color.g - this.g) * alpha;\n    this.b += (color.b - this.b) * alpha;\n\n    return this;\n  }\n\n  lerpColors(color1: Color, color2: Color, alpha: f32): Color {\n    this.r = color1.r + (color2.r - color1.r) * alpha;\n    this.g = color1.g + (color2.g - color1.g) * alpha;\n    this.b = color1.b + (color2.b - color1.b) * alpha;\n\n    return this;\n  }\n\n  lerpHSL(color: Color, alpha: f32): Color {\n    this.getHSL(_hslA);\n    color.getHSL(_hslB);\n\n    const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);\n    const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);\n    const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);\n\n    this.setHSL(h, s, l);\n\n    return this;\n  }\n\n  equals(c: Color): boolean {\n    return c.r === this.r && c.g === this.g && c.b === this.b;\n  }\n\n  fromArray(array: f32[], offset: u32 = 0): Color {\n    this.r = array[offset];\n    this.g = array[offset + 1];\n    this.b = array[offset + 2];\n\n    return this;\n  }\n\n  fromF32Array(array: Float32Array, offset: u32 = 0): Color {\n    this.r = array[offset];\n    this.g = array[offset + 1];\n    this.b = array[offset + 2];\n\n    return this;\n  }\n\n  toArray(array: f32[] = [], offset: u32 = 0): f32[] {\n    array[offset] = this.r;\n    array[offset + 1] = this.g;\n    array[offset + 2] = this.b;\n\n    return array;\n  }\n\n  toF32Array(array: Float32Array, offset: u32 = 0): Float32Array {\n    array[offset] = this.r;\n    array[offset + 1] = this.g;\n    array[offset + 2] = this.b;\n\n    return array;\n  }\n\n  // TODO:\n  //   fromBufferAttribute(attribute, index) {\n  //     this.r = attribute.getX(index);\n  //     this.g = attribute.getY(index);\n  //     this.b = attribute.getZ(index);\n\n  //     if (attribute.normalized === true) {\n  //       // assuming Uint8Array\n\n  //       this.r /= 255;\n  //       this.g /= 255;\n  //       this.b /= 255;\n  //     }\n\n  //     return this;\n  //   }\n\n  // toJSON(): i32 {\n  //   return this.getHex();\n  // }\n}\n","export enum PrimitiveType {\n  POINTS = 0x0000,\n  LINES = 0x0001,\n  LINE_LOOP = 0x0002,\n  LINE_STRIP = 0x0003,\n  TRIANGLES = 0x0004,\n  TRIANGLE_STRIP = 0x0005,\n  TRIANGLE_FAN = 0x0006,\n}\n\nexport enum BufferObjects {\n  ARRAY_BUFFER = 0x8892,\n  ELEMENT_ARRAY_BUFFER = 0x8893,\n  BUFFER_SIZE = 0x8764,\n  BUFFER_USAGE = 0x8765,\n}\n\nexport enum UsageType {\n  STATIC_DRAW = 0x88e4,\n  STREAM_DRAW = 0x88e0,\n  DYNAMIC_DRAW = 0x88e8,\n}\n\nexport enum DataType {\n  BYTE = 0x1400,\n  UNSIGNED_BYTE = 0x1401,\n  SHORT = 0x1402,\n  UNSIGNED_SHORT = 0x1403,\n  INT = 0x1404,\n  UNSIGNED_INT = 0x1405,\n  FLOAT = 0x1406,\n  HALF_FLOAT = 0x140b,\n}\n\nexport enum GLFeatures {\n  BLEND = 0x0be2,\n  DEPTH_TEST = 0x0b71,\n  DITHER = 0x0bd0,\n  POLYGON_OFFSET_FILL = 0x8037,\n  SAMPLE_ALPHA_TO_COVERAGE = 0x809e,\n  SAMPLE_COVERAGE = 0x80a0,\n  SCISSOR_TEST = 0x0c11,\n  STENCIL_TEST = 0x0b90,\n}\n\nexport enum DepthModes {\n  NeverDepth = 0x0200,\n  AlwaysDepth = 0x0207,\n  LessDepth = 0x0201,\n  LessEqualDepth = 0x0203,\n  EqualDepth = 0x0202,\n  GreaterEqualDepth = 0x0206,\n  GreaterDepth = 0x0204,\n  NotEqualDepth = 0x0205,\n}\n\nexport enum BlendModes {\n  ZERO = 0,\n  ONE = 1,\n  SRC_COLOR = 0x0300,\n  ONE_MINUS_SRC_COLOR = 0x0301,\n  SRC_ALPHA = 0x0302,\n  ONE_MINUS_SRC_ALPHA = 0x0303,\n  DST_ALPHA = 0x0304,\n  ONE_MINUS_DST_ALPHA = 0x0305,\n  DST_COLOR = 0x0306,\n  ONE_MINUS_DST_COLOR = 0x0307,\n  SRC_ALPHA_SATURATE = 0x0308,\n  CONSTANT_COLOR = 0x8001,\n  ONE_MINUS_CONSTANT_COLOR = 0x8002,\n  CONSTANT_ALPHA = 0x8003,\n  ONE_MINUS_CONSTANT_ALPHA = 0x8004,\n}\n\nexport enum GLBlendingEquations {\n  FUNC_ADD = 0x8006,\n  FUNC_SUBTRACT = 0x800a,\n  FUNC_REVERSE_SUBTRACT = 0x800b,\n  MIN = 0x8007,\n  MAX = 0x8008,\n}\n\nexport enum Culling {\n  CULL_FACE = 0x0b44,\n  FRONT = 0x0404,\n  BACK = 0x0405,\n  FRONT_AND_BACK = 0x0408,\n}\n\nexport enum FaceDirection {\n  CW = 0x0900,\n  CCW = 0x0901,\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n * @author Lu Wang / http://github.com/luwangthreekit\n * @author WestLangley / http://github.com/westlangley\n * @author Rich-Harris / http://github.com/rich-harris\n * @author Benjamin-Dobell / http://github.com/benjamin-dobell\n * @author artur-trzesiok / http://github.com/artur-trzesiok\n * @author AtiX / http://github.com/atix\n * @author amakaseev / http://github.com/amakaseev\n * @author bhouston / http://exocortex.com\n * @author TristanVALCKE / https://github.com/Itee\n * @author corruptedzulu / http://github.com/corruptedzulu\n * @author Joe Pea / http://github.com/trusktr\n */\n\nexport enum MOUSE {\n  LEFT,\n  MIDDLE,\n  RIGHT,\n}\n\n// GL STATE CONSTANTS\nexport enum CullFace {\n  CullFaceNone = 0,\n  CullFaceBack = 1,\n  CullFaceFront = 2,\n  CullFaceFrontBack = 3,\n}\nexport enum FrontFaceDirection {\n  FrontFaceDirectionCW = 0,\n  FrontFaceDirectionCCW = 1,\n}\n// Shadowing Type\nexport enum ShadowMapType {\n  BasicShadowMap = 0,\n  PCFShadowMap = 1,\n  PCFSoftShadowMap = 2,\n}\n// MATERIAL CONSTANTS\n\n// side\nexport enum Side {\n  FrontSide,\n  BackSide,\n  DoubleSide,\n}\n\n// shadow side\nexport enum ShadowSide {\n  FrontSide,\n  BackSide,\n  DoubleSide,\n  AutoSide,\n}\n\n// shading\nexport enum Shading {\n  FlatShading = 1,\n  SmoothShading = 2,\n}\n\nexport enum Precision {\n  Highp,\n  Mediump,\n  Lowp,\n  Default,\n}\n\n// colors\nexport enum Colors {\n  NoColors = 0,\n  FaceColors = 1,\n  VertexColors = 2,\n}\n// blending modes\nexport enum Blending {\n  NoBlending = 0,\n  NormalBlending = 1,\n  AdditiveBlending = 2,\n  SubtractiveBlending = 3,\n  MultiplyBlending = 4,\n  CustomBlending = 5,\n}\n\n// custom blending equations\n// (numbers start from 100 not to clash with other\n// mappings to OpenGL constants defined in Texture.js)\nexport enum BlendingEquation {\n  AddEquation = 100,\n  SubtractEquation = 101,\n  ReverseSubtractEquation = 102,\n  MinEquation = 103,\n  MaxEquation = 104,\n}\n// custom blending destination factors\nexport enum BlendingDstFactor {\n  ZeroFactor = 200,\n  OneFactor = 201,\n  SrcColorFactor = 202,\n  OneMinusSrcColorFactor = 203,\n  SrcAlphaFactor = 204,\n  OneMinusSrcAlphaFactor = 205,\n  DstAlphaFactor = 206,\n  OneMinusDstAlphaFactor = 207,\n  DstColorFactor = 208,\n  OneMinusDstColorFactor = 209,\n}\n\n// custom blending source factors (contains the same values as BlendingDstFactor,\n// plus one additional value that is only valid as a source value)\nexport enum BlendingSrcFactor {\n  ZeroFactor = 200,\n  OneFactor = 201,\n  SrcColorFactor = 202,\n  OneMinusSrcColorFactor = 203,\n  SrcAlphaFactor = 204,\n  OneMinusSrcAlphaFactor = 205,\n  DstAlphaFactor = 206,\n  OneMinusDstAlphaFactor = 207,\n  DstColorFactor = 208,\n  OneMinusDstColorFactor = 209,\n  SrcAlphaSaturateFactor = 210,\n}\n\n// TEXTURE CONSTANTS\n// Operations\nexport enum Combine {\n  MultiplyOperation = 0,\n  MixOperation = 1,\n  AddOperation = 2,\n}\n// Tone Mapping modes\nexport enum ToneMapping {\n  NoToneMapping = 0,\n  LinearToneMapping = 1,\n  ReinhardToneMapping = 2,\n  Uncharted2ToneMapping = 3,\n  CineonToneMapping = 4,\n  ACESFilmicToneMapping = 5,\n}\n// Mapping modes\nexport enum Mapping {\n  UVMapping = 300,\n  CubeReflectionMapping = 301,\n  CubeRefractionMapping = 302,\n  EquirectangularReflectionMapping = 303,\n  EquirectangularRefractionMapping = 304,\n  SphericalReflectionMapping = 305,\n  CubeUVReflectionMapping = 306,\n  CubeUVRefractionMapping = 307,\n}\n// Wrapping modes\nexport enum Wrapping {\n  RepeatWrapping = 1000,\n  ClampToEdgeWrapping = 1001,\n  MirroredRepeatWrapping = 1002,\n}\n// Filters\nexport enum TextureFilter {\n  NearestFilter = 1003,\n  NearestMipMapNearestFilter = 1004,\n  NearestMipMapLinearFilter = 1005,\n  LinearFilter = 1006,\n  LinearMipMapNearestFilter = 1007,\n  LinearMipMapLinearFilter = 1008,\n}\n// Data types\nexport enum TextureDataType {\n  UnsignedByteType = 1009,\n  ByteType = 1010,\n  ShortType = 1011,\n  UnsignedShortType = 1012,\n  IntType = 1013,\n  UnsignedIntType = 1014,\n  FloatType = 1015,\n  HalfFloatType = 1016,\n}\n// Pixel types\nexport enum PixelType {\n  UnsignedShort4444Type = 1017,\n  UnsignedShort5551Type = 1018,\n  UnsignedShort565Type = 1019,\n  UnsignedInt248Type = 1020,\n}\n// Pixel formats\nexport enum PixelFormat {\n  AlphaFormat = 1021,\n  RGBFormat = 1022,\n  RGBAFormat = 1023,\n  LuminanceFormat = 1024,\n  LuminanceAlphaFormat = 1025,\n  RGBEFormat = RGBAFormat,\n  DepthFormat = 1026,\n  DepthStencilFormat = 1027,\n  RedFormat = 1028,\n}\n// Compressed texture formats\n// DDS / ST3C Compressed texture formats\nexport enum CompressedPixelFormat {\n  RGB_S3TC_DXT1_Format = 33776,\n  RGBA_S3TC_DXT1_Format = 33777,\n  RGBA_S3TC_DXT3_Format = 33778,\n  RGBA_S3TC_DXT5_Format = 33779,\n\n  // PVRTC compressed './texture formats\n  RGB_PVRTC_4BPPV1_Format = 35840,\n  RGB_PVRTC_2BPPV1_Format = 35841,\n  RGBA_PVRTC_4BPPV1_Format = 35842,\n  RGBA_PVRTC_2BPPV1_Format = 35843,\n\n  // ETC compressed texture formats\n  RGB_ETC1_Format = 36196,\n\n  // ASTC compressed texture formats\n  RGBA_ASTC_4x4_Format = 37808,\n  RGBA_ASTC_5x4_Format = 37809,\n  RGBA_ASTC_5x5_Format = 37810,\n  RGBA_ASTC_6x5_Format = 37811,\n  RGBA_ASTC_6x6_Format = 37812,\n  RGBA_ASTC_8x5_Format = 37813,\n  RGBA_ASTC_8x6_Format = 37814,\n  RGBA_ASTC_8x8_Format = 37815,\n  RGBA_ASTC_10x5_Format = 37816,\n  RGBA_ASTC_10x6_Format = 37817,\n  RGBA_ASTC_10x8_Format = 37818,\n  RGBA_ASTC_10x10_Format = 37819,\n  RGBA_ASTC_12x10_Format = 37820,\n  RGBA_ASTC_12x12_Format = 37821,\n}\n// Loop styles for AnimationAction\nexport enum AnimationActionLoopStyles {\n  LoopOnce = 2200,\n  LoopRepeat = 2201,\n  LoopPingPong = 2202,\n}\n// Interpolation\nexport enum InterpolationModes {\n  InterpolateDiscrete = 2300,\n  InterpolateLinear = 2301,\n  InterpolateSmooth = 2302,\n}\n// Interpolant ending modes\nexport enum InterpolationEndingModes {\n  ZeroCurvatureEnding = 2400,\n  ZeroSlopeEnding = 2401,\n  WrapAroundEnding = 2402,\n}\n// Triangle Draw modes\nexport enum TrianglesDrawModes {\n  TrianglesDrawMode = 0,\n  TriangleStripDrawMode = 1,\n  TriangleFanDrawMode = 2,\n}\n// Texture Encodings\nexport enum TextureEncoding {\n  LinearEncoding = 3000,\n  sRGBEncoding = 3001,\n  GammaEncoding = 3007,\n  RGBEEncoding = 3002,\n  LogLuvEncoding = 3003,\n  RGBM7Encoding = 3004,\n  RGBM16Encoding = 3005,\n  RGBDEncoding = 3006,\n}\n// Depth packing strategies\nexport enum DepthPackingStrategies {\n  BasicDepthPacking = 3200,\n  RGBADepthPacking = 3201,\n}\n// Normal Map types\nexport enum NormalMapTypes {\n  TangentSpaceNormalMap = 0,\n  ObjectSpaceNormalMap = 1,\n}\nexport enum StencilOp {\n  ZeroStencilOp = 0,\n  KeepStencilOp = 7680,\n  ReplaceStencilOp = 7681,\n  IncrementStencilOp = 7682,\n  DecrementStencilOp = 7683,\n  IncrementWrapStencilOp = 34055,\n  DecrementWrapStencilOp = 34056,\n  InvertStencilOp = 5386,\n}\nexport enum StencilFunc {\n  NeverStencilFunc = 512,\n  LessStencilFunc = 513,\n  EqualStencilFunc = 514,\n  LessEqualStencilFunc = 515,\n  GreaterStencilFunc = 516,\n  NotEqualStencilFunc = 517,\n  GreaterEqualStencilFunc = 518,\n  AlwaysStencilFunc = 519,\n}\nexport enum Usage {\n  StaticDrawUsage = 35044,\n  DynamicDrawUsage = 35048,\n  StreamDrawUsage = 35040,\n  StaticReadUsage = 35045,\n  DynamicReadUsage = 35049,\n  StreamReadUsage = 35041,\n  StaticCopyUsage = 35046,\n  DynamicCopyUsage = 35050,\n  StreamCopyUsage = 35042,\n}\n\n// GLSL1 = \"100\",\n// GLSL3 = \"300 es\",\n\nexport enum ShaderConstants {\n  FRAGMENT_SHADER = 0x8b30,\n  VERTEX_SHADER = 0x8b31,\n  COMPILE_STATUS = 0x8b81,\n  DELETE_STATUS = 0x8b80,\n  LINK_STATUS = 0x8b82,\n  VALIDATE_STATUS = 0x8b83,\n  ATTACHED_SHADERS = 0x8b85,\n  ACTIVE_ATTRIBUTES = 0x8b89,\n  ACTIVE_UNIFORMS = 0x8b86,\n  MAX_VERTEX_ATTRIBS = 0x8869,\n  MAX_VERTEX_UNIFORM_VECTORS = 0x8dfb,\n  MAX_VARYING_VECTORS = 0x8dfc,\n  MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8b4d,\n  MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8b4c,\n  MAX_TEXTURE_IMAGE_UNITS = 0x8872,\n  MAX_FRAGMENT_UNIFORM_VECTORS = 0x8dfd,\n  SHADER_TYPE = 0x8b4f,\n  SHADING_LANGUAGE_VERSION = 0x8b8c,\n  CURRENT_PROGRAM = 0x8b8d,\n}\n","// import { Camera } from \"../cameras/Camera\";\n// import { BufferAttribute } from \"../core/BufferAttribute\";\nimport { Camera } from \"../cameras/Camera\";\nimport { BufferAttribute } from \"../core/BufferAttribute\";\nimport { Cylindrical } from \"./Cylindrical\";\nimport { Euler } from \"./Euler\";\nimport * as MathUtils from \"./MathUtils\";\nimport { Matrix3 } from \"./Matrix3\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Quaternion } from \"./Quaternion\";\nimport { Spherical } from \"./Spherical\";\n\nexport class Vector3 {\n  isVector3: boolean = true;\n  x: f32;\n  y: f32;\n  z: f32;\n\n  constructor(x: f32 = 0, y: f32 = 0, z: f32 = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  set(x: f32, y: f32, z: f32): Vector3 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n\n    return this;\n  }\n\n  setByIndex(index: u8, value: f32): Vector3 {\n    if (index === 0) this.x = value;\n    else if (index === 1) this.y = value;\n    else this.z = value;\n\n    return this;\n  }\n\n  setScalar(scalar: f32): Vector3 {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n\n    return this;\n  }\n\n  setX(x: f32): Vector3 {\n    this.x = x;\n\n    return this;\n  }\n\n  setY(y: f32): Vector3 {\n    this.y = y;\n\n    return this;\n  }\n\n  setZ(z: f32): Vector3 {\n    this.z = z;\n\n    return this;\n  }\n\n  setComponent(index: u32, value: f32): Vector3 {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n\n    return this;\n  }\n\n  getComponent(index: u32): f32 {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n  }\n\n  clone(): Vector3 {\n    return new Vector3(this.x, this.y, this.z);\n  }\n\n  copy(v: Vector3): Vector3 {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n\n    return this;\n  }\n\n  add(v: Vector3): Vector3 {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n\n    return this;\n  }\n\n  addScalar(s: f32): Vector3 {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n\n    return this;\n  }\n\n  addVectors(a: Vector3, b: Vector3): Vector3 {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n\n    return this;\n  }\n\n  addScaledVector(v: Vector3, s: f32): Vector3 {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n\n    return this;\n  }\n\n  sub(v: Vector3): Vector3 {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n\n    return this;\n  }\n\n  subScalar(s: f32): Vector3 {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n\n    return this;\n  }\n\n  subVectors(a: Vector3, b: Vector3): Vector3 {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n\n    return this;\n  }\n\n  multiply(v: Vector3): Vector3 {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n\n    return this;\n  }\n\n  multiplyScalar(scalar: f32): Vector3 {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n\n    return this;\n  }\n\n  multiplyVectors(a: Vector3, b: Vector3): Vector3 {\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n\n    return this;\n  }\n\n  applyEuler(euler: Euler): Vector3 {\n    return this.applyQuaternion(_quaternion.setFromEuler(euler, false));\n  }\n\n  applyAxisAngle(axis: Vector3, angle: f32): Vector3 {\n    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));\n  }\n\n  applyMatrix3(m: Matrix3): Vector3 {\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n\n    return this;\n  }\n\n  applyNormalMatrix(m: Matrix3): Vector3 {\n    return this.applyMatrix3(m).normalize();\n  }\n\n  applyMatrix4(m: Matrix4): Vector3 {\n    const x: f32 = this.x,\n      y: f32 = this.y,\n      z: f32 = this.z;\n    const e = m.elements;\n\n    const w: f32 = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n\n    return this;\n  }\n\n  applyQuaternion(q: Quaternion): Vector3 {\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const qx = q.x,\n      qy = q.y,\n      qz = q.z,\n      qw = q.w;\n\n    // calculate quat * vector\n\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n    return this;\n  }\n\n  project(camera: Camera): Vector3 {\n    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n  }\n\n  unproject(camera: Camera): Vector3 {\n    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n  }\n\n  transformDirection(m: Matrix4): Vector3 {\n    // input: THREE.Matrix4 affine matrix\n    // vector interpreted as a direction\n\n    const x = this.x,\n      y = this.y,\n      z = this.z;\n    const e = m.elements;\n\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n\n    return this.normalize();\n  }\n\n  divide(v: Vector3): Vector3 {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n\n    return this;\n  }\n\n  divideScalar(scalar: f32): Vector3 {\n    return this.multiplyScalar(1 / scalar);\n  }\n\n  min(v: Vector3): Vector3 {\n    this.x = Mathf.min(this.x, v.x);\n    this.y = Mathf.min(this.y, v.y);\n    this.z = Mathf.min(this.z, v.z);\n\n    return this;\n  }\n\n  max(v: Vector3): Vector3 {\n    this.x = Mathf.max(this.x, v.x);\n    this.y = Mathf.max(this.y, v.y);\n    this.z = Mathf.max(this.z, v.z);\n\n    return this;\n  }\n\n  clamp(min: Vector3, max: Vector3): Vector3 {\n    // assumes min < max, componentwise\n\n    this.x = Mathf.max(min.x, Mathf.min(max.x, this.x));\n    this.y = Mathf.max(min.y, Mathf.min(max.y, this.y));\n    this.z = Mathf.max(min.z, Mathf.min(max.z, this.z));\n\n    return this;\n  }\n\n  clampScalar(minVal: f32, maxVal: f32): Vector3 {\n    this.x = Mathf.max(minVal, Mathf.min(maxVal, this.x));\n    this.y = Mathf.max(minVal, Mathf.min(maxVal, this.y));\n    this.z = Mathf.max(minVal, Mathf.min(maxVal, this.z));\n\n    return this;\n  }\n\n  clampLength(min: f32, max: f32): Vector3 {\n    const length = this.length();\n\n    return this.divideScalar(length || 1).multiplyScalar(Mathf.max(min, Mathf.min(max, length)));\n  }\n\n  floor(): Vector3 {\n    this.x = Mathf.floor(this.x);\n    this.y = Mathf.floor(this.y);\n    this.z = Mathf.floor(this.z);\n\n    return this;\n  }\n\n  ceil(): Vector3 {\n    this.x = Mathf.ceil(this.x);\n    this.y = Mathf.ceil(this.y);\n    this.z = Mathf.ceil(this.z);\n\n    return this;\n  }\n\n  round(): Vector3 {\n    this.x = Mathf.round(this.x);\n    this.y = Mathf.round(this.y);\n    this.z = Mathf.round(this.z);\n\n    return this;\n  }\n\n  roundToZero(): Vector3 {\n    this.x = this.x < 0 ? Mathf.ceil(this.x) : Mathf.floor(this.x);\n    this.y = this.y < 0 ? Mathf.ceil(this.y) : Mathf.floor(this.y);\n    this.z = this.z < 0 ? Mathf.ceil(this.z) : Mathf.floor(this.z);\n\n    return this;\n  }\n\n  negate(): Vector3 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n\n    return this;\n  }\n\n  dot(v: Vector3): f32 {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  }\n\n  // TODO lengthSquared?\n\n  lengthSq(): f32 {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n\n  length(): f32 {\n    return Mathf.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n\n  manhattanLength(): f32 {\n    return Mathf.abs(this.x) + Mathf.abs(this.y) + Mathf.abs(this.z);\n  }\n\n  normalize(): Vector3 {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  setLength(length: f32): Vector3 {\n    return this.normalize().multiplyScalar(length);\n  }\n\n  lerp(v: Vector3, alpha: f32): Vector3 {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n\n    return this;\n  }\n\n  lerpVectors(v1: Vector3, v2: Vector3, alpha: f32): Vector3 {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n\n    return this;\n  }\n\n  cross(v: Vector3): Vector3 {\n    return this.crossVectors(this, v);\n  }\n\n  crossVectors(a: Vector3, b: Vector3): Vector3 {\n    const ax = a.x,\n      ay = a.y,\n      az = a.z;\n    const bx = b.x,\n      by = b.y,\n      bz = b.z;\n\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n\n    return this;\n  }\n\n  projectOnVector(v: Vector3): Vector3 {\n    const denominator = v.lengthSq();\n\n    if (denominator === 0) return this.set(0, 0, 0);\n\n    const scalar = v.dot(this) / denominator;\n\n    return this.copy(v).multiplyScalar(scalar);\n  }\n\n  projectOnPlane(planeNormal: Vector3): Vector3 {\n    _vector.copy(this).projectOnVector(planeNormal);\n\n    return this.sub(_vector);\n  }\n\n  reflect(normal: Vector3): Vector3 {\n    // reflect incident vector off plane orthogonal to normal\n    // normal is assumed to have unit length\n\n    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));\n  }\n\n  angleTo(v: Vector3): f32 {\n    const denominator = Mathf.sqrt(this.lengthSq() * v.lengthSq());\n\n    if (denominator === 0) return Mathf.PI / 2;\n\n    const theta = this.dot(v) / denominator;\n\n    // clamp, to handle numerical problems\n\n    return Mathf.acos(MathUtils.clamp(theta, -1, 1));\n  }\n\n  distanceTo(v: Vector3): f32 {\n    return Mathf.sqrt(this.distanceToSquared(v));\n  }\n\n  distanceToSquared(v: Vector3): f32 {\n    const dx = this.x - v.x,\n      dy = this.y - v.y,\n      dz = this.z - v.z;\n\n    return dx * dx + dy * dy + dz * dz;\n  }\n\n  manhattanDistanceTo(v: Vector3): f32 {\n    return Mathf.abs(this.x - v.x) + Mathf.abs(this.y - v.y) + Mathf.abs(this.z - v.z);\n  }\n\n  setFromSpherical(s: Spherical): Vector3 {\n    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n  }\n\n  setFromSphericalCoords(radius: f32, phi: f32, theta: f32): Vector3 {\n    const sinPhiRadius = Mathf.sin(phi) * radius;\n\n    this.x = sinPhiRadius * Mathf.sin(theta);\n    this.y = Mathf.cos(phi) * radius;\n    this.z = sinPhiRadius * Mathf.cos(theta);\n\n    return this;\n  }\n\n  setFromCylindrical(c: Cylindrical): Vector3 {\n    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n  }\n\n  setFromCylindricalCoords(radius: f32, theta: f32, y: f32): Vector3 {\n    this.x = radius * Mathf.sin(theta);\n    this.y = y;\n    this.z = radius * Mathf.cos(theta);\n\n    return this;\n  }\n\n  setFromMatrixPosition(m: Matrix4): Vector3 {\n    const e = m.elements;\n\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n\n    return this;\n  }\n\n  setFromMatrixScale(m: Matrix4): Vector3 {\n    const sx = this.setFromMatrixColumn(m, 0).length();\n    const sy = this.setFromMatrixColumn(m, 1).length();\n    const sz = this.setFromMatrixColumn(m, 2).length();\n\n    this.x = sx;\n    this.y = sy;\n    this.z = sz;\n\n    return this;\n  }\n\n  setFromMatrixColumn(m: Matrix4, index: u32): Vector3 {\n    return this.fromF32Array(m.elements, index * 4);\n  }\n\n  setFromMatrix3Column(m: Matrix3, index: u32): Vector3 {\n    return this.fromF32Array(m.elements, index * 3);\n  }\n\n  equals(v: Vector3): boolean {\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n  }\n\n  fromArray(array: f32[], offset: u32 = 0): Vector3 {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n\n    return this;\n  }\n\n  fromF32Array(array: Float32Array, offset: u32 = 0): Vector3 {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n\n    return this;\n  }\n\n  toArray(array: f32[] = [], offset: u32 = 0): f32[] {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n\n    return array;\n  }\n\n  fromBufferAttribute(attribute: BufferAttribute<f32, Float32Array>, index: u32): Vector3 {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n\n    return this;\n  }\n\n  random(): Vector3 {\n    this.x = Mathf.random();\n    this.y = Mathf.random();\n    this.z = Mathf.random();\n\n    return this;\n  }\n}\n\nconst _vector = new Vector3();\nconst _quaternion = new Quaternion();\n","import { Vector4 } from \"../math/Vector4\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { Color } from \"../math/Color\";\nimport { UsageType } from \"../../common/GLEnums\";\nimport { Matrix3 } from \"../math/Matrix3\";\nimport { Matrix4 } from \"../math/Matrix4\";\n\nexport class CloneToken {}\nconst _vector = new Vector3();\nconst _vector2 = new Vector2();\nexport class UpdateRange {\n  offset: u32;\n  count: i32;\n\n  constructor() {\n    this.offset = 0;\n    this.count = -1;\n  }\n}\n\nexport type UploadCallback = () => void;\n\nexport abstract class BaseAttribute {\n  name: string;\n  itemSize: u32;\n  version: i32;\n  onUploadCallback: UploadCallback | null;\n  normalized: boolean;\n\n  constructor() {\n    this.name = \"\";\n    this.itemSize = 0;\n    this.onUploadCallback = null;\n    this.normalized = false;\n  }\n\n  abstract clone(data: CloneToken): BaseAttribute;\n\n  merge(source: BaseAttribute, offset: i32): BaseAttribute {\n    return this;\n  }\n\n  abstract convertBufferAttribute(indices: TypedArray<u32>): BaseAttribute;\n  abstract getUpdateRange(): UpdateRange | null;\n  abstract getArray(): ArrayBufferView;\n  abstract getUsage(): UsageType;\n}\n\nexport class BufferAttribute<K, T extends TypedArray<K>> extends BaseAttribute {\n  count: u32;\n  usage: UsageType;\n  array: T;\n  updateRange: UpdateRange;\n\n  constructor(array: T, itemSize: u32, normalized: boolean = false) {\n    super();\n    this.array = array;\n    this.itemSize = itemSize;\n    this.count = array.length / itemSize;\n    this.normalized = normalized === true;\n\n    this.usage = UsageType.STATIC_DRAW;\n    this.updateRange = new UpdateRange();\n\n    this.version = 0;\n  }\n\n  getUpdateRange(): UpdateRange | null {\n    return this.updateRange;\n  }\n\n  getArray(): ArrayBufferView {\n    return this.array;\n  }\n\n  getUsage(): UsageType {\n    return this.usage;\n  }\n\n  convertBufferAttribute(indices: TypedArray<u32>): BaseAttribute {\n    const array = this.array;\n    const itemSize = this.itemSize;\n    const normalized = this.normalized;\n\n    const array2 = array.slice(0) as T;\n\n    let index: i32 = 0,\n      index2: i32 = 0;\n\n    for (let i = 0, l = indices.length; i < l; i++) {\n      index = indices[i] * itemSize;\n\n      for (let j = 0; j < itemSize; j++) {\n        array2[index2++] = array[index++];\n      }\n    }\n\n    return new BufferAttribute<K, T>(array2, itemSize, normalized);\n  }\n\n  merge(sourceAttr: BaseAttribute, offset: i32): BaseAttribute {\n    const source = sourceAttr as BufferAttribute<K, T>;\n    if (!source) return this;\n\n    const attribute1 = this;\n    const attributeArray1 = attribute1.array;\n\n    const attribute2 = source;\n    const attributeArray2 = attribute2.array;\n\n    const attributeOffset: u32 = attribute2.itemSize * offset;\n    const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n    for (let i: i32 = 0, j: u32 = attributeOffset; i < length; i++, j++) {\n      attributeArray1[j] = attributeArray2[i];\n    }\n\n    // const attributeOffset: u32 = source.itemSize * offset;\n    // const length = Math.min(source.array.length, source.array.length - attributeOffset);\n\n    // for (let i: i32 = 0, j: u32 = attributeOffset; i < length; i++, j++) {\n    //   this.array[j] = source.array[i];\n    // }\n\n    return this;\n  }\n\n  set needsUpdate(value: boolean) {\n    if (value === true) this.version++;\n  }\n\n  setUsage(value: UsageType): BufferAttribute<K, T> {\n    this.usage = value;\n\n    return this;\n  }\n\n  copy(source: BufferAttribute<K, T>, array: T): BufferAttribute<K, T> {\n    this.name = source.name;\n    this.array = array;\n    this.itemSize = source.itemSize;\n    this.count = source.count;\n    this.normalized = source.normalized;\n\n    this.usage = source.usage;\n\n    return this;\n  }\n\n  copyAt(index1: u32, attribute: BufferAttribute<K, T>, index2: u32): BufferAttribute<K, T> {\n    index1 *= this.itemSize;\n    index2 *= attribute.itemSize;\n\n    for (let i = 0, l = this.itemSize; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n\n    return this;\n  }\n\n  copyArray(array: TypedArray<T>): BufferAttribute<K, T> {\n    this.array.set(array);\n\n    return this;\n  }\n\n  static copyColorsArray(\n    colors: Color[],\n    buffer: BufferAttribute<f32, Float32Array>\n  ): BufferAttribute<f32, Float32Array> {\n    const array = buffer.array;\n    let offset = 0;\n\n    for (let i = 0, l = colors.length; i < l; i++) {\n      let color = colors[i];\n      array[offset++] = color.r;\n      array[offset++] = color.g;\n      array[offset++] = color.b;\n    }\n\n    return buffer;\n  }\n\n  static copyVector2sArray(\n    vectors: Vector2[],\n    buffer: BufferAttribute<f32, Float32Array>\n  ): BufferAttribute<f32, Float32Array> {\n    const array = buffer.array;\n    let offset = 0;\n\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n    }\n\n    return buffer;\n  }\n\n  static copyVector3sArray(\n    vectors: Vector3[],\n    buffer: BufferAttribute<f32, Float32Array>\n  ): BufferAttribute<f32, Float32Array> {\n    const array = buffer.array;\n    let offset = 0;\n\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n      array[offset++] = vector.z;\n    }\n\n    return buffer;\n  }\n\n  static copyVector4sArray(\n    vectors: Vector4[],\n    buffer: BufferAttribute<f32, Float32Array>\n  ): BufferAttribute<f32, Float32Array> {\n    const array = buffer.array;\n    let offset = 0;\n\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n      array[offset++] = vector.z;\n      array[offset++] = vector.w;\n    }\n\n    return buffer;\n  }\n\n  static applyMatrix3(m: Matrix3, buffer: BufferAttribute<f32, Float32Array>): BufferAttribute<f32, Float32Array> {\n    if (buffer.itemSize === 2) {\n      for (let i = 0, l = buffer.count; i < l; i++) {\n        _vector2.fromBufferAttribute(buffer, i);\n        _vector2.applyMatrix3(m);\n\n        buffer.setXY(i, _vector2.x, _vector2.y);\n      }\n    } else if (buffer.itemSize === 3) {\n      for (let i = 0, l = buffer.count; i < l; i++) {\n        _vector.fromBufferAttribute(buffer, i);\n        _vector.applyMatrix3(m);\n\n        buffer.setXYZ(i, _vector.x, _vector.y, _vector.z);\n      }\n    }\n\n    return buffer;\n  }\n\n  static applyMatrix4(m: Matrix4, buffer: BufferAttribute<f32, Float32Array>): BufferAttribute<f32, Float32Array> {\n    for (let i: u32 = 0, l = buffer.count; i < l; i++) {\n      _vector.x = buffer.getX(i);\n      _vector.y = buffer.getY(i);\n      _vector.z = buffer.getZ(i);\n\n      _vector.applyMatrix4(m);\n\n      buffer.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n\n    return buffer;\n  }\n\n  static applyNormalMatrix(m: Matrix3, buffer: BufferAttribute<f32, Float32Array>): BufferAttribute<f32, Float32Array> {\n    for (let i: u32 = 0, l = buffer.count; i < l; i++) {\n      _vector.x = buffer.getX(i);\n      _vector.y = buffer.getY(i);\n      _vector.z = buffer.getZ(i);\n\n      _vector.applyNormalMatrix(m);\n\n      buffer.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n\n    return buffer;\n  }\n\n  static transformDirection(\n    m: Matrix4,\n    buffer: BufferAttribute<f32, Float32Array>\n  ): BufferAttribute<f32, Float32Array> {\n    for (let i: u32 = 0, l = buffer.count; i < l; i++) {\n      _vector.x = buffer.getX(i);\n      _vector.y = buffer.getY(i);\n      _vector.z = buffer.getZ(i);\n\n      _vector.transformDirection(m);\n\n      buffer.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n\n    return buffer;\n  }\n\n  set(value: ArrayBufferView, offset = 0): BufferAttribute<K, T> {\n    this.array.set(value, offset);\n\n    return this;\n  }\n\n  getX(index: u32): K {\n    return this.array[index * this.itemSize];\n  }\n\n  setX(index: u32, x: K): BufferAttribute<K, T> {\n    this.array[index * this.itemSize] = x;\n\n    return this;\n  }\n\n  getY(index: u32): K {\n    return this.array[index * this.itemSize + 1];\n  }\n\n  setY(index: u32, y: K): BufferAttribute<K, T> {\n    this.array[index * this.itemSize + 1] = y;\n\n    return this;\n  }\n\n  getZ(index: u32): K {\n    return this.array[index * this.itemSize + 2];\n  }\n\n  setZ(index: u32, z: K): BufferAttribute<K, T> {\n    this.array[index * this.itemSize + 2] = z;\n\n    return this;\n  }\n\n  getW(index: u32): K {\n    return this.array[index * this.itemSize + 3];\n  }\n\n  setW(index: u32, w: K): BufferAttribute<K, T> {\n    this.array[index * this.itemSize + 3] = w;\n\n    return this;\n  }\n\n  setXY(index: u32, x: K, y: K): BufferAttribute<K, T> {\n    index *= this.itemSize;\n\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n\n    return this;\n  }\n\n  setXYZ(index: u32, x: K, y: K, z: K): BufferAttribute<K, T> {\n    index *= this.itemSize;\n\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n\n    return this;\n  }\n\n  setXYZW(index: u32, x: K, y: K, z: K, w: K): BufferAttribute<K, T> {\n    index *= this.itemSize;\n\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    this.array[index + 3] = w;\n\n    return this;\n  }\n\n  onUpload(callback: UploadCallback | null): BufferAttribute<K, T> {\n    this.onUploadCallback = callback;\n\n    return this;\n  }\n\n  clone(token: CloneToken | null): BufferAttribute<K, T> {\n    return new BufferAttribute<K, T>(this.array, this.itemSize, this.normalized).copy(this, this.array.slice(0) as T);\n  }\n\n  // TODO:\n  //   toJSON() {\n  //     const data = {\n  //       itemSize: this.itemSize,\n  //       type: this.array.constructor.name,\n  //       array: Array.prototype.slice.call(this.array),\n  //       normalized: this.normalized,\n  //     };\n\n  //     if (this.name !== \"\") data.name = this.name;\n  //     if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n  //     if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)\n  //       data.updateRange = this.updateRange;\n\n  //     return data;\n  //   }\n}\n\n//\n\nexport class Int8BufferAttribute extends BufferAttribute<i8, Int8Array> {\n  constructor(array: Int8Array, itemSize: u32, normalized: boolean = false) {\n    super(array, itemSize, normalized);\n  }\n}\n\nexport class Uint8BufferAttribute extends BufferAttribute<u8, Uint8Array> {\n  constructor(array: Uint8Array, itemSize: u32, normalized: boolean = false) {\n    super(array, itemSize, normalized);\n  }\n}\n\nexport class Uint8ClampedBufferAttribute extends BufferAttribute<u8, Uint8ClampedArray> {\n  constructor(array: Uint8ClampedArray, itemSize: u32, normalized: boolean = false) {\n    super(array, itemSize, normalized);\n  }\n}\n\nexport class Int16BufferAttribute extends BufferAttribute<i16, Int16Array> {\n  constructor(array: Int16Array, itemSize: u32, normalized: boolean = false) {\n    super(array, itemSize, normalized);\n  }\n}\n\nexport class Uint16BufferAttribute extends BufferAttribute<u16, Uint16Array> {\n  constructor(array: Uint16Array, itemSize: u32, normalized: boolean = false) {\n    super(array, itemSize, normalized);\n  }\n}\n\nexport class Int32BufferAttribute extends BufferAttribute<i32, Int32Array> {\n  constructor(array: Int32Array, itemSize: u32, normalized: boolean = false) {\n    super(array, itemSize, normalized);\n  }\n}\n\nexport class Uint32BufferAttribute extends BufferAttribute<u32, Uint32Array> {\n  constructor(array: Uint32Array, itemSize: u32, normalized: boolean = false) {\n    super(array, itemSize, normalized);\n  }\n}\n\nexport class Float16BufferAttribute extends BufferAttribute<u16, Uint16Array> {\n  constructor(array: Uint16Array, itemSize: u32, normalized: boolean) {\n    super(array, itemSize, normalized);\n  }\n}\n\nexport class Float32BufferAttribute extends BufferAttribute<f32, Float32Array> {\n  constructor(array: Float32Array, itemSize: u32, normalized: boolean = false) {\n    super(array, itemSize, normalized);\n  }\n}\n\nexport class Float64BufferAttribute extends BufferAttribute<f64, Float64Array> {\n  constructor(array: Float64Array, itemSize: u32, normalized: boolean = false) {\n    super(array, itemSize, normalized);\n  }\n}\n","import { BufferAttribute } from \"../core/BufferAttribute\";\nimport { Matrix3 } from \"./Matrix3\";\n\nexport class Vector2 {\n  isVector2: boolean = true;\n  x: f32;\n  y: f32;\n\n  constructor(x: f32 = 0, y: f32 = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  get width(): f32 {\n    return this.x;\n  }\n\n  set width(value: f32) {\n    this.x = value;\n  }\n\n  get height(): f32 {\n    return this.y;\n  }\n\n  set height(value: f32) {\n    this.y = value;\n  }\n\n  set(x: f32, y: f32): Vector2 {\n    this.x = x;\n    this.y = y;\n\n    return this;\n  }\n\n  setScalar(scalar: f32): Vector2 {\n    this.x = scalar;\n    this.y = scalar;\n\n    return this;\n  }\n\n  setX(x: f32): Vector2 {\n    this.x = x;\n\n    return this;\n  }\n\n  setY(y: f32): Vector2 {\n    this.y = y;\n\n    return this;\n  }\n\n  setComponent(index: u32, value: f32): Vector2 {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n\n    return this;\n  }\n\n  getComponent(index: u32): f32 {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n  }\n\n  clone(): Vector2 {\n    return new Vector2(this.x, this.y);\n  }\n\n  copy(v: Vector2): Vector2 {\n    this.x = v.x;\n    this.y = v.y;\n\n    return this;\n  }\n\n  add(v: Vector2): Vector2 {\n    this.x += v.x;\n    this.y += v.y;\n\n    return this;\n  }\n\n  addScalar(s: f32): Vector2 {\n    this.x += s;\n    this.y += s;\n\n    return this;\n  }\n\n  addVectors(a: Vector2, b: Vector2): Vector2 {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n\n    return this;\n  }\n\n  addScaledVector(v: Vector2, s: f32): Vector2 {\n    this.x += v.x * s;\n    this.y += v.y * s;\n\n    return this;\n  }\n\n  sub(v: Vector2): Vector2 {\n    this.x -= v.x;\n    this.y -= v.y;\n\n    return this;\n  }\n\n  subScalar(s: f32): Vector2 {\n    this.x -= s;\n    this.y -= s;\n\n    return this;\n  }\n\n  subVectors(a: Vector2, b: Vector2): Vector2 {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n\n    return this;\n  }\n\n  multiply(v: Vector2): Vector2 {\n    this.x *= v.x;\n    this.y *= v.y;\n\n    return this;\n  }\n\n  multiplyScalar(scalar: f32): Vector2 {\n    this.x *= scalar;\n    this.y *= scalar;\n\n    return this;\n  }\n\n  divide(v: Vector2): Vector2 {\n    this.x /= v.x;\n    this.y /= v.y;\n\n    return this;\n  }\n\n  divideScalar(scalar: f32): Vector2 {\n    return this.multiplyScalar(1 / scalar);\n  }\n\n  applyMatrix3(m: Matrix3): Vector2 {\n    const x = this.x,\n      y = this.y;\n    const e = m.elements;\n\n    this.x = e[0] * x + e[3] * y + e[6];\n    this.y = e[1] * x + e[4] * y + e[7];\n\n    return this;\n  }\n\n  min(v: Vector2): Vector2 {\n    this.x = Mathf.min(this.x, v.x);\n    this.y = Mathf.min(this.y, v.y);\n\n    return this;\n  }\n\n  max(v: Vector2): Vector2 {\n    this.x = Mathf.max(this.x, v.x);\n    this.y = Mathf.max(this.y, v.y);\n\n    return this;\n  }\n\n  clamp(min: Vector2, max: Vector2): Vector2 {\n    // assumes min < max, componentwise\n\n    this.x = Mathf.max(min.x, Mathf.min(max.x, this.x));\n    this.y = Mathf.max(min.y, Mathf.min(max.y, this.y));\n\n    return this;\n  }\n\n  clampScalar(minVal: f32, maxVal: f32): Vector2 {\n    this.x = Mathf.max(minVal, Mathf.min(maxVal, this.x));\n    this.y = Mathf.max(minVal, Mathf.min(maxVal, this.y));\n\n    return this;\n  }\n\n  clampLength(min: f32, max: f32): Vector2 {\n    const length = this.length();\n\n    return this.divideScalar(length || 1).multiplyScalar(Mathf.max(min, Mathf.min(max, length)));\n  }\n\n  floor(): Vector2 {\n    this.x = Mathf.floor(this.x);\n    this.y = Mathf.floor(this.y);\n\n    return this;\n  }\n\n  ceil(): Vector2 {\n    this.x = Mathf.ceil(this.x);\n    this.y = Mathf.ceil(this.y);\n\n    return this;\n  }\n\n  round(): Vector2 {\n    this.x = Mathf.round(this.x);\n    this.y = Mathf.round(this.y);\n\n    return this;\n  }\n\n  roundToZero(): Vector2 {\n    this.x = this.x < 0 ? Mathf.ceil(this.x) : Mathf.floor(this.x);\n    this.y = this.y < 0 ? Mathf.ceil(this.y) : Mathf.floor(this.y);\n\n    return this;\n  }\n\n  negate(): Vector2 {\n    this.x = -this.x;\n    this.y = -this.y;\n\n    return this;\n  }\n\n  dot(v: Vector2): f32 {\n    return this.x * v.x + this.y * v.y;\n  }\n\n  cross(v: Vector2): f32 {\n    return this.x * v.y - this.y * v.x;\n  }\n\n  lengthSq(): f32 {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  length(): f32 {\n    return Mathf.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  manhattanLength(): f32 {\n    return Mathf.abs(this.x) + Mathf.abs(this.y);\n  }\n\n  normalize(): Vector2 {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  angle(): f32 {\n    // computes the angle in radians with respect to the positive x-axis\n    const angle = Mathf.atan2(-this.y, -this.x) + Mathf.PI;\n    return angle;\n  }\n\n  distanceTo(v: Vector2): f32 {\n    return Mathf.sqrt(this.distanceToSquared(v));\n  }\n\n  distanceToSquared(v: Vector2): f32 {\n    const dx = this.x - v.x,\n      dy = this.y - v.y;\n    return dx * dx + dy * dy;\n  }\n\n  manhattanDistanceTo(v: Vector2): f32 {\n    return Mathf.abs(this.x - v.x) + Mathf.abs(this.y - v.y);\n  }\n\n  setLength(length: f32): Vector2 {\n    return this.normalize().multiplyScalar(length);\n  }\n\n  lerp(v: Vector2, alpha: f32): Vector2 {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n\n    return this;\n  }\n\n  lerpVectors(v1: Vector2, v2: Vector2, alpha: f32): Vector2 {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n\n    return this;\n  }\n\n  equals(v: Vector2): boolean {\n    return v.x === this.x && v.y === this.y;\n  }\n\n  fromArray(array: Float32Array, offset: u32 = 0): Vector2 {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n\n    return this;\n  }\n\n  toArray(array: f32[] = [], offset: u32 = 0): f32[] {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n\n    return array;\n  }\n\n  fromBufferAttribute(attribute: BufferAttribute<f32, Float32Array>, index: u32): Vector2 {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n\n    return this;\n  }\n\n  rotateAround(center: Vector2, angle: f32): Vector2 {\n    const c = Mathf.cos(angle),\n      s = Mathf.sin(angle);\n\n    const x = this.x - center.x;\n    const y = this.y - center.y;\n\n    this.x = x * c - y * s + center.x;\n    this.y = x * s + y * c + center.y;\n\n    return this;\n  }\n\n  random(): Vector2 {\n    this.x = Mathf.random();\n    this.y = Mathf.random();\n\n    return this;\n  }\n}\n","import { Euler, EulerRotationOrder } from \"./Euler\";\nimport * as MathUtils from \"./MathUtils\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Vector3 } from \"./Vector3\";\nimport { Object } from \"../core/Object\";\n\nexport class Quaternion {\n  _x: f32;\n  _y: f32;\n  _z: f32;\n  _w: f32;\n\n  isQuaternion: boolean = true;\n  _onChangeCallback: Object | null;\n\n  constructor(x: f32 = 0, y: f32 = 0, z: f32 = 0, w: f32 = 1) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n    this._onChangeCallback = null;\n  }\n\n  static slerp(qa: Quaternion, qb: Quaternion, qm: Quaternion, t: f32): void {\n    return qm.slerpQuaternions(qa, qb, t);\n  }\n\n  static slerpFlat(\n    dst: f32[],\n    dstOffset: u32,\n    src0: f32[],\n    srcOffset0: u32,\n    src1: f32[],\n    srcOffset1: u32,\n    t: f32\n  ): void {\n    // fuzz-free, array-based Quaternion SLERP operation\n\n    let x0 = src0[srcOffset0 + 0],\n      y0 = src0[srcOffset0 + 1],\n      z0 = src0[srcOffset0 + 2],\n      w0 = src0[srcOffset0 + 3];\n\n    const x1 = src1[srcOffset1 + 0],\n      y1 = src1[srcOffset1 + 1],\n      z1 = src1[srcOffset1 + 2],\n      w1 = src1[srcOffset1 + 3];\n\n    if (t === 0) {\n      dst[dstOffset + 0] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n      return;\n    }\n\n    if (t === 1) {\n      dst[dstOffset + 0] = x1;\n      dst[dstOffset + 1] = y1;\n      dst[dstOffset + 2] = z1;\n      dst[dstOffset + 3] = w1;\n      return;\n    }\n\n    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n      let s = 1 - t;\n      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n        dir = cos >= 0 ? 1 : -1,\n        sqrSin = 1 - cos * cos;\n\n      // Skip the Slerp for tiny steps to avoid numeric problems:\n      if (sqrSin > f32.EPSILON) {\n        const sin = Mathf.sqrt(sqrSin),\n          len = Mathf.atan2(sin, cos * dir);\n\n        s = Mathf.sin(s * len) / sin;\n        t = Mathf.sin(t * len) / sin;\n      }\n\n      const tDir = t * dir;\n\n      x0 = x0 * s + x1 * tDir;\n      y0 = y0 * s + y1 * tDir;\n      z0 = z0 * s + z1 * tDir;\n      w0 = w0 * s + w1 * tDir;\n\n      // Normalize in case we just did a lerp:\n      if (s === 1 - t) {\n        const f = 1 / Mathf.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n\n        x0 *= f;\n        y0 *= f;\n        z0 *= f;\n        w0 *= f;\n      }\n    }\n\n    dst[dstOffset] = x0;\n    dst[dstOffset + 1] = y0;\n    dst[dstOffset + 2] = z0;\n    dst[dstOffset + 3] = w0;\n  }\n\n  static multiplyQuaternionsFlat(\n    dst: f32[],\n    dstOffset: u32,\n    src0: f32[],\n    srcOffset0: u32,\n    src1: f32[],\n    srcOffset1: u32\n  ): f32[] {\n    const x0 = src0[srcOffset0];\n    const y0 = src0[srcOffset0 + 1];\n    const z0 = src0[srcOffset0 + 2];\n    const w0 = src0[srcOffset0 + 3];\n\n    const x1 = src1[srcOffset1];\n    const y1 = src1[srcOffset1 + 1];\n    const z1 = src1[srcOffset1 + 2];\n    const w1 = src1[srcOffset1 + 3];\n\n    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n    return dst;\n  }\n\n  get x(): f32 {\n    return this._x;\n  }\n\n  set x(value: f32) {\n    this._x = value;\n    this.onChangeCallback();\n  }\n\n  get y(): f32 {\n    return this._y;\n  }\n\n  set y(value: f32) {\n    this._y = value;\n    this.onChangeCallback();\n  }\n\n  get z(): f32 {\n    return this._z;\n  }\n\n  set z(value: f32) {\n    this._z = value;\n    this.onChangeCallback();\n  }\n\n  get w(): f32 {\n    return this._w;\n  }\n\n  set w(value: f32) {\n    this._w = value;\n    this.onChangeCallback();\n  }\n\n  set(x: f32, y: f32, z: f32, w: f32): Quaternion {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  clone(): Quaternion {\n    return new Quaternion(this._x, this._y, this._z, this._w);\n  }\n\n  copy(quaternion: Quaternion): Quaternion {\n    this._x = quaternion.x;\n    this._y = quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  setFromEuler(euler: Euler, update: boolean): Quaternion {\n    const x = euler._x,\n      y = euler._y,\n      z = euler._z,\n      order = euler._order;\n\n    // http://www.mathworks.com/matlabcentral/fileexchange/\n    // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n    //\tcontent/SpinCalc.m\n\n    const cos = Mathf.cos;\n    const sin = Mathf.sin;\n\n    const c1 = cos(x / 2);\n    const c2 = cos(y / 2);\n    const c3 = cos(z / 2);\n\n    const s1 = sin(x / 2);\n    const s2 = sin(y / 2);\n    const s3 = sin(z / 2);\n\n    switch (order) {\n      case EulerRotationOrder.XYZ:\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case EulerRotationOrder.YXZ:\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      case EulerRotationOrder.ZXY:\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case EulerRotationOrder.ZYX:\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      case EulerRotationOrder.YZX:\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n\n      case EulerRotationOrder.XZY:\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n\n      default:\n        throw new Error(\"Quaternion: .setFromEuler() encountered an unknown order\");\n    }\n\n    if (update !== false) this.onChangeCallback();\n\n    return this;\n  }\n\n  setFromAxisAngle(axis: Vector3, angle: f32): Quaternion {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n    // assumes axis is normalized\n\n    const halfAngle: f32 = angle / 2,\n      s: f32 = Mathf.sin(halfAngle);\n\n    this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n    this._w = Mathf.cos(halfAngle);\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  setFromRotationMatrix(m: Matrix4): Quaternion {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    const te = m.elements,\n      m11: f32 = te[0],\n      m12: f32 = te[4],\n      m13: f32 = te[8],\n      m21: f32 = te[1],\n      m22: f32 = te[5],\n      m23: f32 = te[9],\n      m31: f32 = te[2],\n      m32: f32 = te[6],\n      m33: f32 = te[10],\n      trace: f32 = m11 + m22 + m33;\n\n    if (trace > 0) {\n      const s: f32 = 0.5 / Mathf.sqrt(trace + 1.0);\n\n      this._w = 0.25 / s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      const s: f32 = 2.0 * Mathf.sqrt(1.0 + m11 - m22 - m33);\n\n      this._w = (m32 - m23) / s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      const s: f32 = 2.0 * Mathf.sqrt(1.0 + m22 - m11 - m33);\n\n      this._w = (m13 - m31) / s;\n      this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + m32) / s;\n    } else {\n      const s: f32 = 2.0 * Mathf.sqrt(1.0 + m33 - m11 - m22);\n\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n      this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n\n    this.onChangeCallback();\n    return this;\n  }\n\n  setFromUnitVectors(vFrom: Vector3, vTo: Vector3): Quaternion {\n    // assumes direction vectors vFrom and vTo are normalized\n\n    let r = vFrom.dot(vTo) + 1;\n\n    if (r < f32.EPSILON) {\n      // vFrom and vTo point in opposite directions\n\n      r = 0;\n\n      if (Mathf.abs(vFrom.x) > Mathf.abs(vFrom.z)) {\n        this._x = -vFrom.y;\n        this._y = vFrom.x;\n        this._z = 0;\n        this._w = r;\n      } else {\n        this._x = 0;\n        this._y = -vFrom.z;\n        this._z = vFrom.y;\n        this._w = r;\n      }\n    } else {\n      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n      this._w = r;\n    }\n\n    return this.normalize();\n  }\n\n  angleTo(q: Quaternion): f32 {\n    return 2 * Mathf.acos(Mathf.abs(MathUtils.clamp(this.dot(q), -1, 1)));\n  }\n\n  rotateTowards(q: Quaternion, step: f32): Quaternion {\n    const angle = this.angleTo(q);\n\n    if (angle === 0) return this;\n\n    const t = Mathf.min(1, step / angle);\n\n    this.slerp(q, t);\n\n    return this;\n  }\n\n  identity(): Quaternion {\n    return this.set(0, 0, 0, 1);\n  }\n\n  invert(): Quaternion {\n    // quaternion is assumed to have unit length\n\n    return this.conjugate();\n  }\n\n  conjugate(): Quaternion {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  dot(v: Quaternion): f32 {\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  }\n\n  lengthSq(): f32 {\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n  }\n\n  length(): f32 {\n    return Mathf.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  }\n\n  normalize(): Quaternion {\n    let l = this.length();\n\n    if (l === 0) {\n      this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    } else {\n      l = 1 / l;\n\n      this._x = this._x * l;\n      this._y = this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    }\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  multiply(q: Quaternion): Quaternion {\n    return this.multiplyQuaternions(this, q);\n  }\n\n  premultiply(q: Quaternion): Quaternion {\n    return this.multiplyQuaternions(q, this);\n  }\n\n  multiplyQuaternions(a: Quaternion, b: Quaternion): Quaternion {\n    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n    const qax = a._x,\n      qay = a._y,\n      qaz = a._z,\n      qaw = a._w;\n    const qbx = b._x,\n      qby = b._y,\n      qbz = b._z,\n      qbw = b._w;\n\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  slerp(qb: Quaternion, t: f32): Quaternion {\n    if (t === 0) return this;\n    if (t === 1) return this.copy(qb);\n\n    const x = this._x,\n      y = this._y,\n      z = this._z,\n      w = this._w;\n\n    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n    if (cosHalfTheta < 0) {\n      this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n      this._z = -qb._z;\n\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      this.copy(qb);\n    }\n\n    if (cosHalfTheta >= 1.0) {\n      this._w = w;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n\n      return this;\n    }\n\n    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n    if (sqrSinHalfTheta <= f32.EPSILON) {\n      const s = 1 - t;\n      this._w = s * w + t * this._w;\n      this._x = s * x + t * this._x;\n      this._y = s * y + t * this._y;\n      this._z = s * z + t * this._z;\n\n      this.normalize();\n      this.onChangeCallback();\n\n      return this;\n    }\n\n    const sinHalfTheta = Mathf.sqrt(sqrSinHalfTheta);\n    const halfTheta = Mathf.atan2(sinHalfTheta, cosHalfTheta);\n    const ratioA = Mathf.sin((1 - t) * halfTheta) / sinHalfTheta,\n      ratioB = Mathf.sin(t * halfTheta) / sinHalfTheta;\n\n    this._w = w * ratioA + this._w * ratioB;\n    this._x = x * ratioA + this._x * ratioB;\n    this._y = y * ratioA + this._y * ratioB;\n    this._z = z * ratioA + this._z * ratioB;\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  slerpQuaternions(qa: Quaternion, qb: Quaternion, t: f32): void {\n    this.copy(qa).slerp(qb, t);\n  }\n\n  equals(quaternion: Quaternion): boolean {\n    return (\n      quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w\n    );\n  }\n\n  fromArray(array: f32[], offset: u32 = 0): Quaternion {\n    this._x = array[offset];\n    this._y = array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = array[offset + 3];\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  toArray(array: f32[] = [], offset: u32 = 0): f32[] {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._w;\n\n    return array;\n  }\n\n  // TODO:\n  //   fromBufferAttribute(attribute, index) {\n  //     this._x = attribute.getX(index);\n  //     this._y = attribute.getY(index);\n  //     this._z = attribute.getZ(index);\n  //     this._w = attribute.getW(index);\n\n  //     return this;\n  //   }\n\n  private onChangeCallback(): void {\n    if (this._onChangeCallback) this._onChangeCallback!.onQuatChanged(this);\n  }\n\n  _onChange(callback: Object): Quaternion {\n    this._onChangeCallback = callback;\n\n    return this;\n  }\n}\n","import { Vector3 } from \"./Vector3\";\nimport * as MathUtils from \"./MathUtils\";\nimport { Matrix4 } from \"./Matrix4\";\n\nconst _startP = new Vector3();\nconst _startEnd = new Vector3();\n\nexport class Line3 {\n  start: Vector3;\n  end: Vector3;\n\n  constructor(start: Vector3 = new Vector3(), end: Vector3 = new Vector3()) {\n    this.start = start;\n    this.end = end;\n  }\n\n  set(start: Vector3, end: Vector3): Line3 {\n    this.start.copy(start);\n    this.end.copy(end);\n\n    return this;\n  }\n\n  copy(line: Line3): Line3 {\n    this.start.copy(line.start);\n    this.end.copy(line.end);\n\n    return this;\n  }\n\n  getCenter(target: Vector3): Vector3 {\n    return target.addVectors(this.start, this.end).multiplyScalar(0.5);\n  }\n\n  delta(target: Vector3): Vector3 {\n    return target.subVectors(this.end, this.start);\n  }\n\n  distanceSq(): f32 {\n    return this.start.distanceToSquared(this.end);\n  }\n\n  distance(): f32 {\n    return this.start.distanceTo(this.end);\n  }\n\n  at(t: f32, target: Vector3): Vector3 {\n    return this.delta(target).multiplyScalar(t).add(this.start);\n  }\n\n  closestPointToPointParameter(point: Vector3, clampToLine: boolean): f32 {\n    _startP.subVectors(point, this.start);\n    _startEnd.subVectors(this.end, this.start);\n\n    const startEnd2: f32 = _startEnd.dot(_startEnd);\n    const startEnd_startP: f32 = _startEnd.dot(_startP);\n\n    let t = startEnd_startP / startEnd2;\n\n    if (clampToLine) {\n      t = MathUtils.clamp(t, 0, 1);\n    }\n\n    return t;\n  }\n\n  closestPointToPoint(point: Vector3, clampToLine: boolean, target: Vector3): Vector3 {\n    const t = this.closestPointToPointParameter(point, clampToLine);\n\n    if (target === undefined) {\n      console.warn(\"THREE.Line3: .closestPointToPoint() target is now required\");\n      target = new Vector3();\n    }\n\n    return this.delta(target).multiplyScalar(t).add(this.start);\n  }\n\n  applyMatrix4(matrix: Matrix4): Line3 {\n    this.start.applyMatrix4(matrix);\n    this.end.applyMatrix4(matrix);\n\n    return this;\n  }\n\n  equals(line: Line3): boolean {\n    return line.start.equals(this.start) && line.end.equals(this.end);\n  }\n\n  clone(): Line3 {\n    return new Line3().copy(this);\n  }\n}\n","import { Box3 } from \"./Box3\";\nimport { Line3 } from \"./Line\";\nimport { Matrix3 } from \"./Matrix3\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Sphere } from \"./Sphere\";\nimport { Vector3 } from \"./Vector3\";\n\nconst _vector1 = new Vector3();\nconst _vector2 = new Vector3();\nconst _normalMatrix = new Matrix3();\n\nexport class Plane {\n  isPlane: boolean = true;\n  normal: Vector3;\n  constant: f32;\n\n  constructor(normal: Vector3 = new Vector3(1, 0, 0), constant: f32 = 0) {\n    // normal is assumed to be normalized\n\n    this.normal = normal;\n    this.constant = constant;\n  }\n\n  set(normal: Vector3, constant: f32): Plane {\n    this.normal.copy(normal);\n    this.constant = constant;\n\n    return this;\n  }\n\n  setComponents(x: f32, y: f32, z: f32, w: f32): Plane {\n    this.normal.set(x, y, z);\n    this.constant = w;\n\n    return this;\n  }\n\n  setFromNormalAndCoplanarPoint(normal: Vector3, point: Vector3): Plane {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n\n    return this;\n  }\n\n  setFromCoplanarPoints(a: Vector3, b: Vector3, c: Vector3): Plane {\n    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();\n\n    // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n    this.setFromNormalAndCoplanarPoint(normal, a);\n\n    return this;\n  }\n\n  copy(plane: Plane): Plane {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n\n    return this;\n  }\n\n  normalize(): Plane {\n    // Note: will lead to a divide by zero if the plane is invalid.\n\n    const inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n\n    return this;\n  }\n\n  negate(): Plane {\n    this.constant *= -1;\n    this.normal.negate();\n\n    return this;\n  }\n\n  distanceToPoint(point: Vector3): f32 {\n    return this.normal.dot(point) + this.constant;\n  }\n\n  distanceToSphere(sphere: Sphere): f32 {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n\n  projectPoint(point: Vector3, target: Vector3): Vector3 {\n    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n  }\n\n  intersectLine(line: Line3, target: Vector3 = new Vector3()): Vector3 | null {\n    const direction = line.delta(_vector1);\n\n    const denominator = this.normal.dot(direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      }\n\n      // Unsure if this is the correct method to handle this case.\n      return null;\n    }\n\n    const t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n    if (t < 0 || t > 1) {\n      return null;\n    }\n\n    return target.copy(direction).multiplyScalar(t).add(line.start);\n  }\n\n  intersectsLine(line: Line3): boolean {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n    const startSign = this.distanceToPoint(line.start);\n    const endSign = this.distanceToPoint(line.end);\n\n    return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);\n  }\n\n  intersectsBox(box: Box3): boolean {\n    return box.intersectsPlane(this);\n  }\n\n  intersectsSphere(sphere: Sphere): boolean {\n    return sphere.intersectsPlane(this);\n  }\n\n  coplanarPoint(target: Vector3 = new Vector3()): Vector3 {\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n\n  applyMatrix4(matrix: Matrix4, optionalNormalMatrix: Matrix3): Plane {\n    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n\n    const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n\n    this.constant = -referencePoint.dot(normal);\n\n    return this;\n  }\n\n  translate(offset: Vector3): Plane {\n    this.constant -= offset.dot(this.normal);\n\n    return this;\n  }\n\n  equals(plane: Plane): boolean {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n\n  clone(): Plane {\n    return new Plane().copy(this);\n  }\n}\n","import { Matrix4 } from \"./Matrix4\";\nimport { Vector3 } from \"./Vector3\";\nimport { f32Array } from \"../utils\";\nexport class Matrix3 {\n  isMatrix3: boolean = true;\n  elements: Float32Array;\n\n  constructor() {\n    this.elements = f32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n  }\n\n  set(n11: f32, n12: f32, n13: f32, n21: f32, n22: f32, n23: f32, n31: f32, n32: f32, n33: f32): Matrix3 {\n    const te = this.elements;\n\n    te[0] = n11;\n    te[1] = n21;\n    te[2] = n31;\n    te[3] = n12;\n    te[4] = n22;\n    te[5] = n32;\n    te[6] = n13;\n    te[7] = n23;\n    te[8] = n33;\n\n    return this;\n  }\n\n  identity(): Matrix3 {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  copy(m: Matrix3): Matrix3 {\n    const te = this.elements;\n    const me = m.elements;\n\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n\n    return this;\n  }\n\n  extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix3 {\n    xAxis.setFromMatrix3Column(this, 0);\n    yAxis.setFromMatrix3Column(this, 1);\n    zAxis.setFromMatrix3Column(this, 2);\n\n    return this;\n  }\n\n  setFromMatrix4(m: Matrix4): Matrix3 {\n    const me = m.elements;\n\n    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n\n    return this;\n  }\n\n  multiply(m: Matrix3): Matrix3 {\n    return this.multiplyMatrices(this, m);\n  }\n\n  premultiply(m: Matrix3): Matrix3 {\n    return this.multiplyMatrices(m, this);\n  }\n\n  multiplyMatrices(a: Matrix3, b: Matrix3): Matrix3 {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n\n    const a11 = ae[0],\n      a12 = ae[3],\n      a13 = ae[6];\n    const a21 = ae[1],\n      a22 = ae[4],\n      a23 = ae[7];\n    const a31 = ae[2],\n      a32 = ae[5],\n      a33 = ae[8];\n\n    const b11 = be[0],\n      b12 = be[3],\n      b13 = be[6];\n    const b21 = be[1],\n      b22 = be[4],\n      b23 = be[7];\n    const b31 = be[2],\n      b32 = be[5],\n      b33 = be[8];\n\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n    te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n    te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n    te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n    te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n    te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n    te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n    return this;\n  }\n\n  multiplyScalar(s: f32): Matrix3 {\n    const te = this.elements;\n\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] *= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n    te[8] *= s;\n\n    return this;\n  }\n\n  determinant(): f32 {\n    const te = this.elements;\n\n    const a = te[0],\n      b = te[1],\n      c = te[2],\n      d = te[3],\n      e = te[4],\n      f = te[5],\n      g = te[6],\n      h = te[7],\n      i = te[8];\n\n    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n  }\n\n  invert(): Matrix3 {\n    const te = this.elements,\n      n11: f32 = te[0],\n      n21: f32 = te[1],\n      n31: f32 = te[2],\n      n12: f32 = te[3],\n      n22: f32 = te[4],\n      n32: f32 = te[5],\n      n13: f32 = te[6],\n      n23: f32 = te[7],\n      n33: f32 = te[8],\n      t11: f32 = n33 * n22 - n32 * n23,\n      t12: f32 = n32 * n13 - n33 * n12,\n      t13: f32 = n23 * n12 - n22 * n13,\n      det: f32 = n11 * t11 + n21 * t12 + n31 * t13;\n\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n    const detInv: f32 = 1 / det;\n\n    te[0] = t11 * detInv;\n    te[1] = (n31 * n23 - n33 * n21) * detInv;\n    te[2] = (n32 * n21 - n31 * n22) * detInv;\n\n    te[3] = t12 * detInv;\n    te[4] = (n33 * n11 - n31 * n13) * detInv;\n    te[5] = (n31 * n12 - n32 * n11) * detInv;\n\n    te[6] = t13 * detInv;\n    te[7] = (n21 * n13 - n23 * n11) * detInv;\n    te[8] = (n22 * n11 - n21 * n12) * detInv;\n\n    return this;\n  }\n\n  transpose(): Matrix3 {\n    let tmp: f32;\n    const m = this.elements;\n\n    tmp = m[1];\n    m[1] = m[3];\n    m[3] = tmp;\n    tmp = m[2];\n    m[2] = m[6];\n    m[6] = tmp;\n    tmp = m[5];\n    m[5] = m[7];\n    m[7] = tmp;\n\n    return this;\n  }\n\n  getNormalMatrix(matrix4: Matrix4): Matrix3 {\n    return this.setFromMatrix4(matrix4).invert().transpose();\n  }\n\n  transposeIntoArray(r: f32[]): Matrix3 {\n    const m = this.elements;\n\n    r[0] = m[0];\n    r[1] = m[3];\n    r[2] = m[6];\n    r[3] = m[1];\n    r[4] = m[4];\n    r[5] = m[7];\n    r[6] = m[2];\n    r[7] = m[5];\n    r[8] = m[8];\n\n    return this;\n  }\n\n  setUvTransform(tx: f32, ty: f32, sx: f32, sy: f32, rotation: f32, cx: f32, cy: f32): Matrix3 {\n    const c: f32 = Mathf.cos(rotation);\n    const s: f32 = Mathf.sin(rotation);\n\n    this.set(\n      sx * c,\n      sx * s,\n      -sx * (c * cx + s * cy) + cx + tx,\n      -sy * s,\n      sy * c,\n      -sy * (-s * cx + c * cy) + cy + ty,\n      0,\n      0,\n      1\n    );\n\n    return this;\n  }\n\n  scale(sx: f32, sy: f32): Matrix3 {\n    const te = this.elements;\n\n    te[0] *= sx;\n    te[3] *= sx;\n    te[6] *= sx;\n    te[1] *= sy;\n    te[4] *= sy;\n    te[7] *= sy;\n\n    return this;\n  }\n\n  rotate(theta: f32): Matrix3 {\n    const c: f32 = Mathf.cos(theta);\n    const s: f32 = Mathf.sin(theta);\n\n    const te = this.elements;\n\n    const a11: f32 = te[0],\n      a12: f32 = te[3],\n      a13: f32 = te[6];\n    const a21: f32 = te[1],\n      a22: f32 = te[4],\n      a23: f32 = te[7];\n\n    te[0] = c * a11 + s * a21;\n    te[3] = c * a12 + s * a22;\n    te[6] = c * a13 + s * a23;\n\n    te[1] = -s * a11 + c * a21;\n    te[4] = -s * a12 + c * a22;\n    te[7] = -s * a13 + c * a23;\n\n    return this;\n  }\n\n  translate(tx: f32, ty: f32): Matrix3 {\n    const te = this.elements;\n\n    te[0] += tx * te[2];\n    te[3] += tx * te[5];\n    te[6] += tx * te[8];\n    te[1] += ty * te[2];\n    te[4] += ty * te[5];\n    te[7] += ty * te[8];\n\n    return this;\n  }\n\n  equals(matrix: Matrix3): boolean {\n    const te = this.elements;\n    const me = matrix.elements;\n\n    for (let i: u8 = 0; i < 9; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n\n    return true;\n  }\n\n  fromArray(array: Float32Array, offset: u32 = 0): Matrix3 {\n    for (let i: u8 = 0; i < 9; i++) {\n      this.elements[i] = array[i + offset];\n    }\n\n    return this;\n  }\n\n  toArray(array: f32[] = [], offset: u32 = 0): f32[] {\n    const te = this.elements;\n\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n\n    return array;\n  }\n\n  clone(): Matrix3 {\n    return new Matrix3().fromArray(this.elements);\n  }\n}\n","export function fillArray<T>(array1: T[], array2: T[]): T[] {\n  for (let i: i32 = 0, l: i32 = array1.length; i < l; i++) {\n    array1[i] = array2[i];\n  }\n\n  return array1;\n}\n\nexport function toTypedArray<T, TyArr extends ArrayBufferView>(arr: Array<T>, byteSize: i32): TyArr {\n  let len = arr.length;\n  let result = instantiate<TyArr>(len);\n  memory.copy(result.dataStart, arr.dataStart, len * byteSize);\n  return result;\n}\n\nexport function f32Array(arr: Array<f32>): Float32Array {\n  let len = arr.length;\n  let result = new Float32Array(len);\n  memory.copy(result.dataStart, arr.dataStart, len * Float32Array.BYTES_PER_ELEMENT);\n  return result;\n}\n\nexport function arrayMin<T>(array: T[], infinitiy: T): T {\n  if (array.length == 0) return infinitiy;\n\n  let min = array[0];\n\n  for (let i = 1, l = array.length; i < l; ++i) {\n    if (array[i] < min) min = array[i];\n  }\n\n  return min;\n}\n\nexport function arrayMax<T>(array: T[], negInfinitiy: T): T {\n  if (array.length == 0) return negInfinitiy;\n\n  let max = array[0];\n\n  for (let i = 1, l = array.length; i < l; ++i) {\n    if (array[i] > max) max = array[i];\n  }\n\n  return max;\n}\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int8Array, i8, U, valueof<U>>(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8Array, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8ClampedArray, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    var len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int16Array, i16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    var len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint16Array, u16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    var len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int32Array, i32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    var len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint32Array, u32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    var len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int64Array, i64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    var len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint64Array, u64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    var len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float32Array, f32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    var len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float64Array, f64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var ptr = array.dataStart;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) memory.fill(ptr + <usize>start, <u8>value, <usize>(end - start));\n  } else {\n    for (; start < end; ++start) {\n      store<T>(ptr + (<usize>start << alignof<T>()), value);\n    }\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  var slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  var ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  var to    = target < 0 ? max(len + target, 0) : min(target, len);\n  var from  = start < 0 ? max(len + start, 0) : min(start, len);\n  var last  = end < 0 ? max(len + end, 0) : min(end, len);\n  var count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var len = array.length;\n  var ptr = array.dataStart;\n\n  var byteLength = len << alignof<T>();\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  var len = array.length;\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  var dataStart  = array.dataStart;\n  var j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  var byteLength = j << alignof<T>();\n  var data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  var dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  var dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  var byteLength: i32;\n  var bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<TArray extends ArrayBufferView, T, UArray extends ArrayBufferView, U>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<U>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n\n  // Uncaught RangeError: offset is out of bounds\n  if (offset < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n  if (source.length + offset > target.length) throw new RangeError(E_INDEXOUTOFRANGE);\n\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (isInteger<T>() == isInteger<U>() && alignof<T>() == alignof<U>() &&\n    !(target instanceof Uint8ClampedArray && isSigned<U>())) {\n    memory.copy(\n      target.dataStart + (<usize>offset << alignof<T>()),\n      source.dataStart,\n      source.byteLength\n    );\n  } else {\n    let targetDataStart = target.dataStart + (<usize>offset << alignof<T>());\n    let sourceDataStart = source.dataStart;\n    let count = source.length;\n    for (let i = 0; i < count; i++) {\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<U>()) {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          store<T>(\n            targetDataStart + (<usize>i << alignof<T>()),\n            isFinite<U>(value) ? <T>max<U>(0, min<U>(255, value)) : <T>0\n          );\n        } else {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          if (!isSigned<U>()) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              min<U>(255, value)\n            );\n          } else if (sizeof<T>() <= 4) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value)\n            );\n          } else {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value)\n            );\n          }\n        }\n        // if U is a float, then casting float to int must include a finite check\n      } else if (isFloat<U>() && !isFloat<T>()) {\n        let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n        // @ts-ignore: cast to T is valid for numeric types here\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), isFinite<U>(value) ? <T>value : 0);\n      } else if (isFloat<T>() && !isFloat<U>()) {\n        // @ts-ignore: In this case the <T> conversion is required\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), <T>load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      } else {\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      }\n    }\n  }\n}\n","import { BufferAttribute } from \"../core/BufferAttribute\";\nimport { Object } from \"../core/Object\";\nimport { Mesh } from \"../objects/Mesh\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Plane } from \"./Plane\";\nimport { Sphere } from \"./Sphere\";\nimport { Triangle } from \"./Triangle\";\nimport { Vector3 } from \"./Vector3\";\n\nexport class Box3 {\n  isBox3: boolean = true;\n  min: Vector3;\n  max: Vector3;\n\n  constructor(\n    min: Vector3 = new Vector3(+Infinity, +Infinity, +Infinity),\n    max: Vector3 = new Vector3(-Infinity, -Infinity, -Infinity)\n  ) {\n    this.min = min;\n    this.max = max;\n  }\n\n  set(min: Vector3, max: Vector3): Box3 {\n    this.min.copy(min);\n    this.max.copy(max);\n\n    return this;\n  }\n\n  setFromArray(array: f32[]): Box3 {\n    let minX: f32 = +Infinity;\n    let minY: f32 = +Infinity;\n    let minZ: f32 = +Infinity;\n\n    let maxX: f32 = -Infinity;\n    let maxY: f32 = -Infinity;\n    let maxZ: f32 = -Infinity;\n\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (z < minZ) minZ = z;\n\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n      if (z > maxZ) maxZ = z;\n    }\n\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n\n    return this;\n  }\n\n  setFromBufferAttribute(attribute: BufferAttribute<f32, Float32Array>): Box3 {\n    let minX: f32 = +Infinity;\n    let minY: f32 = +Infinity;\n    let minZ: f32 = +Infinity;\n\n    let maxX: f32 = -Infinity;\n    let maxY: f32 = -Infinity;\n    let maxZ: f32 = -Infinity;\n\n    for (let i: u32 = 0, l = attribute.count; i < l; i++) {\n      const x: f32 = attribute.getX(i);\n      const y: f32 = attribute.getY(i);\n      const z: f32 = attribute.getZ(i);\n\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (z < minZ) minZ = z;\n\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n      if (z > maxZ) maxZ = z;\n    }\n\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n\n    return this;\n  }\n\n  setFromPoints(points: Vector3[]): Box3 {\n    this.makeEmpty();\n\n    for (let i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n\n    return this;\n  }\n\n  setFromCenterAndSize(center: Vector3, size: Vector3): Box3 {\n    const halfSize = _vector.copy(size).multiplyScalar(0.5);\n\n    this.min.copy(center).sub(halfSize);\n    this.max.copy(center).add(halfSize);\n\n    return this;\n  }\n\n  setFromObject(object: Object): Box3 {\n    this.makeEmpty();\n\n    return this.expandByObject(object);\n  }\n\n  clone(): Box3 {\n    return new Box3().copy(this);\n  }\n\n  copy(box: Box3): Box3 {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n\n    return this;\n  }\n\n  makeEmpty(): Box3 {\n    this.min.x = this.min.y = this.min.z = +Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n\n    return this;\n  }\n\n  isEmpty(): boolean {\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n  }\n\n  getCenter(target: Vector3): Vector3 {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n  }\n\n  getSize(target: Vector3): Vector3 {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n  }\n\n  expandByPoint(point: Vector3): Box3 {\n    this.min.min(point);\n    this.max.max(point);\n\n    return this;\n  }\n\n  expandByVector(vector: Vector3): Box3 {\n    this.min.sub(vector);\n    this.max.add(vector);\n\n    return this;\n  }\n\n  expandByScalar(scalar: f32): Box3 {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n\n    return this;\n  }\n\n  expandByObject(object: Object): Box3 {\n    // Computes the world-axis-aligned bounding box of an object (including its children),\n    // accounting for both the object's, and children's, world transforms\n\n    object.updateWorldMatrix(false, false);\n\n    const geometry = (object as Mesh).geometry;\n\n    if (geometry !== undefined) {\n      if (geometry.boundingBox === null) {\n        geometry.computeBoundingBox();\n      }\n\n      _box.copy(geometry.boundingBox!);\n      _box.applyMatrix4(object.matrixWorld);\n\n      this.union(_box);\n    }\n\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      this.expandByObject(children[i]);\n    }\n\n    return this;\n  }\n\n  containsPoint(point: Vector3): boolean {\n    return point.x < this.min.x ||\n      point.x > this.max.x ||\n      point.y < this.min.y ||\n      point.y > this.max.y ||\n      point.z < this.min.z ||\n      point.z > this.max.z\n      ? false\n      : true;\n  }\n\n  containsBox(box: Box3): boolean {\n    return (\n      this.min.x <= box.min.x &&\n      box.max.x <= this.max.x &&\n      this.min.y <= box.min.y &&\n      box.max.y <= this.max.y &&\n      this.min.z <= box.min.z &&\n      box.max.z <= this.max.z\n    );\n  }\n\n  getParameter(point: Vector3, target: Vector3): Vector3 {\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n\n    return target.set(\n      (point.x - this.min.x) / (this.max.x - this.min.x),\n      (point.y - this.min.y) / (this.max.y - this.min.y),\n      (point.z - this.min.z) / (this.max.z - this.min.z)\n    );\n  }\n\n  intersectsBox(box: Box3): boolean {\n    // using 6 splitting planes to rule out intersections.\n    return box.max.x < this.min.x ||\n      box.min.x > this.max.x ||\n      box.max.y < this.min.y ||\n      box.min.y > this.max.y ||\n      box.max.z < this.min.z ||\n      box.min.z > this.max.z\n      ? false\n      : true;\n  }\n\n  intersectsSphere(sphere: Sphere): boolean {\n    // Find the point on the AABB closest to the sphere center.\n    this.clampPoint(sphere.center, _vector);\n\n    // If that point is inside the sphere, the AABB and sphere intersect.\n    return _vector.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  }\n\n  intersectsPlane(plane: Plane): boolean {\n    // We compute the minimum and maximum dot product values. If those values\n    // are on the same side (back or front) of the plane, then there is no intersection.\n\n    let min: f32, max: f32;\n\n    if (plane.normal.x > 0) {\n      min = plane.normal.x * this.min.x;\n      max = plane.normal.x * this.max.x;\n    } else {\n      min = plane.normal.x * this.max.x;\n      max = plane.normal.x * this.min.x;\n    }\n\n    if (plane.normal.y > 0) {\n      min += plane.normal.y * this.min.y;\n      max += plane.normal.y * this.max.y;\n    } else {\n      min += plane.normal.y * this.max.y;\n      max += plane.normal.y * this.min.y;\n    }\n\n    if (plane.normal.z > 0) {\n      min += plane.normal.z * this.min.z;\n      max += plane.normal.z * this.max.z;\n    } else {\n      min += plane.normal.z * this.max.z;\n      max += plane.normal.z * this.min.z;\n    }\n\n    return min <= -plane.constant && max >= -plane.constant;\n  }\n\n  intersectsTriangle(triangle: Triangle): boolean {\n    if (this.isEmpty()) {\n      return false;\n    }\n\n    // compute box center and extents\n    this.getCenter(_center);\n    _extents.subVectors(this.max, _center);\n\n    // translate triangle to aabb origin\n    _v0.subVectors(triangle.a, _center);\n    _v1.subVectors(triangle.b, _center);\n    _v2.subVectors(triangle.c, _center);\n\n    // compute edge vectors for triangle\n    _f0.subVectors(_v1, _v0);\n    _f1.subVectors(_v2, _v1);\n    _f2.subVectors(_v0, _v2);\n\n    // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n    let axes = [\n      0,\n      -_f0.z,\n      _f0.y,\n      0,\n      -_f1.z,\n      _f1.y,\n      0,\n      -_f2.z,\n      _f2.y,\n      _f0.z,\n      0,\n      -_f0.x,\n      _f1.z,\n      0,\n      -_f1.x,\n      _f2.z,\n      0,\n      -_f2.x,\n      -_f0.y,\n      _f0.x,\n      0,\n      -_f1.y,\n      _f1.x,\n      0,\n      -_f2.y,\n      _f2.x,\n      0,\n    ];\n    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {\n      return false;\n    }\n\n    // test 3 face normals from the aabb\n    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {\n      return false;\n    }\n\n    // finally testing the face normal of the triangle\n    // use already existing triangle edge vectors here\n    _triangleNormal.crossVectors(_f0, _f1);\n    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n\n    return satForAxes(axes, _v0, _v1, _v2, _extents);\n  }\n\n  clampPoint(point: Vector3, target: Vector3): Vector3 {\n    return target.copy(point).clamp(this.min, this.max);\n  }\n\n  distanceToPoint(point: Vector3): f32 {\n    const clampedPoint = _vector.copy(point).clamp(this.min, this.max);\n\n    return clampedPoint.sub(point).length();\n  }\n\n  getBoundingSphere(target: Sphere): Sphere {\n    this.getCenter(target.center);\n\n    target.radius = this.getSize(_vector).length() * 0.5;\n\n    return target;\n  }\n\n  intersect(box: Box3): Box3 {\n    this.min.max(box.min);\n    this.max.min(box.max);\n\n    // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n    if (this.isEmpty()) this.makeEmpty();\n\n    return this;\n  }\n\n  union(box: Box3): Box3 {\n    this.min.min(box.min);\n    this.max.max(box.max);\n\n    return this;\n  }\n\n  applyMatrix4(matrix: Matrix4): Box3 {\n    // transform of empty box is an empty box.\n    if (this.isEmpty()) return this;\n\n    // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n    this.setFromPoints(_points);\n\n    return this;\n  }\n\n  translate(offset: Vector3): Box3 {\n    this.min.add(offset);\n    this.max.add(offset);\n\n    return this;\n  }\n\n  equals(box: Box3): boolean {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n}\n\nconst _points = [\n  new Vector3(),\n  new Vector3(),\n  new Vector3(),\n  new Vector3(),\n  new Vector3(),\n  new Vector3(),\n  new Vector3(),\n  new Vector3(),\n];\n\nconst _vector = new Vector3();\n\nconst _box = new Box3();\n\n// triangle centered vertices\n\nconst _v0 = new Vector3();\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = new Vector3();\nconst _f1 = new Vector3();\nconst _f2 = new Vector3();\n\nconst _center = new Vector3();\nconst _extents = new Vector3();\nconst _triangleNormal = new Vector3();\nconst _testAxis = new Vector3();\n\nfunction satForAxes(axes: f32[], v0: Vector3, v1: Vector3, v2: Vector3, extents: Vector3): boolean {\n  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n    _testAxis.fromArray(axes, i);\n    // project the aabb onto the seperating axis\n    const r =\n      extents.x * Mathf.abs(_testAxis.x) + extents.y * Mathf.abs(_testAxis.y) + extents.z * Mathf.abs(_testAxis.z);\n    // project all 3 vertices of the triangle onto the seperating axis\n    const p0 = v0.dot(_testAxis);\n    const p1 = v1.dot(_testAxis);\n    const p2 = v2.dot(_testAxis);\n    // actual test, basically see if either of the most extreme of the triangle points intersects r\n    if (Mathf.max(-Mathf.max(Mathf.max(p0, p1), p2), Mathf.min(Mathf.min(p0, p1), p2)) > r) {\n      // points of the projected triangle are outside the projected half-length of the aabb\n      // the axis is seperating and we can exit\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { Box3 } from \"./Box3\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Plane } from \"./Plane\";\nimport { Vector3 } from \"./Vector3\";\n\nconst _box = new Box3();\nconst _v1 = new Vector3();\nconst _toFarthestPoint = new Vector3();\nconst _toPoint = new Vector3();\n\nexport class Sphere {\n  center: Vector3;\n  radius: f32;\n\n  constructor(center: Vector3 = new Vector3(), radius: f32 = -1) {\n    this.center = center;\n    this.radius = radius;\n  }\n\n  set(center: Vector3, radius: f32): Sphere {\n    this.center.copy(center);\n    this.radius = radius;\n\n    return this;\n  }\n\n  setFromPoints(points: Vector3[], optionalCenter: Vector3): Sphere {\n    const center = this.center;\n\n    if (optionalCenter !== undefined) {\n      center.copy(optionalCenter);\n    } else {\n      _box.setFromPoints(points).getCenter(center);\n    }\n\n    let maxRadiusSq = 0;\n\n    for (let i = 0, il = points.length; i < il; i++) {\n      maxRadiusSq = Mathf.max(maxRadiusSq, center.distanceToSquared(points[i]));\n    }\n\n    this.radius = Mathf.sqrt(maxRadiusSq);\n\n    return this;\n  }\n\n  copy(sphere: Sphere): Sphere {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n\n    return this;\n  }\n\n  isEmpty(): boolean {\n    return this.radius < 0;\n  }\n\n  makeEmpty(): Sphere {\n    this.center.set(0, 0, 0);\n    this.radius = -1;\n\n    return this;\n  }\n\n  containsPoint(point: Vector3): boolean {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n\n  distanceToPoint(point: Vector3): f32 {\n    return point.distanceTo(this.center) - this.radius;\n  }\n\n  intersectsSphere(sphere: Sphere): boolean {\n    const radiusSum = this.radius + sphere.radius;\n\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  }\n\n  intersectsBox(box: Box3): boolean {\n    return box.intersectsSphere(this);\n  }\n\n  intersectsPlane(plane: Plane): boolean {\n    return Mathf.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n\n  clampPoint(point: Vector3, target: Vector3): Vector3 {\n    const deltaLengthSq = this.center.distanceToSquared(point);\n\n    target.copy(point);\n\n    if (deltaLengthSq > this.radius * this.radius) {\n      target.sub(this.center).normalize();\n      target.multiplyScalar(this.radius).add(this.center);\n    }\n\n    return target;\n  }\n\n  getBoundingBox(target: Box3): Box3 {\n    if (this.isEmpty()) {\n      // Empty sphere produces empty bounding box\n      target.makeEmpty();\n      return target;\n    }\n\n    target.set(this.center, this.center);\n    target.expandByScalar(this.radius);\n\n    return target;\n  }\n\n  applyMatrix4(matrix: Matrix4): Sphere {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n    return this;\n  }\n\n  translate(offset: Vector3): Sphere {\n    this.center.add(offset);\n\n    return this;\n  }\n\n  expandByPoint(point: Vector3): Sphere {\n    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n\n    _toPoint.subVectors(point, this.center);\n\n    const lengthSq = _toPoint.lengthSq();\n\n    if (lengthSq > this.radius * this.radius) {\n      const length = Mathf.sqrt(lengthSq);\n      const missingRadiusHalf = (length - this.radius) * 0.5;\n\n      // Nudge this sphere towards the target point. Add half the missing distance to radius,\n      // and the other half to position. This gives a tighter enclosure, instead of if\n      // the whole missing distance were just added to radius.\n\n      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));\n      this.radius += missingRadiusHalf;\n    }\n\n    return this;\n  }\n\n  union(sphere: Sphere): Sphere {\n    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n\n    // To enclose another sphere into this sphere, we only need to enclose two points:\n    // 1) Enclose the farthest point on the other sphere into this sphere.\n    // 2) Enclose the opposite point of the farthest point into this sphere.\n\n    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);\n\n    this.expandByPoint(_v1.copy(sphere.center).add(_toFarthestPoint));\n    this.expandByPoint(_v1.copy(sphere.center).sub(_toFarthestPoint));\n\n    return this;\n  }\n\n  equals(sphere: Sphere): boolean {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n\n  clone(): Sphere {\n    return new Sphere().copy(this);\n  }\n}\n","import { Vector3 } from \"./Vector3\";\nimport { Plane } from \"./Plane\";\nimport { Vector2 } from \"./Vector2\";\nimport { Box3 } from \"./Box3\";\n\nconst _v0 = new Vector3();\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _v3 = new Vector3();\n\nconst _vab = new Vector3();\nconst _vac = new Vector3();\nconst _vbc = new Vector3();\nconst _vap = new Vector3();\nconst _vbp = new Vector3();\nconst _vcp = new Vector3();\n\nexport class Triangle {\n  a: Vector3;\n  b: Vector3;\n  c: Vector3;\n\n  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n\n  static getNormal(a: Vector3, b: Vector3, c: Vector3, target: Vector3): Vector3 {\n    target.subVectors(c, b);\n    _v0.subVectors(a, b);\n    target.cross(_v0);\n\n    const targetLengthSq = target.lengthSq();\n    if (targetLengthSq > 0) {\n      return target.multiplyScalar(1 / Mathf.sqrt(targetLengthSq));\n    }\n\n    return target.set(0, 0, 0);\n  }\n\n  // static/instance method to calculate barycentric coordinates\n  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n  static getBarycoord(point: Vector3, a: Vector3, b: Vector3, c: Vector3, target: Vector3): Vector3 {\n    _v0.subVectors(c, a);\n    _v1.subVectors(b, a);\n    _v2.subVectors(point, a);\n\n    const dot00: f32 = _v0.dot(_v0);\n    const dot01: f32 = _v0.dot(_v1);\n    const dot02: f32 = _v0.dot(_v2);\n    const dot11: f32 = _v1.dot(_v1);\n    const dot12: f32 = _v1.dot(_v2);\n\n    const denom: f32 = dot00 * dot11 - dot01 * dot01;\n\n    // collinear or singular triangle\n    if (denom === 0) {\n      // arbitrary location outside of triangle?\n      // not sure if this is the best idea, maybe should be returning undefined\n      return target.set(-2, -1, -1);\n    }\n\n    const invDenom: f32 = 1 / denom;\n    const u: f32 = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v: f32 = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // barycentric coordinates must always sum to 1\n    return target.set(1 - u - v, v, u);\n  }\n\n  static containsPoint(point: Vector3, a: Vector3, b: Vector3, c: Vector3): boolean {\n    this.getBarycoord(point, a, b, c, _v3);\n\n    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;\n  }\n\n  static getUV(\n    point: Vector3,\n    p1: Vector3,\n    p2: Vector3,\n    p3: Vector3,\n    uv1: Vector2,\n    uv2: Vector2,\n    uv3: Vector2,\n    target: Vector2\n  ): Vector2 {\n    this.getBarycoord(point, p1, p2, p3, _v3);\n\n    target.set(0, 0);\n    target.addScaledVector(uv1, _v3.x);\n    target.addScaledVector(uv2, _v3.y);\n    target.addScaledVector(uv3, _v3.z);\n\n    return target;\n  }\n\n  static isFrontFacing(a: Vector3, b: Vector3, c: Vector3, direction: Vector3): boolean {\n    _v0.subVectors(c, b);\n    _v1.subVectors(a, b);\n\n    // strictly front facing\n    return _v0.cross(_v1).dot(direction) < 0 ? true : false;\n  }\n\n  set(a: Vector3, b: Vector3, c: Vector3): Triangle {\n    this.a.copy(a);\n    this.b.copy(b);\n    this.c.copy(c);\n\n    return this;\n  }\n\n  setFromPointsAndIndices(points: Vector3[], i0: u32, i1: u32, i2: u32): Triangle {\n    this.a.copy(points[i0]);\n    this.b.copy(points[i1]);\n    this.c.copy(points[i2]);\n\n    return this;\n  }\n\n  clone(): Triangle {\n    return new Triangle().copy(this);\n  }\n\n  copy(triangle: Triangle): Triangle {\n    this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    this.c.copy(triangle.c);\n\n    return this;\n  }\n\n  getArea(): f32 {\n    _v0.subVectors(this.c, this.b);\n    _v1.subVectors(this.a, this.b);\n\n    return _v0.cross(_v1).length() * 0.5;\n  }\n\n  getMidpoint(target: Vector3): Vector3 {\n    return target\n      .addVectors(this.a, this.b)\n      .add(this.c)\n      .multiplyScalar(1 / 3);\n  }\n\n  getNormal(target: Vector3): Vector3 {\n    return Triangle.getNormal(this.a, this.b, this.c, target);\n  }\n\n  getPlane(target: Plane): Plane {\n    return target.setFromCoplanarPoints(this.a, this.b, this.c);\n  }\n\n  getBarycoord(point: Vector3, target: Vector3): Vector3 {\n    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n  }\n\n  getUV(point: Vector3, uv1: Vector2, uv2: Vector2, uv3: Vector2, target: Vector2): Vector2 {\n    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);\n  }\n\n  containsPoint(point: Vector3): boolean {\n    return Triangle.containsPoint(point, this.a, this.b, this.c);\n  }\n\n  isFrontFacing(direction: Vector3): boolean {\n    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n  }\n\n  intersectsBox(box: Box3): boolean {\n    return box.intersectsTriangle(this);\n  }\n\n  closestPointToPoint(p: Vector3, target: Vector3): Vector3 {\n    const a = this.a,\n      b = this.b,\n      c = this.c;\n    let v: f32, w: f32;\n\n    // algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n    // under the accompanying license; see chapter 5.1.5 for detailed explanation.\n    // basically, we're distinguishing which of the voronoi regions of the triangle\n    // the point lies in with the minimum amount of redundant computation.\n\n    _vab.subVectors(b, a);\n    _vac.subVectors(c, a);\n    _vap.subVectors(p, a);\n    const d1 = _vab.dot(_vap);\n    const d2 = _vac.dot(_vap);\n    if (d1 <= 0 && d2 <= 0) {\n      // vertex region of A; barycentric coords (1, 0, 0)\n      return target.copy(a);\n    }\n\n    _vbp.subVectors(p, b);\n    const d3 = _vab.dot(_vbp);\n    const d4 = _vac.dot(_vbp);\n    if (d3 >= 0 && d4 <= d3) {\n      // vertex region of B; barycentric coords (0, 1, 0)\n      return target.copy(b);\n    }\n\n    const vc = d1 * d4 - d3 * d2;\n    if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n      v = d1 / (d1 - d3);\n      // edge region of AB; barycentric coords (1-v, v, 0)\n      return target.copy(a).addScaledVector(_vab, v);\n    }\n\n    _vcp.subVectors(p, c);\n    const d5 = _vab.dot(_vcp);\n    const d6 = _vac.dot(_vcp);\n    if (d6 >= 0 && d5 <= d6) {\n      // vertex region of C; barycentric coords (0, 0, 1)\n      return target.copy(c);\n    }\n\n    const vb = d5 * d2 - d1 * d6;\n    if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n      w = d2 / (d2 - d6);\n      // edge region of AC; barycentric coords (1-w, 0, w)\n      return target.copy(a).addScaledVector(_vac, w);\n    }\n\n    const va = d3 * d6 - d5 * d4;\n    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n      _vbc.subVectors(c, b);\n      w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n      // edge region of BC; barycentric coords (0, 1-w, w)\n      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC\n    }\n\n    // face region\n    const denom = 1 / (va + vb + vc);\n    // u = va * denom\n    v = vb * denom;\n    w = vc * denom;\n\n    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n  }\n\n  equals(triangle: Triangle): boolean {\n    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n  }\n}\n","import { Vector3 } from \"../math/Vector3\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { Box3 } from \"../math/Box3\";\nimport { EventDispatcher } from \"./EventDispatcher\";\nimport {\n  BaseAttribute,\n  BufferAttribute,\n  CloneToken,\n  Float32BufferAttribute,\n  Uint16BufferAttribute,\n  Uint32BufferAttribute,\n} from \"./BufferAttribute\";\nimport { Sphere } from \"../math/Sphere\";\nimport { Object } from \"./Object\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Matrix3 } from \"../math/Matrix3\";\nimport * as MathUtils from \"../math/MathUtils\";\nimport { Quaternion } from \"../math/Quaternion\";\nimport { ASError } from \"./Error\";\nimport { GLBufferAttribute } from \"./GLBufferAttribute\";\nimport { Event } from \"./Event\";\nimport { toTypedArray } from \"../utils\";\nimport { BridgeManager } from \"../core/BridgeManager\";\n\nlet _id = 0;\n\nconst _m1 = new Matrix4();\nconst _obj = new Object();\nconst _offset = new Vector3();\nconst _box = new Box3();\nconst _boxMorphTargets = new Box3();\nconst _vector = new Vector3();\n\nexport class AttributeTypes {\n  static POSITION: symbol = Symbol();\n  static NORMAL: symbol = Symbol();\n  static UV: symbol = Symbol();\n  static TANGENT: symbol = Symbol();\n}\n\nexport class BufferGeometryDrawRange {\n  start: i32;\n  count: i32;\n  constructor() {\n    this.start = 0;\n    this.count = i32.MAX_VALUE;\n  }\n}\n\nexport class BufferGeometryGroup {\n  start: i32;\n  count: i32;\n  materialIndex: i32;\n\n  constructor(start: i32, count: i32, materialIndex: i32 = 0) {\n    this.start = start;\n    this.count = count;\n    this.materialIndex = materialIndex;\n  }\n}\n\nconst disposeEvent: Event = new Event(\"disposed\");\n\nexport class BufferGeometry extends EventDispatcher {\n  uuid: string;\n\n  name: string;\n  type: string;\n\n  indexes: Uint32BufferAttribute | null;\n  attributes: Map<symbol, BaseAttribute>;\n\n  morphAttributes: Map<symbol, BaseAttribute[]>;\n  morphTargetsRelative: boolean;\n\n  groups: BufferGeometryGroup[];\n\n  boundingBox: Box3 | null;\n  boundingSphere: Sphere | null;\n\n  drawRange: BufferGeometryDrawRange;\n  readonly id: u32;\n\n  // userData: {};\n\n  constructor() {\n    super();\n\n    this.id = _id++;\n\n    this.uuid = MathUtils.generateUUID();\n\n    this.name = \"\";\n    this.type = \"BufferGeometry\";\n\n    this.indexes = null;\n    this.attributes = new Map();\n\n    this.morphAttributes = new Map();\n    this.morphTargetsRelative = false;\n\n    this.groups = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null;\n\n    this.drawRange = new BufferGeometryDrawRange();\n\n    // this.userData = {};\n  }\n\n  getIndexes(): Uint32BufferAttribute | null {\n    return this.indexes;\n  }\n\n  setIndexes(indexes: u32[] | null): BufferGeometry {\n    this.indexes = indexes\n      ? new Uint32BufferAttribute(toTypedArray<u32, Uint32Array>(indexes, Uint32Array.BYTES_PER_ELEMENT), 1)\n      : null;\n    return this;\n  }\n\n  setIndexAttrbute(index: Uint32BufferAttribute): BufferGeometry {\n    this.indexes = index;\n    return this;\n  }\n  // ==================\n\n  getAttribute<K extends BaseAttribute>(name: symbol): K | null {\n    if (this.hasAttribute(name)) return this.attributes.get(name) as K;\n    else return null;\n  }\n\n  getMorphAttribute<K extends BaseAttribute>(name: symbol): K[] | null {\n    if (this.hasMoprhAttribute(name)) {\n      const toRet = this.morphAttributes.get(name);\n      return changetype<K[]>(toRet);\n    } else return null;\n  }\n\n  setAttribute(name: symbol, attribute: BaseAttribute): BufferGeometry {\n    this.attributes.set(name, attribute);\n\n    return this;\n  }\n\n  deleteAttribute(name: symbol): BufferGeometry {\n    this.attributes.delete(name);\n\n    return this;\n  }\n\n  hasAttribute(name: symbol): bool {\n    return this.attributes.has(name);\n  }\n\n  hasMoprhAttribute(name: symbol): bool {\n    return this.morphAttributes.has(name);\n  }\n\n  addGroup(start: i32, count: i32, materialIndex: i32 = 0): void {\n    this.groups.push(new BufferGeometryGroup(start, count, materialIndex));\n  }\n\n  clearGroups(): void {\n    this.groups = [];\n  }\n\n  setDrawRange(start: i32, count: i32): void {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n\n  applyMatrix4(matrix: Matrix4): BufferGeometry {\n    const position = this.getAttribute<Float32BufferAttribute>(AttributeTypes.POSITION);\n\n    if (position) {\n      BufferAttribute.applyMatrix4(matrix, position);\n\n      position.needsUpdate = true;\n    }\n\n    const normal = this.getAttribute<Float32BufferAttribute>(AttributeTypes.NORMAL);\n\n    if (normal !== null) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      BufferAttribute.applyNormalMatrix(normalMatrix, normal);\n      normal.needsUpdate = true;\n    }\n\n    const tangent = this.getAttribute<Float32BufferAttribute>(AttributeTypes.TANGENT);\n\n    if (tangent !== null) {\n      BufferAttribute.transformDirection(matrix, tangent);\n      tangent.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  applyQuaternion(q: Quaternion): BufferGeometry {\n    _m1.makeRotationFromQuaternion(q);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  rotateX(angle: f32): BufferGeometry {\n    // rotate geometry around world x-axis\n\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  rotateY(angle: f32): BufferGeometry {\n    // rotate geometry around world y-axis\n\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  rotateZ(angle: f32): BufferGeometry {\n    // rotate geometry around world z-axis\n\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  translate(x: f32, y: f32, z: f32): BufferGeometry {\n    // translate geometry\n\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  scale(x: f32, y: f32, z: f32): BufferGeometry {\n    // scale geometry\n\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n\n    return this;\n  }\n\n  lookAt(vector: Vector3): BufferGeometry {\n    _obj.lookAt(vector.x, vector.y, vector.z);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n\n    return this;\n  }\n\n  center(): BufferGeometry {\n    this.computeBoundingBox();\n\n    this.boundingBox!.getCenter(_offset).negate();\n\n    this.translate(_offset.x, _offset.y, _offset.z);\n\n    return this;\n  }\n\n  setFromPoints(points: Vector3[]): BufferGeometry {\n    const position: f32[] = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      position.push(point.x);\n      position.push(point.y);\n      position.push(point.z);\n    }\n\n    this.setAttribute(\n      AttributeTypes.POSITION,\n      new Float32BufferAttribute(toTypedArray<f32, Float32Array>(position, Float32Array.BYTES_PER_ELEMENT), 3)\n    );\n\n    return this;\n  }\n\n  computeBoundingBox(): void {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    const position = this.getAttribute<Float32BufferAttribute>(AttributeTypes.POSITION);\n    const morphAttributesPosition = this.getMorphAttribute<Float32BufferAttribute>(AttributeTypes.POSITION);\n\n    if (position && position instanceof GLBufferAttribute) {\n      BridgeManager.getBridge().print(\n        'BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".'\n      );\n\n      this.boundingBox!.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n\n      return;\n    }\n\n    if (position !== null) {\n      this.boundingBox!.setFromBufferAttribute(position);\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _box.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(this.boundingBox!.min, _box.min);\n            this.boundingBox!.expandByPoint(_vector);\n\n            _vector.addVectors(this.boundingBox!.max, _box.max);\n            this.boundingBox!.expandByPoint(_vector);\n          } else {\n            this.boundingBox!.expandByPoint(_box.min);\n            this.boundingBox!.expandByPoint(_box.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox!.makeEmpty();\n    }\n\n    if (isNaN(this.boundingBox!.min.x) || isNaN(this.boundingBox!.min.y) || isNaN(this.boundingBox!.min.z)) {\n      throw new ASError(\n        'BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.'\n      );\n    }\n  }\n\n  computeBoundingSphere(): void {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    const position = this.getAttribute<Float32BufferAttribute>(AttributeTypes.POSITION);\n    const morphAttributesPosition = this.getMorphAttribute<Float32BufferAttribute>(AttributeTypes.POSITION);\n\n    if (position && position instanceof GLBufferAttribute) {\n      BridgeManager.getBridge().print(\n        'BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".'\n      );\n      this.boundingSphere!.set(new Vector3(), Infinity);\n      return;\n    }\n\n    if (position) {\n      // first, find the center of the bounding sphere\n\n      const center = this.boundingSphere!.center;\n\n      _box.setFromBufferAttribute(position);\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(_box.min, _boxMorphTargets.min);\n            _box.expandByPoint(_vector);\n\n            _vector.addVectors(_box.max, _boxMorphTargets.max);\n            _box.expandByPoint(_vector);\n          } else {\n            _box.expandByPoint(_boxMorphTargets.min);\n            _box.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n\n      _box.getCenter(center);\n\n      // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n      let maxRadiusSq: f32 = 0;\n\n      for (let i: u32 = 0, il = position.count; i < il; i++) {\n        _vector.fromBufferAttribute(position, i);\n\n        maxRadiusSq = Mathf.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          const morphTargetsRelative = this.morphTargetsRelative;\n\n          for (let j: u32 = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector.fromBufferAttribute(morphAttribute, j);\n\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n              _vector.add(_offset);\n            }\n\n            maxRadiusSq = Mathf.max(maxRadiusSq, center.distanceToSquared(_vector));\n          }\n        }\n      }\n\n      this.boundingSphere!.radius = Mathf.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere!.radius)) {\n        throw new ASError(\n          'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.'\n        );\n      }\n    }\n  }\n\n  computeFaceNormals(): void {\n    // backwards compatibility\n  }\n\n  computeTangents(): void {\n    const index = this.indexes;\n    const attributes = this.attributes;\n\n    // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (\n      index === null ||\n      !attributes.has(AttributeTypes.POSITION) ||\n      !attributes.has(AttributeTypes.NORMAL) ||\n      !attributes.has(AttributeTypes.UV)\n    )\n      throw new ASError(\n        \"BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)\"\n      );\n\n    const indices = index.array;\n    const positions = this.getAttribute<Float32BufferAttribute>(AttributeTypes.POSITION)!.array;\n    const normals = this.getAttribute<Float32BufferAttribute>(AttributeTypes.NORMAL)!.array;\n    const uvs = this.getAttribute<Float32BufferAttribute>(AttributeTypes.UV)!.array;\n\n    const nVertices = positions.length / 3;\n\n    if (!attributes.has(AttributeTypes.TANGENT)) {\n      this.setAttribute(AttributeTypes.TANGENT, new Float32BufferAttribute(new Float32Array(4 * nVertices), 4));\n    }\n\n    const tangents = this.getAttribute<Float32BufferAttribute>(AttributeTypes.TANGENT)!.array;\n\n    const tan1: Vector3[] = [],\n      tan2: Vector3[] = [];\n\n    for (let i = 0; i < nVertices; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n\n    const vA = new Vector3(),\n      vB = new Vector3(),\n      vC = new Vector3(),\n      uvA = new Vector2(),\n      uvB = new Vector2(),\n      uvC = new Vector2(),\n      sdir = new Vector3(),\n      tdir = new Vector3();\n\n    function handleTriangle(a: f32, b: f32, c: f32) {\n      vA.fromF32Array(positions, a * 3);\n      vB.fromF32Array(positions, b * 3);\n      vC.fromF32Array(positions, c * 3);\n\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n\n      vB.sub(vA);\n      vC.sub(vA);\n\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n\n      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);\n\n      // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n\n    let groups = this.groups;\n\n    if (groups.length === 0) {\n      groups = [new BufferGeometryGroup(0, indices.length)];\n    }\n\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n\n      const start = group.start;\n      const count = group.count;\n\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n\n    const tmp = new Vector3(),\n      tmp2 = new Vector3();\n    const n = new Vector3(),\n      n2 = new Vector3();\n\n    function handleVertex(v: u32) {\n      n.fromF32Array(normals, v * 3);\n      n2.copy(n);\n\n      const t = tan1[v];\n\n      // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n\n      // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      const test = tmp2.dot(tan2[v]);\n      const w = test < 0.0 ? -1.0 : 1.0;\n\n      tangents[v * 4] = tmp.x;\n      tangents[v * 4 + 1] = tmp.y;\n      tangents[v * 4 + 2] = tmp.z;\n      tangents[v * 4 + 3] = w;\n    }\n\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n\n      const start = group.start;\n      const count = group.count;\n\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  }\n\n  computeVertexNormals(): void {\n    const index = this.indexes;\n    const positionAttribute = this.getAttribute<Float32BufferAttribute>(AttributeTypes.POSITION);\n\n    if (positionAttribute !== null) {\n      let normalAttribute = this.getAttribute<Float32BufferAttribute>(AttributeTypes.NORMAL);\n\n      if (normalAttribute === null) {\n        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n        this.setAttribute(AttributeTypes.NORMAL, normalAttribute);\n      } else {\n        // reset existing normals to zero\n\n        for (let i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n\n      const pA = new Vector3(),\n        pB = new Vector3(),\n        pC = new Vector3();\n      const nA = new Vector3(),\n        nB = new Vector3(),\n        nC = new Vector3();\n      const cb = new Vector3(),\n        ab = new Vector3();\n\n      // indexed elements\n\n      if (index) {\n        for (let i = 0, il = index.count; i < il; i += 3) {\n          const vA = index.getX(i + 0);\n          const vB = index.getX(i + 1);\n          const vC = index.getX(i + 2);\n\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          pB.fromBufferAttribute(positionAttribute, i + 1);\n          pC.fromBufferAttribute(positionAttribute, i + 2);\n\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n\n      this.normalizeNormals();\n\n      normalAttribute.needsUpdate = true;\n    }\n  }\n\n  merge(geometry: BufferGeometry, offset: i32 = 0): BufferGeometry {\n    const attributes = this.attributes;\n\n    const keys = attributes.keys();\n    for (let i: i32 = 0, l: i32 = keys.length; i < l; i++) {\n      const key = keys[i];\n      if (!geometry.attributes.has(key)) continue;\n\n      const attribute1 = attributes.get(key);\n      // const attributeArray1 = attribute1.array;\n\n      const attribute2 = geometry.attributes.get(key);\n      // const attributeArray2 = attribute2.array;\n\n      attribute1.merge(attribute2, offset);\n\n      // const attributeOffset = attribute2.itemSize * offset;\n      // const length = Mathf.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n      // for (let i = 0, j = attributeOffset; i < length; i++, j++) {\n      //   attributeArray1[j] = attributeArray2[i];\n      // }\n    }\n\n    return this;\n  }\n\n  normalizeNormals(): void {\n    const normals = this.getAttribute<Float32BufferAttribute>(AttributeTypes.NORMAL);\n    if (!normals) throw new Error(\"No normal attribute defined\");\n\n    for (let i = 0, il = normals.count; i < il; i++) {\n      _vector.fromBufferAttribute(normals, i);\n\n      _vector.normalize();\n\n      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n  }\n\n  toNonIndexed(): BufferGeometry {\n    if (this.indexes === null) {\n      return this;\n    }\n\n    const geometry2 = new BufferGeometry();\n\n    const index = this.indexes;\n    const indices = index.array;\n    const attributes = this.attributes;\n\n    // attributes\n\n    const keys = attributes.keys();\n    for (let i: i32 = 0, l: i32 = keys.length; i < l; i++) {\n      const key = keys[i];\n      const attribute = attributes.get(key);\n      const newAttribute = attribute.convertBufferAttribute(indices);\n      geometry2.setAttribute(key, newAttribute);\n    }\n\n    // morph attributes\n\n    const morphAttributes = this.morphAttributes;\n    const morphKeys = morphAttributes.keys();\n\n    for (let i: i32 = 0, l: i32 = morphKeys.length; i < l; i++) {\n      const morphKey = morphKeys[i];\n      const morphArray: BaseAttribute[] = [];\n      const morphAttribute = morphAttributes.get(morphKey); // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const attribute = morphAttribute[i];\n        const newAttribute = attribute.convertBufferAttribute(indices);\n        morphArray.push(newAttribute);\n      }\n\n      geometry2.morphAttributes.set(morphKey, morphArray);\n    }\n\n    geometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n    // groups\n\n    const groups = this.groups;\n\n    for (let i: i32 = 0, l: i32 = groups.length; i < l; i++) {\n      const group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    return geometry2;\n  }\n\n  // toJSON() {\n  //   const data = {\n  //     metadata: {\n  //       version: 4.5,\n  //       type: \"BufferGeometry\",\n  //       generator: \"BufferGeometry.toJSON\",\n  //     },\n  //   };\n\n  //   // standard BufferGeometry serialization\n\n  //   data.uuid = this.uuid;\n  //   data.type = this.type;\n  //   if (this.name !== \"\") data.name = this.name;\n  //   if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n  //   if (this.parameters !== undefined) {\n  //     const parameters = this.parameters;\n\n  //     for (const key in parameters) {\n  //       if (parameters[key] !== undefined) data[key] = parameters[key];\n  //     }\n\n  //     return data;\n  //   }\n\n  //   // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n  //   data.data = { attributes: {} };\n\n  //   const index = this.index;\n\n  //   if (index !== null) {\n  //     data.data.index = {\n  //       type: index.array.constructor.name,\n  //       array: Array.prototype.slice.call(index.array),\n  //     };\n  //   }\n\n  //   const attributes = this.attributes;\n\n  //   for (const key in attributes) {\n  //     const attribute = attributes[key];\n\n  //     data.data.attributes[key] = attribute.toJSON(data.data);\n  //   }\n\n  //   const morphAttributes = {};\n  //   let hasMorphAttributes = false;\n\n  //   for (const key in this.morphAttributes) {\n  //     const attributeArray = this.morphAttributes[key];\n\n  //     const array = [];\n\n  //     for (let i = 0, il = attributeArray.length; i < il; i++) {\n  //       const attribute = attributeArray[i];\n\n  //       array.push(attribute.toJSON(data.data));\n  //     }\n\n  //     if (array.length > 0) {\n  //       morphAttributes[key] = array;\n\n  //       hasMorphAttributes = true;\n  //     }\n  //   }\n\n  //   if (hasMorphAttributes) {\n  //     data.data.morphAttributes = morphAttributes;\n  //     data.data.morphTargetsRelative = this.morphTargetsRelative;\n  //   }\n\n  //   const groups = this.groups;\n\n  //   if (groups.length > 0) {\n  //     data.data.groups = JSON.parse(JSON.stringify(groups));\n  //   }\n\n  //   const boundingSphere = this.boundingSphere;\n\n  //   if (boundingSphere !== null) {\n  //     data.data.boundingSphere = {\n  //       center: boundingSphere.center.toArray(),\n  //       radius: boundingSphere.radius,\n  //     };\n  //   }\n\n  //   return data;\n  // }\n\n  clone(): BufferGeometry {\n    /*\n\t\t // Handle primitives\n\t\t const parameters = this.parameters;\n\t\t if ( parameters !== undefined ) {\n\t\t const values = [];\n\t\t for ( const key in parameters ) {\n\t\t values.push( parameters[ key ] );\n\t\t }\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\t\t }\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n    return new BufferGeometry().copy(this);\n  }\n\n  copy(source: BufferGeometry): BufferGeometry {\n    // reset\n\n    this.indexes = null;\n    this.attributes = new Map();\n    this.morphAttributes = new Map();\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n\n    // used for storing cloned, shared data\n\n    const data: CloneToken = new CloneToken();\n\n    // name\n\n    this.name = source.name;\n\n    // index\n\n    const index = source.indexes ? new Uint32BufferAttribute(source.indexes.array.slice(0), 1) : null;\n\n    // attributes\n\n    const attributes = source.attributes;\n\n    const keys = attributes.keys();\n    for (let i: u8 = 0, l: u8 = keys.length; i < l; i++) {\n      const key = keys[i];\n      const attribute = attributes.get(key);\n      this.setAttribute(key, attribute.clone(data));\n    }\n\n    // morph attributes\n\n    const morphAttributes = source.morphAttributes;\n\n    const morphKeys = morphAttributes.keys();\n    for (let i: u8 = 0, l: u8 = morphKeys.length; i < l; i++) {\n      const morphKey = morphKeys[i];\n      const array = [];\n      const morphAttribute = morphAttributes.get(morphKey); // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n\n      this.morphAttributes.set(morphKey, array);\n    }\n\n    this.morphTargetsRelative = source.morphTargetsRelative;\n\n    // groups\n\n    const groups = source.groups;\n\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    // bounding box\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n\n    // bounding sphere\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n\n    // draw range\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count;\n\n    // user data\n\n    // this.userData = source.userData;\n\n    return this;\n  }\n\n  dispose(): void {\n    disposeEvent.target = this;\n    this.dispatchEvent(disposeEvent);\n  }\n}\n","import { Euler, EulerRotationOrder } from \"./Euler\";\nimport { Matrix3 } from \"./Matrix3\";\nimport { Quaternion } from \"./Quaternion\";\nimport { Vector3 } from \"./Vector3\";\nimport { f32Array } from \"../utils\";\nexport class Matrix4 {\n  isMatrix4: boolean = true;\n  elements: Float32Array;\n\n  constructor() {\n    this.elements = f32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n\n  set(\n    n11: f32,\n    n12: f32,\n    n13: f32,\n    n14: f32,\n    n21: f32,\n    n22: f32,\n    n23: f32,\n    n24: f32,\n    n31: f32,\n    n32: f32,\n    n33: f32,\n    n34: f32,\n    n41: f32,\n    n42: f32,\n    n43: f32,\n    n44: f32\n  ): Matrix4 {\n    const te = this.elements;\n\n    te[0] = n11;\n    te[4] = n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = n42;\n    te[11] = n43;\n    te[15] = n44;\n\n    return this;\n  }\n\n  identity(): Matrix4 {\n    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  clone(): Matrix4 {\n    return new Matrix4().fromArray(this.elements);\n  }\n\n  copy(m: Matrix4): Matrix4 {\n    const te = this.elements;\n    const me = m.elements;\n\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    te[9] = me[9];\n    te[10] = me[10];\n    te[11] = me[11];\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    te[15] = me[15];\n\n    return this;\n  }\n\n  copyPosition(m: Matrix4): Matrix4 {\n    const te = this.elements,\n      me = m.elements;\n\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n\n    return this;\n  }\n\n  setFromMatrix3(m: Matrix3): Matrix4 {\n    const me = m.elements;\n\n    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4 {\n    xAxis.setFromMatrixColumn(this, 0);\n    yAxis.setFromMatrixColumn(this, 1);\n    zAxis.setFromMatrixColumn(this, 2);\n\n    return this;\n  }\n\n  makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4 {\n    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  extractRotation(m: Matrix4): Matrix4 {\n    // this method does not support reflection matrices\n\n    const te = this.elements;\n    const me = m.elements;\n\n    const scaleX: f32 = 1 / _v1.setFromMatrixColumn(m, 0).length();\n    const scaleY: f32 = 1 / _v1.setFromMatrixColumn(m, 1).length();\n    const scaleZ: f32 = 1 / _v1.setFromMatrixColumn(m, 2).length();\n\n    te[0] = me[0] * scaleX;\n    te[1] = me[1] * scaleX;\n    te[2] = me[2] * scaleX;\n    te[3] = 0;\n\n    te[4] = me[4] * scaleY;\n    te[5] = me[5] * scaleY;\n    te[6] = me[6] * scaleY;\n    te[7] = 0;\n\n    te[8] = me[8] * scaleZ;\n    te[9] = me[9] * scaleZ;\n    te[10] = me[10] * scaleZ;\n    te[11] = 0;\n\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n\n    return this;\n  }\n\n  makeRotationFromEuler(euler: Euler): Matrix4 {\n    if (!(euler && euler.isEuler)) {\n      console.error(\n        \"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\"\n      );\n    }\n\n    const te = this.elements;\n\n    const x = euler.x,\n      y = euler.y,\n      z = euler.z;\n    const a = Mathf.cos(x),\n      b = Mathf.sin(x);\n    const c = Mathf.cos(y),\n      d = Mathf.sin(y);\n    const e = Mathf.cos(z),\n      f = Mathf.sin(z);\n\n    if (euler.order === EulerRotationOrder.XYZ) {\n      const ae = a * e,\n        af = a * f,\n        be = b * e,\n        bf = b * f;\n\n      te[0] = c * e;\n      te[4] = -c * f;\n      te[8] = d;\n\n      te[1] = af + be * d;\n      te[5] = ae - bf * d;\n      te[9] = -b * c;\n\n      te[2] = bf - ae * d;\n      te[6] = be + af * d;\n      te[10] = a * c;\n    } else if (euler.order === EulerRotationOrder.YXZ) {\n      const ce = c * e,\n        cf = c * f,\n        de = d * e,\n        df = d * f;\n\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a * d;\n\n      te[1] = a * f;\n      te[5] = a * e;\n      te[9] = -b;\n\n      te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a * c;\n    } else if (euler.order === EulerRotationOrder.ZXY) {\n      const ce = c * e,\n        cf = c * f,\n        de = d * e,\n        df = d * f;\n\n      te[0] = ce - df * b;\n      te[4] = -a * f;\n      te[8] = de + cf * b;\n\n      te[1] = cf + de * b;\n      te[5] = a * e;\n      te[9] = df - ce * b;\n\n      te[2] = -a * d;\n      te[6] = b;\n      te[10] = a * c;\n    } else if (euler.order === EulerRotationOrder.ZYX) {\n      const ae = a * e,\n        af = a * f,\n        be = b * e,\n        bf = b * f;\n\n      te[0] = c * e;\n      te[4] = be * d - af;\n      te[8] = ae * d + bf;\n\n      te[1] = c * f;\n      te[5] = bf * d + ae;\n      te[9] = af * d - be;\n\n      te[2] = -d;\n      te[6] = b * c;\n      te[10] = a * c;\n    } else if (euler.order === EulerRotationOrder.YZX) {\n      const ac = a * c,\n        ad = a * d,\n        bc = b * c,\n        bd = b * d;\n\n      te[0] = c * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + ad;\n\n      te[1] = f;\n      te[5] = a * e;\n      te[9] = -b * e;\n\n      te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n    } else if (euler.order === EulerRotationOrder.XZY) {\n      const ac = a * c,\n        ad = a * d,\n        bc = b * c,\n        bd = b * d;\n\n      te[0] = c * e;\n      te[4] = -f;\n      te[8] = d * e;\n\n      te[1] = ac * f + bd;\n      te[5] = a * e;\n      te[9] = ad * f - bc;\n\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      te[10] = bd * f + ac;\n    }\n\n    // bottom row\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n\n    // last column\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n\n    return this;\n  }\n\n  makeRotationFromQuaternion(q: Quaternion): Matrix4 {\n    return this.compose(_zero, q, _one);\n  }\n\n  lookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix4 {\n    const te = this.elements;\n\n    _z.subVectors(eye, target);\n\n    if (_z.lengthSq() === 0) {\n      // eye and target are in the same position\n\n      _z.z = 1;\n    }\n\n    _z.normalize();\n    _x.crossVectors(up, _z);\n\n    if (_x.lengthSq() === 0) {\n      // up and z are parallel\n\n      if (Mathf.abs(up.z) === 1) {\n        _z.x += 0.0001;\n      } else {\n        _z.z += 0.0001;\n      }\n\n      _z.normalize();\n      _x.crossVectors(up, _z);\n    }\n\n    _x.normalize();\n    _y.crossVectors(_z, _x);\n\n    te[0] = _x.x;\n    te[4] = _y.x;\n    te[8] = _z.x;\n    te[1] = _x.y;\n    te[5] = _y.y;\n    te[9] = _z.y;\n    te[2] = _x.z;\n    te[6] = _y.z;\n    te[10] = _z.z;\n\n    return this;\n  }\n\n  multiply(m: Matrix4): Matrix4 {\n    return this.multiplyMatrices(this, m);\n  }\n\n  premultiply(m: Matrix4): Matrix4 {\n    return this.multiplyMatrices(m, this);\n  }\n\n  multiplyMatrices(a: Matrix4, b: Matrix4): Matrix4 {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n\n    const a11 = ae[0],\n      a12 = ae[4],\n      a13 = ae[8],\n      a14 = ae[12];\n    const a21 = ae[1],\n      a22 = ae[5],\n      a23 = ae[9],\n      a24 = ae[13];\n    const a31 = ae[2],\n      a32 = ae[6],\n      a33 = ae[10],\n      a34 = ae[14];\n    const a41 = ae[3],\n      a42 = ae[7],\n      a43 = ae[11],\n      a44 = ae[15];\n\n    const b11 = be[0],\n      b12 = be[4],\n      b13 = be[8],\n      b14 = be[12];\n    const b21 = be[1],\n      b22 = be[5],\n      b23 = be[9],\n      b24 = be[13];\n    const b31 = be[2],\n      b32 = be[6],\n      b33 = be[10],\n      b34 = be[14];\n    const b41 = be[3],\n      b42 = be[7],\n      b43 = be[11],\n      b44 = be[15];\n\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n    return this;\n  }\n\n  multiplyScalar(s: f32): Matrix4 {\n    const te = this.elements;\n\n    te[0] *= s;\n    te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] *= s;\n    te[15] *= s;\n\n    return this;\n  }\n\n  determinant(): f32 {\n    const te = this.elements;\n\n    const n11 = te[0],\n      n12 = te[4],\n      n13 = te[8],\n      n14 = te[12];\n    const n21 = te[1],\n      n22 = te[5],\n      n23 = te[9],\n      n24 = te[13];\n    const n31 = te[2],\n      n32 = te[6],\n      n33 = te[10],\n      n34 = te[14];\n    const n41 = te[3],\n      n42 = te[7],\n      n43 = te[11],\n      n44 = te[15];\n\n    //TODO: make this more efficient\n    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n    return (\n      n41 *\n        (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) +\n      n42 *\n        (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) +\n      n43 *\n        (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) +\n      n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31)\n    );\n  }\n\n  transpose(): Matrix4 {\n    const te = this.elements;\n    let tmp: f32;\n\n    tmp = te[1];\n    te[1] = te[4];\n    te[4] = tmp;\n    tmp = te[2];\n    te[2] = te[8];\n    te[8] = tmp;\n    tmp = te[6];\n    te[6] = te[9];\n    te[9] = tmp;\n\n    tmp = te[3];\n    te[3] = te[12];\n    te[12] = tmp;\n    tmp = te[7];\n    te[7] = te[13];\n    te[13] = tmp;\n    tmp = te[11];\n    te[11] = te[14];\n    te[14] = tmp;\n\n    return this;\n  }\n\n  setPosition(x: f32, y: f32, z: f32): Matrix4 {\n    const te = this.elements;\n\n    te[12] = x;\n    te[13] = y;\n    te[14] = z;\n\n    return this;\n  }\n\n  invert(): Matrix4 {\n    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n    const te = this.elements,\n      n11: f32 = te[0],\n      n21: f32 = te[1],\n      n31: f32 = te[2],\n      n41: f32 = te[3],\n      n12: f32 = te[4],\n      n22: f32 = te[5],\n      n32: f32 = te[6],\n      n42: f32 = te[7],\n      n13: f32 = te[8],\n      n23: f32 = te[9],\n      n33: f32 = te[10],\n      n43: f32 = te[11],\n      n14: f32 = te[12],\n      n24: f32 = te[13],\n      n34: f32 = te[14],\n      n44: f32 = te[15],\n      t11: f32 =\n        n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n      t12: f32 =\n        n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n      t13: f32 =\n        n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n      t14: f32 =\n        n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n    const det: f32 = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n    const detInv: f32 = 1 / det;\n\n    te[0] = t11 * detInv;\n    te[1] =\n      (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) *\n      detInv;\n    te[2] =\n      (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) *\n      detInv;\n    te[3] =\n      (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) *\n      detInv;\n\n    te[4] = t12 * detInv;\n    te[5] =\n      (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) *\n      detInv;\n    te[6] =\n      (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) *\n      detInv;\n    te[7] =\n      (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) *\n      detInv;\n\n    te[8] = t13 * detInv;\n    te[9] =\n      (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) *\n      detInv;\n    te[10] =\n      (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) *\n      detInv;\n    te[11] =\n      (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) *\n      detInv;\n\n    te[12] = t14 * detInv;\n    te[13] =\n      (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) *\n      detInv;\n    te[14] =\n      (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) *\n      detInv;\n    te[15] =\n      (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) *\n      detInv;\n\n    return this;\n  }\n\n  scale(v: Vector3): Matrix4 {\n    const te = this.elements;\n    const x: f32 = v.x,\n      y: f32 = v.y,\n      z: f32 = v.z;\n\n    te[0] *= x;\n    te[4] *= y;\n    te[8] *= z;\n    te[1] *= x;\n    te[5] *= y;\n    te[9] *= z;\n    te[2] *= x;\n    te[6] *= y;\n    te[10] *= z;\n    te[3] *= x;\n    te[7] *= y;\n    te[11] *= z;\n\n    return this;\n  }\n\n  getMaxScaleOnAxis(): f32 {\n    const te = this.elements;\n\n    const scaleXSq: f32 = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    const scaleYSq: f32 = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n    const scaleZSq: f32 = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\n    //Mathf.max only takes two arguments, have to do it twice.\n    let maxScale: f32 = Mathf.max(scaleXSq, scaleYSq);\n    maxScale = Mathf.max(maxScale, scaleZSq);\n    return Mathf.sqrt(maxScale);\n  }\n\n  makeTranslation(x: f32, y: f32, z: f32): Matrix4 {\n    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  makeRotationX(theta: f32): Matrix4 {\n    const c: f32 = Mathf.cos(theta),\n      s: f32 = Mathf.sin(theta);\n\n    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  makeRotationY(theta: f32): Matrix4 {\n    const c: f32 = Mathf.cos(theta),\n      s: f32 = Mathf.sin(theta);\n\n    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  makeRotationZ(theta: f32): Matrix4 {\n    const c: f32 = Mathf.cos(theta),\n      s: f32 = Mathf.sin(theta);\n\n    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  makeRotationAxis(axis: Vector3, angle: f32): Matrix4 {\n    // Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n    const c: f32 = Mathf.cos(angle);\n    const s: f32 = Mathf.sin(angle);\n    const t: f32 = 1 - c;\n    const x: f32 = axis.x,\n      y: f32 = axis.y,\n      z: f32 = axis.z;\n    const tx: f32 = t * x,\n      ty: f32 = t * y;\n\n    this.set(\n      tx * x + c,\n      tx * y - s * z,\n      tx * z + s * y,\n      0,\n      tx * y + s * z,\n      ty * y + c,\n      ty * z - s * x,\n      0,\n      tx * z - s * y,\n      ty * z + s * x,\n      t * z * z + c,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n\n    return this;\n  }\n\n  makeScale(x: f32, y: f32, z: f32): Matrix4 {\n    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  makeShear(xy: f32, xz: f32, yx: f32, yz: f32, zx: f32, zy: f32): Matrix4 {\n    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);\n\n    return this;\n  }\n\n  compose(position: Vector3, quaternion: Quaternion, scale: Vector3): Matrix4 {\n    const te = this.elements;\n\n    const x: f32 = quaternion._x,\n      y: f32 = quaternion._y,\n      z: f32 = quaternion._z,\n      w: f32 = quaternion._w;\n    const x2: f32 = x + x,\n      y2: f32 = y + y,\n      z2: f32 = z + z;\n    const xx: f32 = x * x2,\n      xy: f32 = x * y2,\n      xz: f32 = x * z2;\n    const yy: f32 = y * y2,\n      yz: f32 = y * z2,\n      zz: f32 = z * z2;\n    const wx = w * x2,\n      wy: f32 = w * y2,\n      wz: f32 = w * z2;\n\n    const sx: f32 = scale.x,\n      sy: f32 = scale.y,\n      sz: f32 = scale.z;\n\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n\n    te[12] = position.x;\n    te[13] = position.y;\n    te[14] = position.z;\n    te[15] = 1;\n\n    return this;\n  }\n\n  decompose(position: Vector3, quaternion: Quaternion, scale: Vector3): Matrix4 {\n    const te = this.elements;\n\n    let sx: f32 = _v1.set(te[0], te[1], te[2]).length();\n    const sy: f32 = _v1.set(te[4], te[5], te[6]).length();\n    const sz: f32 = _v1.set(te[8], te[9], te[10]).length();\n\n    // if determine is negative, we need to invert one scale\n    const det: f32 = this.determinant();\n    if (det < 0) sx = -sx;\n\n    position.x = te[12];\n    position.y = te[13];\n    position.z = te[14];\n\n    // scale the rotation part\n    _m1.copy(this);\n\n    const invSX: f32 = 1 / sx;\n    const invSY: f32 = 1 / sy;\n    const invSZ: f32 = 1 / sz;\n\n    _m1.elements[0] *= invSX;\n    _m1.elements[1] *= invSX;\n    _m1.elements[2] *= invSX;\n\n    _m1.elements[4] *= invSY;\n    _m1.elements[5] *= invSY;\n    _m1.elements[6] *= invSY;\n\n    _m1.elements[8] *= invSZ;\n    _m1.elements[9] *= invSZ;\n    _m1.elements[10] *= invSZ;\n\n    quaternion.setFromRotationMatrix(_m1);\n\n    scale.x = sx;\n    scale.y = sy;\n    scale.z = sz;\n\n    return this;\n  }\n\n  makePerspective(left: f32, right: f32, top: f32, bottom: f32, near: f32, far: f32): Matrix4 {\n    const te = this.elements;\n    const x: f32 = (2 * near) / (right - left);\n    const y: f32 = (2 * near) / (top - bottom);\n\n    const a: f32 = (right + left) / (right - left);\n    const b: f32 = (top + bottom) / (top - bottom);\n    const c: f32 = -(far + near) / (far - near);\n    const d: f32 = (-2 * far * near) / (far - near);\n\n    te[0] = x;\n    te[4] = 0;\n    te[8] = a;\n    te[12] = 0;\n    te[1] = 0;\n    te[5] = y;\n    te[9] = b;\n    te[13] = 0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = c;\n    te[14] = d;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    te[15] = 0;\n\n    return this;\n  }\n\n  makeOrthographic(left: f32, right: f32, top: f32, bottom: f32, near: f32, far: f32): Matrix4 {\n    const te = this.elements;\n    const w: f32 = 1.0 / (right - left);\n    const h: f32 = 1.0 / (top - bottom);\n    const p: f32 = 1.0 / (far - near);\n\n    const x: f32 = (right + left) * w;\n    const y: f32 = (top + bottom) * h;\n    const z: f32 = (far + near) * p;\n\n    te[0] = 2 * w;\n    te[4] = 0;\n    te[8] = 0;\n    te[12] = -x;\n    te[1] = 0;\n    te[5] = 2 * h;\n    te[9] = 0;\n    te[13] = -y;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = -2 * p;\n    te[14] = -z;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[15] = 1;\n\n    return this;\n  }\n\n  equals(matrix: Matrix4): boolean {\n    const te = this.elements;\n    const me = matrix.elements;\n\n    for (let i: u8 = 0; i < 16; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n\n    return true;\n  }\n\n  fromArray(array: Float32Array, offset: u32 = 0): Matrix4 {\n    for (let i: u8 = 0; i < 16; i++) {\n      this.elements[i] = array[i + offset];\n    }\n\n    return this;\n  }\n\n  toArray(array: Float32Array, offset: u32 = 0): Float32Array {\n    const te = this.elements;\n\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n\n    array[offset + 8] = te[8];\n    array[offset + 9] = te[9];\n    array[offset + 10] = te[10];\n    array[offset + 11] = te[11];\n\n    array[offset + 12] = te[12];\n    array[offset + 13] = te[13];\n    array[offset + 14] = te[14];\n    array[offset + 15] = te[15];\n\n    return array;\n  }\n}\n\nconst _v1 = new Vector3();\nconst _m1 = new Matrix4();\nconst _zero = new Vector3(0, 0, 0);\nconst _one = new Vector3(1, 1, 1);\nconst _x = new Vector3();\nconst _y = new Vector3();\nconst _z = new Vector3();\n","import { Euler } from \"../math/Euler\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Matrix3 } from \"../math/Matrix3\";\nimport { Quaternion } from \"../math/Quaternion\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { Event } from \"./Event\";\nimport { EventDispatcher } from \"./EventDispatcher\";\nimport { Layers } from \"./Layers\";\nimport * as MathUtils from \"../math/MathUtils\";\nimport { Camera } from \"../cameras/Camera\";\nimport { Light } from \"../lights/Light\";\nimport { Raycaster } from \"./Raycaster\";\nimport { Intersection } from \"../objects/Mesh\";\n\nlet object3DId: i32 = 1;\n\nconst _v1 = new Vector3();\nconst _q1 = new Quaternion();\nconst _m1 = new Matrix4();\nconst _target = new Vector3();\n\nconst _position = new Vector3();\nconst _scale = new Vector3();\nconst _quaternion = new Quaternion();\n\nconst _xAxis = new Vector3(1, 0, 0);\nconst _yAxis = new Vector3(0, 1, 0);\nconst _zAxis = new Vector3(0, 0, 1);\n\ntype TraverseCallback = (object: Object) => void;\nconst _addedEvent: Event = new Event(\"added\");\nconst _removedEvent: Event = new Event(\"removed\");\n\nexport class Object extends EventDispatcher {\n  static DefaultUp: Vector3 = new Vector3(0, 1, 0);\n  static DefaultMatrixAutoUpdate: boolean = true;\n\n  uuid: string = MathUtils.generateUUID();\n  name: string;\n  type: string;\n  parent: Object | null;\n  children: Object[];\n  matrix: Matrix4;\n  matrixWorld: Matrix4;\n  up: Vector3;\n  castShadow: boolean;\n  receiveShadow: boolean;\n  frustumCulled: boolean;\n  renderOrder: i32;\n  // animations = [];\n  // TODO:\n  // userData: any;\n  matrixAutoUpdate: boolean;\n  visible: boolean;\n  matrixWorldNeedsUpdate: boolean;\n  layers: Layers;\n\n  id: i32 = object3DId++;\n\n  readonly position: Vector3;\n  readonly rotation: Euler;\n  readonly quaternion: Quaternion;\n  readonly scale: Vector3;\n  readonly modelViewMatrix: Matrix4;\n  readonly normalMatrix: Matrix3;\n\n  constructor() {\n    super();\n    this.position = new Vector3();\n    this.rotation = new Euler();\n    this.quaternion = new Quaternion();\n    this.scale = new Vector3(1, 1, 1);\n    this.modelViewMatrix = new Matrix4();\n    this.normalMatrix = new Matrix3();\n\n    this.uuid = MathUtils.generateUUID();\n\n    this.name = \"\";\n    this.type = \"Object3D\";\n\n    this.parent = null;\n    this.children = [];\n\n    this.up = Object.DefaultUp.clone();\n\n    this.matrix = new Matrix4();\n    this.matrixWorld = new Matrix4();\n\n    this.matrixAutoUpdate = Object.DefaultMatrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = false;\n\n    this.layers = new Layers();\n    this.visible = true;\n\n    this.castShadow = false;\n    this.receiveShadow = false;\n\n    this.frustumCulled = true;\n    this.renderOrder = 0;\n\n    // this.animations = [];\n\n    // this.transform = new Transform();\n    this.rotation._onChange(this);\n    this.quaternion._onChange(this);\n  }\n\n  onEulerChanged(euler: Euler): void {\n    this.quaternion.setFromEuler(euler, false);\n  }\n\n  onQuatChanged(quat: Quaternion): void {\n    this.rotation.setFromQuaternion(quat, Euler.DefaultOrder, false);\n  }\n\n  onBeforeRender(): void {}\n  onAfterRender(): void {}\n\n  applyMatrix4(matrix: Matrix4): void {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    this.matrix.premultiply(matrix);\n\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n  }\n\n  applyQuaternion(q: Quaternion): Object {\n    this.quaternion.premultiply(q);\n\n    return this;\n  }\n\n  setRotationFromAxisAngle(axis: Vector3, angle: f32): void {\n    // assumes axis is normalized\n\n    this.quaternion.setFromAxisAngle(axis, angle);\n  }\n\n  setRotationFromEuler(euler: Euler): void {\n    this.quaternion.setFromEuler(euler, true);\n  }\n\n  setRotationFromMatrix(m: Matrix4): void {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    this.quaternion.setFromRotationMatrix(m);\n  }\n\n  setRotationFromQuaternion(q: Quaternion): void {\n    // assumes q is normalized\n\n    this.quaternion.copy(q);\n  }\n\n  rotateOnAxis(axis: Vector3, angle: f32): Object {\n    // rotate object on axis in object space\n    // axis is assumed to be normalized\n\n    _q1.setFromAxisAngle(axis, angle);\n\n    this.quaternion.multiply(_q1);\n\n    return this;\n  }\n\n  rotateOnWorldAxis(axis: Vector3, angle: f32): Object {\n    // rotate object on axis in world space\n    // axis is assumed to be normalized\n    // method assumes no rotated parent\n\n    _q1.setFromAxisAngle(axis, angle);\n\n    this.quaternion.premultiply(_q1);\n\n    return this;\n  }\n\n  rotateX(angle: f32): Object {\n    return this.rotateOnAxis(_xAxis, angle);\n  }\n\n  rotateY(angle: f32): Object {\n    return this.rotateOnAxis(_yAxis, angle);\n  }\n\n  rotateZ(angle: f32): Object {\n    return this.rotateOnAxis(_zAxis, angle);\n  }\n\n  translateOnAxis(axis: Vector3, distance: f32): Object {\n    // translate object by distance along axis in object space\n    // axis is assumed to be normalized\n\n    _v1.copy(axis).applyQuaternion(this.quaternion);\n\n    this.position.add(_v1.multiplyScalar(distance));\n\n    return this;\n  }\n\n  translateX(distance: f32): Object {\n    return this.translateOnAxis(_xAxis, distance);\n  }\n\n  translateY(distance: f32): Object {\n    return this.translateOnAxis(_yAxis, distance);\n  }\n\n  translateZ(distance: f32): Object {\n    return this.translateOnAxis(_zAxis, distance);\n  }\n\n  localToWorld(vector: Vector3): Vector3 {\n    return vector.applyMatrix4(this.matrixWorld);\n  }\n\n  worldToLocal(vector: Vector3): Vector3 {\n    return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());\n  }\n\n  lookAt(x: f32, y: f32, z: f32): void {\n    // This method does not support objects having non-uniformly-scaled parent(s)\n\n    _target.set(x, y, z);\n\n    const parent = this.parent;\n\n    this.updateWorldMatrix(true, false);\n\n    _position.setFromMatrixPosition(this.matrixWorld);\n\n    if (this instanceof Camera || this instanceof Light) {\n      _m1.lookAt(_position, _target, this.up);\n    } else {\n      _m1.lookAt(_target, _position, this.up);\n    }\n\n    this.quaternion.setFromRotationMatrix(_m1);\n\n    if (parent) {\n      _m1.extractRotation(parent.matrixWorld);\n      _q1.setFromRotationMatrix(_m1);\n      this.quaternion.premultiply(_q1.invert());\n    }\n  }\n\n  add(object: Object): Object {\n    if (object === this) throw new Error(\"Object can't be added as a child of itself.\");\n\n    if (object.parent !== null) {\n      object.parent!.remove(object);\n    }\n\n    object.parent = this;\n    this.children.push(object);\n\n    _addedEvent.target = this;\n    object.dispatchEvent(_addedEvent);\n\n    return this;\n  }\n\n  remove(object: Object): Object {\n    const index = this.children.indexOf(object);\n\n    if (index !== -1) {\n      object.parent = null;\n      this.children.splice(index, 1);\n\n      _removedEvent.target = this;\n      object.dispatchEvent(_removedEvent);\n    }\n\n    return this;\n  }\n\n  removeFromParent(): Object {\n    const parent = this.parent;\n\n    if (parent !== null) parent.remove(this);\n\n    return this;\n  }\n\n  clear(): Object {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const object = children[i];\n      object.parent = null;\n      object.dispatchEvent(_removedEvent);\n    }\n\n    this.children.length = 0;\n\n    return this;\n  }\n\n  attach(object: Object): Object {\n    // adds object as a child of this, while maintaining the object's world transform\n\n    this.updateWorldMatrix(true, false);\n\n    _m1.copy(this.matrixWorld).invert();\n\n    const objectParent = object.parent;\n    if (objectParent != null) {\n      objectParent.updateWorldMatrix(true, false);\n\n      _m1.multiply(objectParent.matrixWorld);\n    }\n\n    object.applyMatrix4(_m1);\n\n    this.add(object);\n\n    object.updateWorldMatrix(false, true);\n\n    return this;\n  }\n\n  // TODO\n  // getObjectById(id: string) {\n  //   return this.getObjectByProperty(\"id\", id);\n  // }\n\n  // getObjectByName(name: string) {\n  //   return this.getObjectByProperty(\"name\", name);\n  // }\n\n  // getObjectByProperty(name: string, value) {\n  //   if (this[name] === value) return this;\n\n  //   for (let i = 0, l = this.children.length; i < l; i++) {\n  //     const child = this.children[i];\n  //     const object = child.getObjectByProperty(name, value);\n\n  //     if (object !== undefined) {\n  //       return object;\n  //     }\n  //   }\n\n  //   return undefined;\n  // }\n\n  getWorldPosition(target: Vector3): Vector3 {\n    this.updateWorldMatrix(true, false);\n\n    return target.setFromMatrixPosition(this.matrixWorld);\n  }\n\n  getWorldQuaternion(target: Quaternion): Quaternion {\n    this.updateWorldMatrix(true, false);\n\n    this.matrixWorld.decompose(_position, target, _scale);\n\n    return target;\n  }\n\n  getWorldScale(target: Vector3): Vector3 {\n    this.updateWorldMatrix(true, false);\n\n    this.matrixWorld.decompose(_position, _quaternion, target);\n\n    return target;\n  }\n\n  getWorldDirection(target: Vector3): Vector3 {\n    this.updateWorldMatrix(true, false);\n\n    const e = this.matrixWorld.elements;\n\n    return target.set(e[8], e[9], e[10]).normalize();\n  }\n\n  raycast(raycaster: Raycaster, intersects: Intersection[]): void {}\n\n  traverse(callback: TraverseCallback): void {\n    callback(this);\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverse(callback);\n    }\n  }\n\n  traverseVisible(callback: TraverseCallback): void {\n    if (this.visible === false) return;\n\n    callback(this);\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverseVisible(callback);\n    }\n  }\n\n  traverseAncestors(callback: TraverseCallback): void {\n    const parent = this.parent;\n\n    if (parent !== null) {\n      callback(parent);\n\n      parent.traverseAncestors(callback);\n    }\n  }\n\n  updateMatrix(): void {\n    this.matrix.compose(this.position, this.quaternion, this.scale);\n\n    this.matrixWorldNeedsUpdate = true;\n  }\n\n  updateMatrixWorld(force: boolean = false): void {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent!.matrixWorld, this.matrix);\n      }\n\n      this.matrixWorldNeedsUpdate = false;\n\n      force = true;\n    }\n\n    // update children\n\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].updateMatrixWorld(force);\n    }\n  }\n\n  updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void {\n    const parent = this.parent;\n\n    if (updateParents === true && parent !== null) {\n      parent.updateWorldMatrix(true, false);\n    }\n\n    if (this.matrixAutoUpdate) this.updateMatrix();\n\n    if (this.parent === null) {\n      this.matrixWorld.copy(this.matrix);\n    } else {\n      this.matrixWorld.multiplyMatrices(this.parent!.matrixWorld, this.matrix);\n    }\n\n    // update children\n\n    if (updateChildren === true) {\n      const children = this.children;\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateWorldMatrix(false, true);\n      }\n    }\n  }\n\n  clone(recursive: boolean = false): Object {\n    return new Object().copy(this, recursive);\n  }\n\n  copy(source: Object, recursive: boolean = true): Object {\n    this.name = source.name;\n\n    this.up.copy(source.up);\n\n    this.position.copy(source.position);\n    this.rotation.order = source.rotation.order;\n    this.quaternion.copy(source.quaternion);\n    this.scale.copy(source.scale);\n\n    this.matrix.copy(source.matrix);\n    this.matrixWorld.copy(source.matrixWorld);\n\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n    this.layers.mask = source.layers.mask;\n    this.visible = source.visible;\n\n    this.castShadow = source.castShadow;\n    this.receiveShadow = source.receiveShadow;\n\n    this.frustumCulled = source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n\n    // TODO:\n    // this.userData = JSON.parse(JSON.stringify(source.userData));\n\n    if (recursive === true) {\n      for (let i = 0; i < source.children.length; i++) {\n        const child = source.children[i];\n        this.add(child.clone());\n      }\n    }\n\n    return this;\n  }\n}\n","import { Quaternion } from \"./Quaternion\";\nimport { Vector3 } from \"./Vector3\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { clamp } from \"./MathUtils\";\nimport { Object } from \"../core/Object\";\n\nconst _matrix = new Matrix4();\nconst _quaternion = new Quaternion();\n\nexport enum EulerRotationOrder {\n  XYZ = 0,\n  YZX,\n  ZXY,\n  XZY,\n  YXZ,\n  ZYX,\n}\n\nexport class Euler {\n  isEuler: bool = true;\n  _x: f32;\n  _y: f32;\n  _z: f32;\n  _order: EulerRotationOrder;\n  _onChangeCallback: Object | null;\n\n  static DefaultOrder: EulerRotationOrder = 0; // TODO: This is supposed to be EulerRotationOrder.XYZ but it keeps failing >:/\n  static RotationOrders: EulerRotationOrder[] = [\n    EulerRotationOrder.XYZ,\n    EulerRotationOrder.YZX,\n    EulerRotationOrder.ZXY,\n    EulerRotationOrder.XZY,\n    EulerRotationOrder.YXZ,\n    EulerRotationOrder.ZYX,\n  ];\n\n  constructor(x: f32 = 0, y: f32 = 0, z: f32 = 0, order: EulerRotationOrder = Euler.DefaultOrder) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n    this._onChangeCallback = null;\n  }\n\n  get x(): f32 {\n    return this._x;\n  }\n\n  set x(value: f32) {\n    this._x = value;\n    this.onChangeCallback();\n  }\n\n  get y(): f32 {\n    return this._y;\n  }\n\n  set y(value: f32) {\n    this._y = value;\n    this.onChangeCallback();\n  }\n\n  get z(): f32 {\n    return this._z;\n  }\n\n  set z(value: f32) {\n    this._z = value;\n    this.onChangeCallback();\n  }\n\n  get order(): EulerRotationOrder {\n    return this._order;\n  }\n\n  set order(value: EulerRotationOrder) {\n    this._order = value;\n    this.onChangeCallback();\n  }\n\n  set(x: f32, y: f32, z: f32, order: EulerRotationOrder): Euler {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order || this._order;\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  clone(): Euler {\n    return new Euler(this._x, this._y, this._z, this._order);\n  }\n\n  copy(euler: Euler): Euler {\n    this._x = euler._x;\n    this._y = euler._y;\n    this._z = euler._z;\n    this._order = euler._order;\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  setFromRotationMatrix(m: Matrix4, order: EulerRotationOrder = Euler.DefaultOrder, update: boolean = true): Euler {\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    const te = m.elements;\n    const m11 = te[0],\n      m12 = te[4],\n      m13 = te[8];\n    const m21 = te[1],\n      m22 = te[5],\n      m23 = te[9];\n    const m31 = te[2],\n      m32 = te[6],\n      m33 = te[10];\n\n    order = order || this._order;\n\n    switch (order) {\n      case EulerRotationOrder.XYZ:\n        this._y = Mathf.asin(clamp(m13, -1, 1));\n\n        if (Mathf.abs(m13) < 0.9999999) {\n          this._x = Mathf.atan2(-m23, m33);\n          this._z = Mathf.atan2(-m12, m11);\n        } else {\n          this._x = Mathf.atan2(m32, m22);\n          this._z = 0;\n        }\n\n        break;\n\n      case EulerRotationOrder.YXZ:\n        this._x = Mathf.asin(-clamp(m23, -1, 1));\n\n        if (Mathf.abs(m23) < 0.9999999) {\n          this._y = Mathf.atan2(m13, m33);\n          this._z = Mathf.atan2(m21, m22);\n        } else {\n          this._y = Mathf.atan2(-m31, m11);\n          this._z = 0;\n        }\n\n        break;\n\n      case EulerRotationOrder.ZXY:\n        this._x = Mathf.asin(clamp(m32, -1, 1));\n\n        if (Mathf.abs(m32) < 0.9999999) {\n          this._y = Mathf.atan2(-m31, m33);\n          this._z = Mathf.atan2(-m12, m22);\n        } else {\n          this._y = 0;\n          this._z = Mathf.atan2(m21, m11);\n        }\n\n        break;\n\n      case EulerRotationOrder.ZYX:\n        this._y = Mathf.asin(-clamp(m31, -1, 1));\n\n        if (Mathf.abs(m31) < 0.9999999) {\n          this._x = Mathf.atan2(m32, m33);\n          this._z = Mathf.atan2(m21, m11);\n        } else {\n          this._x = 0;\n          this._z = Mathf.atan2(-m12, m22);\n        }\n\n        break;\n\n      case EulerRotationOrder.YZX:\n        this._z = Mathf.asin(clamp(m21, -1, 1));\n\n        if (Mathf.abs(m21) < 0.9999999) {\n          this._x = Mathf.atan2(-m23, m22);\n          this._y = Mathf.atan2(-m31, m11);\n        } else {\n          this._x = 0;\n          this._y = Mathf.atan2(m13, m33);\n        }\n\n        break;\n\n      case EulerRotationOrder.XZY:\n        this._z = Mathf.asin(-clamp(m12, -1, 1));\n\n        if (Mathf.abs(m12) < 0.9999999) {\n          this._x = Mathf.atan2(m32, m22);\n          this._y = Mathf.atan2(m13, m11);\n        } else {\n          this._x = Mathf.atan2(-m23, m33);\n          this._y = 0;\n        }\n\n        break;\n\n      default:\n        throw new Error(`THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ${order}`);\n    }\n\n    this._order = order;\n\n    if (update !== false) this.onChangeCallback();\n\n    return this;\n  }\n\n  setFromQuaternion(q: Quaternion, order: EulerRotationOrder = Euler.DefaultOrder, update: boolean = true): Euler {\n    _matrix.makeRotationFromQuaternion(q);\n\n    return this.setFromRotationMatrix(_matrix, order, update);\n  }\n\n  setFromVector3(v: Vector3, order: EulerRotationOrder): Euler {\n    return this.set(v.x, v.y, v.z, order || this._order);\n  }\n\n  reorder(newOrder: EulerRotationOrder): Euler {\n    // WARNING: this discards revolution information -bhouston\n\n    _quaternion.setFromEuler(this, false);\n\n    return this.setFromQuaternion(_quaternion, newOrder, false);\n  }\n\n  equals(euler: Euler): boolean {\n    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n  }\n\n  fromArray(array: f32[]): Euler {\n    this._x = array[0];\n    this._y = array[1];\n    this._z = array[2];\n    if (array[3] !== undefined) this._order = array[3];\n\n    this.onChangeCallback();\n\n    return this;\n  }\n\n  toArray(array: f32[] = [], offset: u32 = 0): f32[] {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._order;\n\n    return array;\n  }\n\n  toVector3(optionalResult: Vector3): Vector3 {\n    if (optionalResult) {\n      return optionalResult.set(this._x, this._y, this._z);\n    } else {\n      return new Vector3(this._x, this._y, this._z);\n    }\n  }\n\n  private onChangeCallback(): void {\n    if (this._onChangeCallback) this._onChangeCallback!.onEulerChanged(this);\n  }\n\n  _onChange(callback: Object): Euler {\n    this._onChangeCallback = callback;\n\n    return this;\n  }\n}\n","// Total tables size: ~5 kb (usually compressed to ~4 kb)\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/casemap.h\n\n// @ts-ignore: decorator\n@lazy @inline const TAB = memory.data<u8>([\n  7, 8, 9, 10, 11, 12, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  13, 6, 6, 14, 6, 6, 6, 6, 6, 6, 6, 6, 15, 16, 17, 18,\n  6, 19, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 20, 21, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 22, 23, 6, 6, 6, 24, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 25,\n  6, 6, 6, 6, 26, 6, 6, 6, 6, 6, 6, 6, 27, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 28, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 29, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 30, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36,\n  43, 43, 43, 43, 43, 43, 43, 43, 1, 0, 84, 86, 86, 86, 86, 86,\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 43, 43, 43, 43, 43, 43,\n  43, 7, 43, 43, 91, 86, 86, 86, 86, 86, 86, 86, 74, 86, 86, 5,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  36, 80, 121, 49, 80, 49, 80, 49, 56, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 78, 49, 2, 78, 13, 13, 78, 3,\n  78, 0, 36, 110, 0, 78, 49, 38, 110, 81, 78, 36, 80, 78, 57, 20,\n  129, 27, 29, 29, 83, 49, 80, 49, 80, 13, 49, 80, 49, 80, 49, 80,\n  27, 83, 36, 80, 49, 2, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123,\n  20, 121, 92, 123, 92, 123, 92, 45, 43, 73, 3, 72, 3, 120, 92, 123,\n  20, 0, 150, 10, 1, 43, 40, 6, 6, 0, 42, 6, 42, 42, 43, 7,\n  187, 181, 43, 30, 0, 43, 7, 43, 43, 43, 1, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 205, 70, 205, 43, 0, 37, 43, 7, 1, 6, 1, 85, 86, 86, 86,\n  86, 86, 85, 86, 86, 2, 36, 129, 129, 129, 129, 129, 21, 129, 129, 129,\n  0, 0, 43, 0, 178, 209, 178, 209, 178, 209, 178, 209, 0, 0, 205, 204,\n  1, 0, 215, 215, 215, 215, 215, 131, 129, 129, 129, 129, 129, 129, 129, 129,\n  129, 129, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 28, 0, 0, 0,\n  0, 0, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 2, 0, 0,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 78, 49, 80, 49, 80, 78, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 2, 135, 166, 135, 166, 135, 166, 135, 166,\n  135, 166, 135, 166, 135, 166, 135, 166, 42, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 84, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  12, 0, 12, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 7, 42, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 86, 86, 108, 129, 21, 0, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 7, 108, 3, 65, 43, 43, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 86, 86, 86, 44, 86, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 1,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 12, 108, 0, 0, 0, 0, 0, 6,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 86, 122, 158, 38, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 37,\n  6, 37, 6, 37, 6, 37, 6, 37, 6, 37, 6, 1, 43, 43, 79, 86,\n  86, 44, 43, 127, 86, 86, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\n  86, 44, 43, 127, 86, 86, 129, 55, 117, 91, 123, 92, 43, 43, 79, 86,\n  86, 2, 172, 4, 0, 0, 57, 43, 43, 85, 86, 86, 43, 43, 79, 86,\n  86, 44, 43, 43, 86, 86, 50, 19, 129, 87, 0, 111, 129, 126, 201, 215,\n  126, 45, 129, 129, 14, 126, 57, 127, 111, 87, 0, 129, 129, 126, 21, 0,\n  126, 3, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 43,\n  36, 43, 151, 43, 43, 43, 43, 43, 43, 43, 43, 43, 42, 43, 43, 43,\n  43, 43, 86, 86, 86, 86, 86, 128, 129, 129, 129, 129, 57, 187, 42, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 1, 129, 129, 129, 129, 129, 129, 129, 129,\n  129, 129, 129, 129, 129, 129, 129, 201, 172, 172, 172, 172, 172, 172, 172, 172,\n  172, 172, 172, 172, 172, 172, 172, 208, 13, 0, 78, 49, 2, 180, 193, 193,\n  215, 215, 36, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 215, 215, 83, 193, 71, 212, 215, 215, 215, 5, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 1, 0, 1, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 49, 80, 49, 80, 49, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 13, 0, 0, 0, 0, 0, 36, 80,\n  49, 80, 49, 80, 49, 80, 49, 80, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 121, 92, 123, 92, 123, 79, 123, 92, 123, 92, 123,\n  92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 123, 92, 45,\n  43, 43, 121, 20, 92, 123, 92, 45, 121, 42, 92, 39, 92, 123, 92, 123,\n  92, 123, 164, 0, 10, 180, 92, 123, 92, 123, 79, 3, 120, 56, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 79, 45, 43, 43, 1,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 72, 86, 86, 86, 86,\n  86, 86, 86, 86, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 85, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 36, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n  43, 43, 7, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 43, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 7, 0, 0,\n  0, 0, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 86, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 43, 43,\n  43, 43, 43, 43, 43, 43, 43, 43, 86, 86, 86, 86, 86, 86, 86, 86,\n  86, 86, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 86, 86,\n  86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 85,\n  86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 14, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const RULES = memory.data<i32>([\n  0x0, 0x2001, -0x2000, 0x1dbf00, 0x2e700, 0x7900,\n  0x2402, 0x101, -0x100, 0x0, 0x201, -0x200,\n  -0xc6ff, -0xe800, -0x78ff, -0x12c00, 0xc300, 0xd201,\n  0xce01, 0xcd01, 0x4f01, 0xca01, 0xcb01, 0xcf01,\n  0x6100, 0xd301, 0xd101, 0xa300, 0xd501, 0x8200,\n  0xd601, 0xda01, 0xd901, 0xdb01, 0x3800, 0x3,\n  -0x4f00, -0x60ff, -0x37ff, 0x242802, 0x0, 0x101,\n  -0x100, -0xcd00, -0xda00, -0x81ff, 0x2a2b01, -0xa2ff,\n  0x2a2801, 0x2a3f00, -0xc2ff, 0x4501, 0x4701, 0x2a1f00,\n  0x2a1c00, 0x2a1e00, -0xd200, -0xce00, -0xca00, -0xcb00,\n  0xa54f00, 0xa54b00, -0xcf00, 0xa52800, 0xa54400, -0xd100,\n  -0xd300, 0x29f700, 0xa54100, 0x29fd00, -0xd500, -0xd600,\n  0x29e700, 0xa54300, 0xa52a00, -0x4500, -0xd900, -0x4700,\n  -0xdb00, 0xa51500, 0xa51200, 0x4c2402, 0x0, 0x2001,\n  -0x2000, 0x101, -0x100, 0x5400, 0x7401, 0x2601,\n  0x2501, 0x4001, 0x3f01, -0x2600, -0x2500, -0x1f00,\n  -0x4000, -0x3f00, 0x801, -0x3e00, -0x3900, -0x2f00,\n  -0x3600, -0x800, -0x5600, -0x5000, 0x700, -0x7400,\n  -0x3bff, -0x6000, -0x6ff, 0x701a02, 0x101, -0x100,\n  0x2001, -0x2000, 0x5001, 0xf01, -0xf00, 0x0,\n  0x3001, -0x3000, 0x101, -0x100, 0x0, 0xbc000,\n  0x1c6001, 0x0, 0x97d001, 0x801, -0x800, 0x8a0502,\n  0x0, -0xbbfff, -0x186200, 0x89c200, -0x182500, -0x186e00,\n  -0x186d00, -0x186400, -0x186300, -0x185c00, 0x0, 0x8a3800,\n  0x8a0400, 0xee600, 0x101, -0x100, 0x0, -0x3b00,\n  -0x1dbeff, 0x8f1d02, 0x800, -0x7ff, 0x0, 0x5600,\n  -0x55ff, 0x4a00, 0x6400, 0x8000, 0x7000, 0x7e00,\n  0x900, -0x49ff, -0x8ff, -0x1c2500, -0x63ff, -0x6fff,\n  -0x7fff, -0x7dff, 0xac0502, 0x0, 0x1001, -0x1000,\n  0x1c01, 0x101, -0x1d5cff, -0x20beff, -0x2045ff, -0x1c00,\n  0xb10b02, 0x101, -0x100, 0x3001, -0x3000, 0x0,\n  -0x29f6ff, -0xee5ff, -0x29e6ff, -0x2a2b00, -0x2a2800, -0x2a1bff,\n  -0x29fcff, -0x2a1eff, -0x2a1dff, -0x2a3eff, 0x0, -0x1c6000,\n  0x0, 0x101, -0x100, 0xbc0c02, 0x0, 0x101,\n  -0x100, -0xa543ff, 0x3a001, -0x8a03ff, -0xa527ff, 0x3000,\n  -0xa54eff, -0xa54aff, -0xa540ff, -0xa511ff, -0xa529ff, -0xa514ff,\n  -0x2fff, -0xa542ff, -0x8a37ff, 0x0, -0x97d000, -0x3a000,\n  0x0, 0x2001, -0x2000, 0x0, 0x2801, -0x2800,\n  0x0, 0x4001, -0x4000, 0x0, 0x2001, -0x2000,\n  0x0, 0x2001, -0x2000, 0x0, 0x2201, -0x2200\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const RULE_BASES = memory.data<u8>([\n  0, 6, 39, 81, 111, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  124, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 131, 142, 146, 151,\n  0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 180, 196, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 198, 201, 0, 0, 0, 219, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222,\n  0, 0, 0, 0, 225, 0, 0, 0, 0, 0, 0, 0, 228, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 231, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const EXCEPTIONS = memory.data<u8>([\n  48, 12,  49, 13,  120, 14,  127, 15,\n  128, 16,  129, 17,  134, 18,  137, 19,\n  138, 19,  142, 20,  143, 21,  144, 22,\n  147, 19,  148, 23,  149, 24,  150, 25,\n  151, 26,  154, 27,  156, 25,  157, 28,\n  158, 29,  159, 30,  166, 31,  169, 31,\n  174, 31,  177, 32,  178, 32,  183, 33,\n  191, 34,  197, 35,  200, 35,  203, 35,\n  221, 36,  242, 35,  246, 37,  247, 38,\n  32, 45,  58, 46,  61, 47,  62, 48,\n  63, 49,  64, 49,  67, 50,  68, 51,\n  69, 52,  80, 53,  81, 54,  82, 55,\n  83, 56,  84, 57,  89, 58,  91, 59,\n  92, 60,  97, 61,  99, 62,  101, 63,\n  102, 64,  104, 65,  105, 66,  106, 64,\n  107, 67,  108, 68,  111, 66,  113, 69,\n  114, 70,  117, 71,  125, 72,  130, 73,\n  135, 74,  137, 75,  138, 76,  139, 76,\n  140, 77,  146, 78,  157, 79,  158, 80,\n  69, 87,  123, 29,  124, 29,  125, 29,\n  127, 88,  134, 89,  136, 90,  137, 90,\n  138, 90,  140, 91,  142, 92,  143, 92,\n  172, 93,  173, 94,  174, 94,  175, 94,\n  194, 95,  204, 96,  205, 97,  206, 97,\n  207, 98,  208, 99,  209, 100,  213, 101,\n  214, 102,  215, 103,  240, 104,  241, 105,\n  242, 106,  243, 107,  244, 108,  245, 109,\n  249, 110,  253, 45,  254, 45,  255, 45,\n  80, 105,  81, 105,  82, 105,  83, 105,\n  84, 105,  85, 105,  86, 105,  87, 105,\n  88, 105,  89, 105,  90, 105,  91, 105,\n  92, 105,  93, 105,  94, 105,  95, 105,\n  130, 0,  131, 0,  132, 0,  133, 0,\n  134, 0,  135, 0,  136, 0,  137, 0,\n  192, 117,  207, 118,  128, 137,  129, 138,\n  130, 139,  133, 140,  134, 141,  112, 157,\n  113, 157,  118, 158,  119, 158,  120, 159,\n  121, 159,  122, 160,  123, 160,  124, 161,\n  125, 161,  179, 162,  186, 163,  187, 163,\n  188, 164,  190, 165,  195, 162,  204, 164,\n  218, 166,  219, 166,  229, 106,  234, 167,\n  235, 167,  236, 110,  243, 162,  248, 168,\n  249, 168,  250, 169,  251, 169,  252, 164,\n  38, 176,  42, 177,  43, 178,  78,  179,\n  132,  8,  98, 186,  99, 187,  100, 188,\n  101, 189,  102, 190,  109, 191,  110, 192,\n  111, 193,  112, 194,  126, 195,  127, 195,\n  125, 207,  141, 208,  148, 209,  171, 210,\n  172, 211,  173, 212,  176, 213,  177, 214,\n  178, 215,  196, 216,  197, 217,  198, 218\n]);\n\n/* Special Case Mappings\n * See: https://unicode.org/Public/UNIDATA/SpecialCasing.txt\n */\n\n/*\n@lazy @inline\nconst SPECIALS_LOWER: StaticArray<u16> = [\n  0x0130,  0x0069, 0x0307, 0x0000,\n];\n*/\n\n// @ts-ignore: decorator\n@lazy @inlne\nexport const SPECIALS_UPPER: StaticArray<u16> = [\n  // String#toUpperCase needs .length\n  0x00DF,  0x0053, 0x0053, 0x0000,\n  0x0149,  0x02BC, 0x004E, 0x0000,\n  0x01F0,  0x004A, 0x030C, 0x0000,\n  0x0390,  0x0399, 0x0308, 0x0301,\n  0x03B0,  0x03A5, 0x0308, 0x0301,\n  0x0587,  0x0535, 0x0552, 0x0000,\n  0x1E96,  0x0048, 0x0331, 0x0000,\n  0x1E97,  0x0054, 0x0308, 0x0000,\n  0x1E98,  0x0057, 0x030A, 0x0000,\n  0x1E99,  0x0059, 0x030A, 0x0000,\n  0x1E9A,  0x0041, 0x02BE, 0x0000,\n  0x1F50,  0x03A5, 0x0313, 0x0000,\n  0x1F52,  0x03A5, 0x0313, 0x0300,\n  0x1F54,  0x03A5, 0x0313, 0x0301,\n  0x1F56,  0x03A5, 0x0313, 0x0342,\n  0x1F80,  0x1F08, 0x0399, 0x0000,\n  0x1F81,  0x1F09, 0x0399, 0x0000,\n  0x1F82,  0x1F0A, 0x0399, 0x0000,\n  0x1F83,  0x1F0B, 0x0399, 0x0000,\n  0x1F84,  0x1F0C, 0x0399, 0x0000,\n  0x1F85,  0x1F0D, 0x0399, 0x0000,\n  0x1F86,  0x1F0E, 0x0399, 0x0000,\n  0x1F87,  0x1F0F, 0x0399, 0x0000,\n  0x1F88,  0x1F08, 0x0399, 0x0000,\n  0x1F89,  0x1F09, 0x0399, 0x0000,\n  0x1F8A,  0x1F0A, 0x0399, 0x0000,\n  0x1F8B,  0x1F0B, 0x0399, 0x0000,\n  0x1F8C,  0x1F0C, 0x0399, 0x0000,\n  0x1F8D,  0x1F0D, 0x0399, 0x0000,\n  0x1F8E,  0x1F0E, 0x0399, 0x0000,\n  0x1F8F,  0x1F0F, 0x0399, 0x0000,\n  0x1F90,  0x1F28, 0x0399, 0x0000,\n  0x1F91,  0x1F29, 0x0399, 0x0000,\n  0x1F92,  0x1F2A, 0x0399, 0x0000,\n  0x1F93,  0x1F2B, 0x0399, 0x0000,\n  0x1F94,  0x1F2C, 0x0399, 0x0000,\n  0x1F95,  0x1F2D, 0x0399, 0x0000,\n  0x1F96,  0x1F2E, 0x0399, 0x0000,\n  0x1F97,  0x1F2F, 0x0399, 0x0000,\n  0x1F98,  0x1F28, 0x0399, 0x0000,\n  0x1F99,  0x1F29, 0x0399, 0x0000,\n  0x1F9A,  0x1F2A, 0x0399, 0x0000,\n  0x1F9B,  0x1F2B, 0x0399, 0x0000,\n  0x1F9C,  0x1F2C, 0x0399, 0x0000,\n  0x1F9D,  0x1F2D, 0x0399, 0x0000,\n  0x1F9E,  0x1F2E, 0x0399, 0x0000,\n  0x1F9F,  0x1F2F, 0x0399, 0x0000,\n  0x1FA0,  0x1F68, 0x0399, 0x0000,\n  0x1FA1,  0x1F69, 0x0399, 0x0000,\n  0x1FA2,  0x1F6A, 0x0399, 0x0000,\n  0x1FA3,  0x1F6B, 0x0399, 0x0000,\n  0x1FA4,  0x1F6C, 0x0399, 0x0000,\n  0x1FA5,  0x1F6D, 0x0399, 0x0000,\n  0x1FA6,  0x1F6E, 0x0399, 0x0000,\n  0x1FA7,  0x1F6F, 0x0399, 0x0000,\n  0x1FA8,  0x1F68, 0x0399, 0x0000,\n  0x1FA9,  0x1F69, 0x0399, 0x0000,\n  0x1FAA,  0x1F6A, 0x0399, 0x0000,\n  0x1FAB,  0x1F6B, 0x0399, 0x0000,\n  0x1FAC,  0x1F6C, 0x0399, 0x0000,\n  0x1FAD,  0x1F6D, 0x0399, 0x0000,\n  0x1FAE,  0x1F6E, 0x0399, 0x0000,\n  0x1FAF,  0x1F6F, 0x0399, 0x0000,\n  0x1FB2,  0x1FBA, 0x0399, 0x0000,\n  0x1FB3,  0x0391, 0x0399, 0x0000,\n  0x1FB4,  0x0386, 0x0399, 0x0000,\n  0x1FB6,  0x0391, 0x0342, 0x0000,\n  0x1FB7,  0x0391, 0x0342, 0x0399,\n  0x1FBC,  0x0391, 0x0399, 0x0000,\n  0x1FC2,  0x1FCA, 0x0399, 0x0000,\n  0x1FC3,  0x0397, 0x0399, 0x0000,\n  0x1FC4,  0x0389, 0x0399, 0x0000,\n  0x1FC6,  0x0397, 0x0342, 0x0000,\n  0x1FC7,  0x0397, 0x0342, 0x0399,\n  0x1FCC,  0x0397, 0x0399, 0x0000,\n  0x1FD2,  0x0399, 0x0308, 0x0300,\n  0x1FD3,  0x0399, 0x0308, 0x0301,\n  0x1FD6,  0x0399, 0x0342, 0x0000,\n  0x1FD7,  0x0399, 0x0308, 0x0342,\n  0x1FE2,  0x03A5, 0x0308, 0x0300,\n  0x1FE3,  0x03A5, 0x0308, 0x0301,\n  0x1FE4,  0x03A1, 0x0313, 0x0000,\n  0x1FE6,  0x03A5, 0x0342, 0x0000,\n  0x1FE7,  0x03A5, 0x0308, 0x0342,\n  0x1FF2,  0x1FFA, 0x0399, 0x0000,\n  0x1FF3,  0x03A9, 0x0399, 0x0000,\n  0x1FF4,  0x038F, 0x0399, 0x0000,\n  0x1FF6,  0x03A9, 0x0342, 0x0000,\n  0x1FF7,  0x03A9, 0x0342, 0x0399,\n  0x1FFC,  0x03A9, 0x0399, 0x0000,\n  0xFB00,  0x0046, 0x0046, 0x0000,\n  0xFB01,  0x0046, 0x0049, 0x0000,\n  0xFB02,  0x0046, 0x004C, 0x0000,\n  0xFB03,  0x0046, 0x0046, 0x0049,\n  0xFB04,  0x0046, 0x0046, 0x004C,\n  0xFB05,  0x0053, 0x0054, 0x0000,\n  0xFB06,  0x0053, 0x0054, 0x0000,\n  0xFB13,  0x0544, 0x0546, 0x0000,\n  0xFB14,  0x0544, 0x0535, 0x0000,\n  0xFB15,  0x0544, 0x053B, 0x0000,\n  0xFB16,  0x054E, 0x0546, 0x0000,\n  0xFB17,  0x0544, 0x053D, 0x0000\n];\n\n// @ts-ignore: decorator\n@lazy @inline const MT = memory.data<i32>([\n  2048, 342, 57\n]);\n\n// Special binary search routine for Special Casing Tables\n// @ts-ignore: decorator\n@inline\nexport function bsearch(key: u32, ptr: usize, max: i32): i32 {\n  var min = 0;\n  while (min <= max) {\n    let mid = (min + max) >>> 3 << 2;\n    let cmp = load<u16>(ptr + (mid << alignof<u16>())) - key;\n    if (cmp == 0) return mid; // found\n    else if (cmp >>> 31) min = mid + 4; // < 0\n    else max = mid - 4; // > 0\n  }\n  return -1; // not found\n}\n\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/towctrans.c\nexport function casemap(c: u32, dir: i32): i32 {\n  // if (c >= 0x20000) return c;\n  var c0 = c as i32;\n  var b = c >> 8;\n  c &= 255;\n\n  var x = c / 3;\n  var y = c % 3;\n\n  /* lookup entry in two-level base-6 table */\n  // v = tab[(tab[b] as i32) * 86 + x] as u32;\n  var v = <usize>load<u8>(TAB + <usize>load<u8>(TAB + b) * 86 + x);\n  // v = (v * mt[y] >> 11) % 6;\n  v = (v * load<i32>(MT + (y << alignof<i32>())) >> 11) % 6;\n  /* use the bit vector out of the tables as an index into\n   * a block-specific set of rules and decode the rule into\n   * a type and a case-mapping delta. */\n  // r = rules[(ruleBases[b] as u32) + v];\n  var r = load<i32>(RULES + ((<usize>load<u8>(RULE_BASES + b) + v) << alignof<i32>()));\n  var rt: u32 = r & 255;\n  var rd: i32 = r >> 8;\n  /* rules 0/1 are simple lower/upper case with a delta.\n   * apply according to desired mapping direction. */\n  if (rt < 2) return c0 + (rd & -(rt ^ dir));\n  /* binary search. endpoints of the binary search for\n   * this block are stored in the rule delta field. */\n  var xn: u32 = rd & 0xff;\n  var xb: u32 = rd >>> 8;\n  while (xn) {\n    let h = xn >> 1;\n    // let t = exceptions[(xb + h) * 2 + 0] as u32;\n    let t = <u32>load<u8>(EXCEPTIONS + (xb + h) * 2, 0);\n    if (t == c) {\n      // r = rules[exceptions[(xb + h) * 2 + 1]];\n      r = load<i32>(RULES + <usize>(load<u8>(EXCEPTIONS + (xb + h) * 2, 1) << alignof<i32>()));\n      rt = r & 255;\n      rd = r >> 8;\n      if (rt < 2) return c0 + (rd & -(rt ^ dir));\n      /* Hard-coded for the four exceptional titlecase */\n      return c0 + 1 - (dir << 1); // (dir ? -1 : 1);\n    } else if (t > c) {\n      xn = h;\n    } else {\n      xb += h;\n      xn -= h;\n    }\n  }\n  return c0;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    var length = source.length;\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    var sourceLen = source.length;\n    var otherLen = select(0, other.length, other === null);\n    var outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<StaticArray<T>>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n    var outStart = changetype<usize>(out);\n    var sourceSize = <usize>sourceLen << alignof<T>();\n    if (isManaged<T>()) {\n      for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(source) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += sourceSize;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(other) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(source), sourceSize);\n      memory.copy(outStart + sourceSize, changetype<usize>(other), <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    var length = source.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var sliceSize = <usize>length << alignof<T>();\n    var slice = changetype<StaticArray<T>>(__new(sliceSize, idof<StaticArray<T>>()));\n    var sourcePtr = changetype<usize>(source) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off: usize = 0;\n      while (off < sliceSize) {\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(slice) + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(changetype<usize>(slice), sourcePtr, sliceSize);\n    }\n    return slice;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    memory.fill(changetype<usize>(out), 0, outSize);\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    var len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var ptr = changetype<usize>(this);\n    var len = this.length;\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        store<usize>(ptr + (<usize>start << alignof<T>()), changetype<usize>(value));\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          ptr + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(ptr + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var ptr = changetype<usize>(this);\n    var len = this.length;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    var length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length;\n    var otherLen = select(0, other.length, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = changetype<usize>(this);\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(this), thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = changetype<usize>(this) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    var len = this.length;\n    var out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    var outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): this {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","export class Layers {\n  mask: u32;\n\n  constructor() {\n    this.mask = 1 | 0;\n  }\n\n  set(channel: u32): void {\n    this.mask = (1 << channel) | 0;\n  }\n\n  enable(channel: u32): void {\n    this.mask |= (1 << channel) | 0;\n  }\n\n  enableAll(): void {\n    this.mask = 0xffffffff | 0;\n  }\n\n  toggle(channel: u32): void {\n    this.mask ^= (1 << channel) | 0;\n  }\n\n  disable(channel: u32): void {\n    this.mask &= ~((1 << channel) | 0);\n  }\n\n  disableAll(): void {\n    this.mask = 0;\n  }\n\n  test(layers: Layers): boolean {\n    return (this.mask & layers.mask) !== 0;\n  }\n}\n","import { Map } from \"./map\";\n\n// @ts-ignore: decorator\n@lazy var stringToId: Map<string, usize>;\n\n// @ts-ignore: decorator\n@lazy var idToString: Map<usize, string>;\n\n// @ts-ignore: decorator\n@lazy var nextId: usize = 12; // Symbol.unscopables + 1\n\n@unmanaged @final abstract class _Symbol {\n\n  // TODO: all of the following default symbols are unused currently yet add to\n  // binary size if #toString becomes compiled. Ultimately we'll most likely want\n  // to remove the unsupported ones and only keep what's actually supported.\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly hasInstance: symbol = changetype<symbol>(1);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly isConcatSpreadable: symbol = changetype<symbol>(2);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly isRegExp: symbol = changetype<symbol>(3);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly iterator: symbol = changetype<symbol>(3);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly match: symbol = changetype<symbol>(4);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly replace: symbol = changetype<symbol>(5);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly search: symbol = changetype<symbol>(6);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly species: symbol = changetype<symbol>(7);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly split: symbol = changetype<symbol>(8);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly toPrimitive: symbol = changetype<symbol>(9);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly toStringTag: symbol = changetype<symbol>(10);\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly unscopables: symbol = changetype<symbol>(11);\n\n  static for(key: string): symbol {\n    if (!stringToId) { stringToId = new Map(); idToString = new Map(); }\n    else if (stringToId.has(key)) return changetype<symbol>(stringToId.get(key));\n    var id = nextId++;\n    if (!id) unreachable(); // out of ids\n    stringToId.set(key, id);\n    idToString.set(id, key);\n    return changetype<symbol>(id);\n  }\n\n  static keyFor(sym: symbol): string | null {\n    return idToString !== null && idToString.has(changetype<usize>(sym))\n      ? idToString.get(changetype<usize>(sym))\n      : null;\n  }\n\n  toString(): string {\n    var id = changetype<usize>(this);\n    var str = \"\";\n    switch (<u32>id) {\n      case 1:  { str = \"hasInstance\"; break; }\n      case 2:  { str = \"isConcatSpreadable\"; break; }\n      case 3:  { str = \"isRegExp\"; break; }\n      case 4:  { str = \"match\"; break; }\n      case 5:  { str = \"replace\"; break; }\n      case 6:  { str = \"search\"; break; }\n      case 7:  { str = \"species\"; break; }\n      case 8:  { str = \"split\"; break; }\n      case 9:  { str = \"toPrimitive\"; break; }\n      case 10: { str = \"toStringTag\"; break; }\n      case 11: { str = \"unscopables\"; break; }\n      default: {\n        if (idToString !== null && idToString.has(id)) str = idToString.get(id);\n        break;\n      }\n    }\n    return \"Symbol(\" + str + \")\";\n  }\n}\n\nexport function Symbol(description: string | null = null): symbol {\n  var id = nextId++;\n  if (!id) unreachable(); // out of ids\n  return changetype<symbol>(id);\n}\n\nexport type Symbol = _Symbol;\n\n// @ts-ignore: nolib\nexport type symbol = _Symbol;\n","import { Side } from \"../../common/GPUEnums\";\nlet object3DId: i32 = 1;\n\nexport class Pipeline {\n  name: string;\n  index: i32;\n  side: Side;\n  readonly id: i32 = object3DId++;\n\n  constructor(name: string, index: i32) {\n    this.name = name;\n    this.index = index;\n    this.side = Side.FrontSide;\n  }\n\n  clone(): Pipeline {\n    return new Pipeline(this.name, this.index);\n  }\n\n  copy(source: Pipeline): Pipeline {\n    this.name = source.name;\n    this.index = source.index;\n    return this;\n  }\n}\n","import { EventDispatcher } from \"../core/EventDispatcher\";\nimport {\n  Blending,\n  Side,\n  BlendingSrcFactor,\n  BlendingDstFactor,\n  BlendingEquation,\n  DepthModes,\n  StencilFunc,\n  StencilOp,\n  ShadowSide,\n  Precision,\n} from \"../../common/GLEnums\";\nimport * as MathUtils from \"../math/MathUtils\";\nimport { Plane } from \"../math/Plane\";\nimport { Event } from \"../core/Event\";\nimport { Vector2 } from \"../math/Vector2\";\n\nlet materialId: u32 = 0;\n\nexport class Material extends EventDispatcher {\n  isMaterial: boolean = true;\n\n  readonly id: u32 = materialId++;\n  uuid: string;\n  name: string;\n  type: string;\n  fog: boolean;\n  blending: Blending;\n  wireframe: boolean;\n  side: Side;\n  vertexColors: boolean;\n  opacity: f32;\n  transparent: boolean;\n  blendSrc: BlendingSrcFactor;\n  blendDst: BlendingDstFactor;\n  blendEquation: BlendingEquation;\n  blendSrcAlpha: f32; // TODO: This should be null - ensure we check this everywhere its used (NaN)\n  blendDstAlpha: f32; // TODO: This should be null - ensure we check this everywhere its used (NaN)\n  blendEquationAlpha: f32; // TODO: This should be null - ensure we check this everywhere its used (NaN)\n  depthFunc: DepthModes;\n  depthTest: boolean;\n  depthWrite: boolean;\n  stencilWriteMask: i32;\n  stencilFunc: StencilFunc;\n  stencilRef: i32;\n  stencilFuncMask: i32;\n  stencilFail: StencilOp;\n  stencilZFail: StencilOp;\n  stencilZPass: StencilOp;\n  stencilWrite: boolean;\n  clippingPlanes: Plane[] | null;\n  clipIntersection: boolean;\n  clipShadows: boolean;\n  shadowSide: ShadowSide;\n  colorWrite: boolean;\n  precision: Precision; // TODO: This should be null\n  polygonOffset: boolean;\n  polygonOffsetVector: Vector2;\n  dithering: boolean;\n  alphaTest: f32;\n  alphaToCoverage: boolean;\n  transmission: f32;\n  premultipliedAlpha: boolean;\n  visible: boolean;\n  toneMapped: boolean;\n  flatShading: boolean;\n  defaultAttributeValues: Map<string, Float32Array> | null;\n  // TODO:\n  // userData: any;\n  version: u32;\n  disposeEvent: Event = new Event(\"dispose\");\n\n  constructor() {\n    super();\n\n    this.uuid = MathUtils.generateUUID();\n    this.type = \"Material\";\n    this.name = \"\";\n    this.type = \"Material\";\n\n    this.fog = true;\n\n    this.blending = Blending.NormalBlending;\n    this.side = Side.FrontSide;\n    this.vertexColors = false;\n\n    this.opacity = 1;\n    this.transmission = 0;\n    this.transparent = false;\n\n    this.blendSrc = BlendingSrcFactor.SrcAlphaFactor;\n    this.blendDst = BlendingDstFactor.OneMinusSrcAlphaFactor;\n    this.blendEquation = BlendingEquation.AddEquation;\n    this.blendSrcAlpha = NaN;\n    this.blendDstAlpha = NaN;\n    this.blendEquationAlpha = NaN;\n\n    this.depthFunc = DepthModes.LessEqualDepth;\n    this.depthTest = true;\n    this.depthWrite = true;\n\n    this.stencilWriteMask = 0xff;\n    this.stencilFunc = StencilFunc.AlwaysStencilFunc;\n    this.stencilRef = 0;\n    this.stencilFuncMask = 0xff;\n    this.stencilFail = StencilOp.KeepStencilOp;\n    this.stencilZFail = StencilOp.KeepStencilOp;\n    this.stencilZPass = StencilOp.KeepStencilOp;\n    this.stencilWrite = false;\n\n    this.clippingPlanes = null;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n\n    this.shadowSide = ShadowSide.AutoSide;\n\n    this.colorWrite = true;\n\n    this.precision = Precision.Default; // override the renderer's default precision for this material\n\n    this.polygonOffset = false;\n    this.polygonOffsetVector = new Vector2();\n\n    this.dithering = false;\n\n    this.alphaTest = 0;\n    this.alphaToCoverage = false;\n    this.premultipliedAlpha = false;\n\n    this.visible = true;\n\n    this.toneMapped = true;\n    this.disposeEvent.target = this;\n\n    this.wireframe = false;\n    this.defaultAttributeValues = null;\n\n    // TODO:\n    // this.userData = {};\n\n    this.version = 0;\n  }\n\n  set polygonOffsetFactor(value: f32) {\n    this.polygonOffsetVector.x = value;\n  }\n  get polygonOffsetFactor(): f32 {\n    return this.polygonOffsetVector.x;\n  }\n\n  set polygonOffsetUnits(value: f32) {\n    this.polygonOffsetVector.y = value;\n  }\n  get polygonOffsetUnits(): f32 {\n    return this.polygonOffsetVector.y;\n  }\n\n  onBuild(/* shaderobject, renderer */): void {}\n\n  onBeforeCompile(/* shaderobject, renderer */): void {}\n\n  customProgramCacheKey(): string {\n    return this.onBeforeCompile.toString();\n  }\n\n  // TODO:\n  //   setValues(values) {\n  //     if (values === undefined) return;\n\n  //     for (const key in values) {\n  //       const newValue = values[key];\n\n  //       if (newValue === undefined) {\n  //         console.warn(\"THREE.Material: '\" + key + \"' parameter is undefined.\");\n  //         continue;\n  //       }\n\n  //       // for backward compatability if shading is set in the constructor\n  //       if (key === \"shading\") {\n  //         console.warn(\n  //           \"THREE.\" +\n  //             this.type +\n  //             \": .shading has been removed. Use the boolean .flatShading instead.\"\n  //         );\n  //         this.flatShading = newValue === FlatShading ? true : false;\n  //         continue;\n  //       }\n\n  //       const currentValue = this[key];\n\n  //       if (currentValue === undefined) {\n  //         console.warn(\n  //           \"THREE.\" +\n  //             this.type +\n  //             \": '\" +\n  //             key +\n  //             \"' is not a property of this material.\"\n  //         );\n  //         continue;\n  //       }\n\n  //       if (currentValue && currentValue.isColor) {\n  //         currentValue.set(newValue);\n  //       } else if (\n  //         currentValue &&\n  //         currentValue.isVector3 &&\n  //         newValue &&\n  //         newValue.isVector3\n  //       ) {\n  //         currentValue.copy(newValue);\n  //       } else {\n  //         this[key] = newValue;\n  //       }\n  //     }\n  //   }\n\n  // TODO:\n  // toJSON( meta ) {\n\n  // \tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n  // \tif ( isRoot ) {\n\n  // \t\tmeta = {\n  // \t\t\ttextures: {},\n  // \t\t\timages: {}\n  // \t\t};\n\n  // \t}\n\n  // \tconst data = {\n  // \t\tmetadata: {\n  // \t\t\tversion: 4.5,\n  // \t\t\ttype: 'Material',\n  // \t\t\tgenerator: 'Material.toJSON'\n  // \t\t}\n  // \t};\n\n  // \t// standard Material serialization\n  // \tdata.uuid = this.uuid;\n  // \tdata.type = this.type;\n\n  // \tif ( this.name !== '' ) data.name = this.name;\n\n  // \tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n  // \tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n  // \tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n  // \tif ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();\n  // \tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n  // \tif ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n  // \tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n  // \tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n  // \tif ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;\n  // \tif ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;\n\n  // \tif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {\n\n  // \t\tdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;\n\n  // \t}\n\n  // \tif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {\n\n  // \t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;\n\n  // \t}\n\n  // \tif ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {\n\n  // \t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;\n  // \t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\n  // \t}\n\n  // \tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n  // \tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\n  // \tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\n  // \tif ( this.lightMap && this.lightMap.isTexture ) {\n\n  // \t\tdata.lightMap = this.lightMap.toJSON( meta ).uuid;\n  // \t\tdata.lightMapIntensity = this.lightMapIntensity;\n\n  // \t}\n\n  // \tif ( this.aoMap && this.aoMap.isTexture ) {\n\n  // \t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n  // \t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n  // \t}\n\n  // \tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n  // \t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n  // \t\tdata.bumpScale = this.bumpScale;\n\n  // \t}\n\n  // \tif ( this.normalMap && this.normalMap.isTexture ) {\n\n  // \t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n  // \t\tdata.normalMapType = this.normalMapType;\n  // \t\tdata.normalScale = this.normalScale.toArray();\n\n  // \t}\n\n  // \tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n  // \t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n  // \t\tdata.displacementScale = this.displacementScale;\n  // \t\tdata.displacementBias = this.displacementBias;\n\n  // \t}\n\n  // \tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n  // \tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n  // \tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n  // \tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n  // \tif ( this.envMap && this.envMap.isTexture ) {\n\n  // \t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\n  // \t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\n  // \t}\n\n  // \tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n  // \tif ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;\n  // \tif ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;\n\n  // \tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n  // \t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n  // \t}\n\n  // \tif ( this.transmission !== undefined ) data.transmission = this.transmission;\n  // \tif ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;\n  // \tif ( this.thickness !== undefined ) data.thickness = this.thickness;\n  // \tif ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;\n  // \tif ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;\n  // \tif ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();\n\n  // \tif ( this.size !== undefined ) data.size = this.size;\n  // \tif ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;\n  // \tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n  // \tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n  // \tif ( this.side !== FrontSide ) data.side = this.side;\n  // \tif ( this.vertexColors ) data.vertexColors = true;\n\n  // \tif ( this.opacity < 1 ) data.opacity = this.opacity;\n  // \tif ( this.transparent === true ) data.transparent = this.transparent;\n\n  // \tdata.depthFunc = this.depthFunc;\n  // \tdata.depthTest = this.depthTest;\n  // \tdata.depthWrite = this.depthWrite;\n  // \tdata.colorWrite = this.colorWrite;\n\n  // \tdata.stencilWrite = this.stencilWrite;\n  // \tdata.stencilWriteMask = this.stencilWriteMask;\n  // \tdata.stencilFunc = this.stencilFunc;\n  // \tdata.stencilRef = this.stencilRef;\n  // \tdata.stencilFuncMask = this.stencilFuncMask;\n  // \tdata.stencilFail = this.stencilFail;\n  // \tdata.stencilZFail = this.stencilZFail;\n  // \tdata.stencilZPass = this.stencilZPass;\n\n  // \t// rotation (SpriteMaterial)\n  // \tif ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;\n\n  // \tif ( this.polygonOffset === true ) data.polygonOffset = true;\n  // \tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n  // \tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n  // \tif ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;\n  // \tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n  // \tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n  // \tif ( this.scale !== undefined ) data.scale = this.scale;\n\n  // \tif ( this.dithering === true ) data.dithering = true;\n\n  // \tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n  // \tif ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;\n  // \tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\n  // \tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n  // \tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n  // \tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n  // \tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n  // \tif ( this.morphTargets === true ) data.morphTargets = true;\n  // \tif ( this.morphNormals === true ) data.morphNormals = true;\n\n  // \tif ( this.flatShading === true ) data.flatShading = this.flatShading;\n\n  // \tif ( this.visible === false ) data.visible = false;\n\n  // \tif ( this.toneMapped === false ) data.toneMapped = false;\n\n  // \tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\n\n  // \t// TODO: Copied from Object3D.toJSON\n\n  // \tfunction extractFromCache( cache ) {\n\n  // \t\tconst values = [];\n\n  // \t\tfor ( const key in cache ) {\n\n  // \t\t\tconst data = cache[ key ];\n  // \t\t\tdelete data.metadata;\n  // \t\t\tvalues.push( data );\n\n  // \t\t}\n\n  // \t\treturn values;\n\n  // \t}\n\n  // \tif ( isRoot ) {\n\n  // \t\tconst textures = extractFromCache( meta.textures );\n  // \t\tconst images = extractFromCache( meta.images );\n\n  // \t\tif ( textures.length > 0 ) data.textures = textures;\n  // \t\tif ( images.length > 0 ) data.images = images;\n\n  // \t}\n\n  // \treturn data;\n\n  // }\n\n  clone(): Material {\n    return new Material().copy(this);\n  }\n\n  copy(source: Material): Material {\n    this.name = source.name;\n\n    this.fog = source.fog;\n\n    this.blending = source.blending;\n    this.side = source.side;\n    this.vertexColors = source.vertexColors;\n\n    this.opacity = source.opacity;\n    this.transparent = source.transparent;\n\n    this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    this.blendEquation = source.blendEquation;\n    this.blendSrcAlpha = source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    this.blendEquationAlpha = source.blendEquationAlpha;\n\n    this.depthFunc = source.depthFunc;\n    this.depthTest = source.depthTest;\n    this.depthWrite = source.depthWrite;\n\n    this.stencilWriteMask = source.stencilWriteMask;\n    this.stencilFunc = source.stencilFunc;\n    this.stencilRef = source.stencilRef;\n    this.stencilFuncMask = source.stencilFuncMask;\n    this.stencilFail = source.stencilFail;\n    this.stencilZFail = source.stencilZFail;\n    this.stencilZPass = source.stencilZPass;\n    this.stencilWrite = source.stencilWrite;\n\n    const srcPlanes = source.clippingPlanes;\n    let dstPlanes: Plane[] | null = null;\n\n    if (srcPlanes !== null) {\n      const n = srcPlanes.length;\n      dstPlanes = new Array(n);\n\n      for (let i = 0; i !== n; ++i) {\n        dstPlanes[i] = srcPlanes[i].clone();\n      }\n    }\n\n    this.clippingPlanes = dstPlanes;\n    this.clipIntersection = source.clipIntersection;\n    this.clipShadows = source.clipShadows;\n\n    this.shadowSide = source.shadowSide;\n\n    this.colorWrite = source.colorWrite;\n\n    this.precision = source.precision;\n\n    this.polygonOffset = source.polygonOffset;\n    this.polygonOffsetFactor = source.polygonOffsetFactor;\n    this.polygonOffsetUnits = source.polygonOffsetUnits;\n\n    this.dithering = source.dithering;\n\n    this.alphaTest = source.alphaTest;\n    this.alphaToCoverage = source.alphaToCoverage;\n    this.premultipliedAlpha = source.premultipliedAlpha;\n\n    this.visible = source.visible;\n\n    this.toneMapped = source.toneMapped;\n\n    const defaultAttributeValues = this.defaultAttributeValues;\n    if (defaultAttributeValues) {\n      source.defaultAttributeValues = new Map();\n      const defaultAttKeys = defaultAttributeValues.keys();\n\n      const sourceDefaultAttributeValues = source.defaultAttributeValues;\n\n      for (let i: i32 = 0, l: i32 = defaultAttKeys.length; i < l; i++)\n        sourceDefaultAttributeValues!.set(defaultAttKeys[i], defaultAttributeValues.get(defaultAttKeys[i]));\n    }\n\n    // TODO:\n    // this.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n    return this;\n  }\n\n  dispose(): void {\n    this.dispatchEvent(this.disposeEvent);\n  }\n\n  set needsUpdate(value: boolean) {\n    if (value === true) this.version++;\n  }\n}\n","import { EventDispatcher } from \"../core/EventDispatcher\";\nimport { Mapping, Wrapping, TextureFilter, PixelFormat, TextureDataType, TextureEncoding } from \"../../common/GLEnums\";\nimport * as MathUtils from \"../math/MathUtils\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { Matrix3 } from \"../math/Matrix3\";\n// import { ImageUtils } from \"../extras/ImageUtils\";\nimport { Event } from \"../core/Event\";\n\nlet textureId: u32 = 0;\n\ntype UpdateCallback = () => void;\n\nexport class Image {}\n\nexport class Texture extends EventDispatcher {\n  static DEFAULT_IMAGE: Image | null = null;\n  static DEFAULT_MAPPING: Mapping = Mapping.UVMapping;\n\n  uuid: string;\n  name: string;\n  image: Image | null; // TODO: ?\n  mipmaps: Image[]; // TODO: ?\n  wrapS: Wrapping;\n  wrapT: Wrapping;\n  mapping: Mapping;\n  magFilter: TextureFilter;\n  minFilter: TextureFilter;\n  anisotropy: f32;\n  format: PixelFormat;\n  internalFormat: PixelFormat; // TODO: THis should be null\n  type: TextureDataType;\n  offset: Vector2;\n  repeat: Vector2;\n  center: Vector2;\n  rotation: f32;\n  matrixAutoUpdate: boolean;\n  matrix: Matrix3;\n  encoding: TextureEncoding;\n  version: i32;\n  onUpdate: UpdateCallback | null;\n\n  generateMipmaps: boolean;\n  premultiplyAlpha: boolean;\n  flipY: boolean;\n  unpackAlignment: f32;\n  readonly id: u32 = textureId++;\n\n  isTexture: boolean = true;\n\n  disposeEvent: Event = new Event(\"dispose\");\n\n  constructor(\n    image: Image | null = Texture.DEFAULT_IMAGE,\n    mapping: Mapping = Texture.DEFAULT_MAPPING,\n    wrapS: Wrapping = Wrapping.ClampToEdgeWrapping,\n    wrapT: Wrapping = Wrapping.ClampToEdgeWrapping,\n    magFilter: TextureFilter = TextureFilter.LinearFilter,\n    minFilter: TextureFilter = TextureFilter.LinearMipMapLinearFilter,\n    format: PixelFormat = PixelFormat.RGBAFormat,\n    type: TextureDataType = TextureDataType.UnsignedByteType,\n    anisotropy: f32 = 1,\n    encoding: TextureEncoding = TextureEncoding.LinearEncoding\n  ) {\n    super();\n\n    this.uuid = MathUtils.generateUUID();\n\n    this.name = \"\";\n\n    this.image = image;\n    this.mipmaps = [];\n    this.mapping = mapping;\n\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n\n    this.magFilter = magFilter;\n    this.minFilter = minFilter;\n\n    this.anisotropy = anisotropy;\n\n    this.format = format;\n    this.internalFormat = PixelFormat.RGBAFormat;\n    this.type = type;\n\n    this.offset = new Vector2(0, 0);\n    this.repeat = new Vector2(1, 1);\n    this.center = new Vector2(0, 0);\n    this.rotation = 0;\n\n    this.matrixAutoUpdate = true;\n    this.matrix = new Matrix3();\n\n    this.generateMipmaps = true;\n    this.premultiplyAlpha = false;\n    this.flipY = true;\n    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n    //\n    // Also changing the encoding after already used by a Material will not automatically make the Material\n    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n    this.encoding = encoding;\n\n    this.version = 0;\n    this.onUpdate = null;\n    this.disposeEvent.target = this;\n  }\n\n  updateMatrix(): void {\n    this.matrix.setUvTransform(\n      this.offset.x,\n      this.offset.y,\n      this.repeat.x,\n      this.repeat.y,\n      this.rotation,\n      this.center.x,\n      this.center.y\n    );\n  }\n\n  clone(): Texture {\n    return new Texture().copy(this);\n  }\n\n  copy(source: Texture): Texture {\n    this.name = source.name;\n\n    this.image = source.image;\n    this.mipmaps = source.mipmaps.slice(0);\n\n    this.mapping = source.mapping;\n\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n\n    this.anisotropy = source.anisotropy;\n\n    this.format = source.format;\n    this.internalFormat = source.internalFormat;\n    this.type = source.type;\n\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.center.copy(source.center);\n    this.rotation = source.rotation;\n\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrix.copy(source.matrix);\n\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    this.encoding = source.encoding;\n\n    return this;\n  }\n\n  // TODO:\n  //   toJSON(meta) {\n  //     const isRootObject = meta === undefined || typeof meta === \"string\";\n\n  //     if (!isRootObject && meta.textures[this.uuid] !== undefined) {\n  //       return meta.textures[this.uuid];\n  //     }\n\n  //     const output = {\n  //       metadata: {\n  //         version: 4.5,\n  //         type: \"Texture\",\n  //         generator: \"Texture.toJSON\",\n  //       },\n\n  //       uuid: this.uuid,\n  //       name: this.name,\n\n  //       mapping: this.mapping,\n\n  //       repeat: [this.repeat.x, this.repeat.y],\n  //       offset: [this.offset.x, this.offset.y],\n  //       center: [this.center.x, this.center.y],\n  //       rotation: this.rotation,\n\n  //       wrap: [this.wrapS, this.wrapT],\n\n  //       format: this.format,\n  //       type: this.type,\n  //       encoding: this.encoding,\n\n  //       minFilter: this.minFilter,\n  //       magFilter: this.magFilter,\n  //       anisotropy: this.anisotropy,\n\n  //       flipY: this.flipY,\n\n  //       premultiplyAlpha: this.premultiplyAlpha,\n  //       unpackAlignment: this.unpackAlignment,\n  //     };\n\n  //     if (this.image !== undefined) {\n  //       // TODO: Move to THREE.Image\n\n  //       const image = this.image;\n\n  //       if (image.uuid === undefined) {\n  //         image.uuid = MathUtils.generateUUID(); // UGH\n  //       }\n\n  //       if (!isRootObject && meta.images[image.uuid] === undefined) {\n  //         let url;\n\n  //         if (Array.isArray(image)) {\n  //           // process array of images e.g. CubeTexture\n\n  //           url = [];\n\n  //           for (let i = 0, l = image.length; i < l; i++) {\n  //             // check cube texture with data textures\n\n  //             if (image[i].isDataTexture) {\n  //               url.push(serializeImage(image[i].image));\n  //             } else {\n  //               url.push(serializeImage(image[i]));\n  //             }\n  //           }\n  //         } else {\n  //           // process single image\n\n  //           url = serializeImage(image);\n  //         }\n\n  //         meta.images[image.uuid] = {\n  //           uuid: image.uuid,\n  //           url: url,\n  //         };\n  //       }\n\n  //       output.image = image.uuid;\n  //     }\n\n  //     if (!isRootObject) {\n  //       meta.textures[this.uuid] = output;\n  //     }\n\n  //     return output;\n  //   }\n\n  dispose(): void {\n    this.dispatchEvent(this.disposeEvent);\n  }\n\n  transformUv(uv: Vector2): Vector2 {\n    if (this.mapping != Mapping.UVMapping) return uv;\n\n    uv.applyMatrix3(this.matrix);\n\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case Wrapping.RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n\n        case Wrapping.ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n\n        case Wrapping.MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n\n          break;\n      }\n    }\n\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case Wrapping.RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n\n        case Wrapping.ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n\n        case Wrapping.MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n\n          break;\n      }\n    }\n\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n\n    return uv;\n  }\n\n  set needsUpdate(value: boolean) {\n    if (value === true) this.version++;\n  }\n}\n\n// TODO\n// function serializeImage(image) {\n//   if (\n//     (typeof HTMLImageElement !== \"undefined\" &&\n//       image instanceof HTMLImageElement) ||\n//     (typeof HTMLCanvasElement !== \"undefined\" &&\n//       image instanceof HTMLCanvasElement) ||\n//     (typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap)\n//   ) {\n//     // default images\n\n//     return ImageUtils.getDataURL(image);\n//   } else {\n//     if (image.data) {\n//       // images of DataTexture\n\n//       return {\n//         data: Array.prototype.slice.call(image.data),\n//         width: image.width,\n//         height: image.height,\n//         type: image.data.constructor.name,\n//       };\n//     } else {\n//       console.warn(\"THREE.Texture: Unable to serialize Texture.\");\n//       return {};\n//     }\n//   }\n// }\n","import { Vector3 } from \"../math/Vector3\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { Sphere } from \"../math/Sphere\";\nimport { Ray } from \"../math/Ray\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Object } from \"../core/Object\";\nimport { Triangle } from \"../math/Triangle\";\nimport { Side } from \"../../common/GLEnums\";\nimport { AttributeTypes, BufferGeometry } from \"../core/BufferGeometry\";\nimport { MeshPipeline } from \"../pipelines/MeshPipeline\";\nimport { Raycaster } from \"../core/Raycaster\";\nimport { BufferAttribute, Float32BufferAttribute } from \"../core/BufferAttribute\";\nimport { SkinnedMesh } from \"./SkinnedMesh\";\nimport { Pipeline } from \"..\";\n\nexport class Face {\n  public a: i32;\n  public b: i32;\n  public c: i32;\n  public normal: Vector3;\n  public materialIndex: i32;\n}\n\nexport class Intersection {\n  public distance: f32;\n  public point: Vector3;\n  public object: Object;\n  public faceIndex: i32;\n  public face: Face | null;\n  public uv: Vector2 | null;\n  public uv2: Vector2 | null;\n  public instanceId: i32;\n}\n\nconst _inverseMatrix = new Matrix4();\nconst _ray = new Ray();\nconst _sphere = new Sphere();\n\nconst _vA = new Vector3();\nconst _vB = new Vector3();\nconst _vC = new Vector3();\n\nconst _tempA = new Vector3();\nconst _tempB = new Vector3();\nconst _tempC = new Vector3();\n\nconst _morphA = new Vector3();\nconst _morphB = new Vector3();\nconst _morphC = new Vector3();\n\nconst _uvA = new Vector2();\nconst _uvB = new Vector2();\nconst _uvC = new Vector2();\n\nconst _intersectionPoint = new Vector3();\nconst _intersectionPointWorld = new Vector3();\n\nexport class Mesh extends Object {\n  pipelines: MeshPipeline[];\n  geometry: BufferGeometry;\n  morphTargetInfluences: f32[] | null;\n  morphTargetDictionary: Map<string, i32> | null;\n\n  constructor(geometry: BufferGeometry = new BufferGeometry(), pipelines: MeshPipeline[] = []) {\n    super();\n\n    this.type = \"Mesh\";\n\n    this.geometry = geometry;\n    this.pipelines = pipelines;\n    this.morphTargetInfluences = null;\n    this.morphTargetDictionary = null;\n\n    this.updateMorphTargets();\n  }\n\n  copy(source: Mesh, recursive: boolean = true): Mesh {\n    super.copy(source, recursive);\n\n    const sourceMorphTargetInfluences = source.morphTargetInfluences;\n    if (sourceMorphTargetInfluences != null) {\n      this.morphTargetInfluences = sourceMorphTargetInfluences.slice(0);\n    }\n\n    const sourceMorphTargetDictionary = source.morphTargetDictionary;\n    if (sourceMorphTargetDictionary != null) {\n      this.morphTargetDictionary = new Map();\n      const keys = sourceMorphTargetDictionary.keys();\n\n      const morphTargetDictionary = this.morphTargetDictionary;\n\n      for (let i: i32 = 0; i < keys.length; i++)\n        morphTargetDictionary!.set(keys[i], sourceMorphTargetDictionary.get(keys[i]));\n    }\n\n    this.pipelines = new Array(source.pipelines.length);\n    for (let i: i32 = 0; i < source.pipelines.length; i++)\n      this.pipelines[i] = source.pipelines[i].clone() as MeshPipeline;\n\n    this.geometry = source.geometry;\n\n    return this;\n  }\n\n  updateMorphTargets(): void {\n    const geometry = this.geometry;\n\n    const morphAttributes = geometry.morphAttributes;\n    const keys = morphAttributes.keys();\n\n    if (keys.length > 0) {\n      const morphAttribute = morphAttributes.get(keys[0]);\n\n      if (morphAttribute !== null) {\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = new Map();\n\n        for (let m: i32 = 0, ml = morphAttribute.length; m < ml; m++) {\n          const name = morphAttribute[m].name || m.toString();\n\n          this.morphTargetInfluences!.push(0);\n          this.morphTargetDictionary!.set(name, m);\n        }\n      }\n    }\n  }\n\n  raycast(raycaster: Raycaster, intersects: Intersection[]): void {\n    const geometry = this.geometry;\n    const pipelines = this.pipelines;\n    const matrixWorld = this.matrixWorld;\n\n    // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere!);\n    _sphere.applyMatrix4(matrixWorld);\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n\n    //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    // Check boundingBox before continuing\n\n    if (geometry.boundingBox !== null) {\n      if (_ray.intersectsBox(geometry.boundingBox!) === false) return;\n    }\n\n    let intersection: Intersection | null = null;\n\n    const indexes = geometry.indexes;\n\n    const position = geometry.getAttribute<Float32BufferAttribute>(AttributeTypes.POSITION)!;\n    const morphPosition = geometry.getMorphAttribute<Float32BufferAttribute>(AttributeTypes.POSITION);\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const uv = geometry.getAttribute<Float32BufferAttribute>(AttributeTypes.UV);\n    const uv2 = geometry.getAttribute<Float32BufferAttribute>(AttributeTypes.UV);\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n\n    if (indexes !== null) {\n      const index = indexes;\n\n      // indexed buffer geometry\n\n      if (pipelines.length > 1) {\n        for (let i = 0, il = groups.length; i < il; i++) {\n          const group = groups[i];\n          const groupPipeline = pipelines[group.materialIndex];\n\n          const start = Math.max(group.start, drawRange.start);\n          const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n          for (let j: u32 = u32(start), jl: u32 = u32(end); j < jl; j += 3) {\n            const a = index.getX(j);\n            const b = index.getX(j + 1);\n            const c = index.getX(j + 2);\n\n            intersection = checkBufferGeometryIntersection(\n              this,\n              groupPipeline,\n              raycaster,\n              _ray,\n              position,\n              morphPosition,\n              morphTargetsRelative,\n              uv,\n              uv2,\n              a,\n              b,\n              c\n            );\n\n            if (intersection) {\n              intersection.faceIndex = i32(Math.floor(j / 3)); // triangle number in indexed buffer semantics\n              intersection.face!.materialIndex = group.materialIndex;\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n        for (let i: i32 = i32(start), il: i32 = i32(end); i < il; i += 3) {\n          const a = index.getX(i);\n          const b = index.getX(i + 1);\n          const c = index.getX(i + 2);\n\n          intersection = checkBufferGeometryIntersection(\n            this,\n            pipelines[0],\n            raycaster,\n            _ray,\n            position,\n            morphPosition,\n            morphTargetsRelative,\n            uv,\n            uv2,\n            a,\n            b,\n            c\n          );\n\n          if (intersection) {\n            intersection.faceIndex = i32(Math.floor(i / 3)); // triangle number in indexed buffer semantics\n            intersects.push(intersection);\n          }\n        }\n      }\n    } else if (position !== null) {\n      // non-indexed buffer geometry\n\n      if (pipelines.length > 1) {\n        for (let i: i32 = 0, il = groups.length; i < il; i++) {\n          const group = groups[i];\n          const groupPipeline = pipelines[group.materialIndex];\n\n          const start = Math.max(group.start, drawRange.start);\n          const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n          for (let j: i32 = i32(start), jl: i32 = i32(end); j < jl; j += 3) {\n            const a = j;\n            const b = j + 1;\n            const c = j + 2;\n\n            intersection = checkBufferGeometryIntersection(\n              this,\n              groupPipeline,\n              raycaster,\n              _ray,\n              position,\n              morphPosition,\n              morphTargetsRelative,\n              uv,\n              uv2,\n              a,\n              b,\n              c\n            );\n\n            if (intersection) {\n              intersection.faceIndex = i32(Math.floor(f32(j) / f32(3))); // triangle number in non-indexed buffer semantics\n              intersection.face!.materialIndex = group.materialIndex;\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(position.count, drawRange.start + drawRange.count);\n\n        for (let i: i32 = i32(start), il: i32 = i32(end); i < il; i += 3) {\n          const a: i32 = i;\n          const b: i32 = i + 1;\n          const c: i32 = i + 2;\n\n          intersection = checkBufferGeometryIntersection(\n            this,\n            pipelines[0],\n            raycaster,\n            _ray,\n            position,\n            morphPosition,\n            morphTargetsRelative,\n            uv,\n            uv2,\n            a,\n            b,\n            c\n          );\n\n          if (intersection) {\n            intersection.faceIndex = i32(Math.floor(i / 3)); // triangle number in non-indexed buffer semantics\n            intersects.push(intersection);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction checkIntersection(\n  object: Object,\n  pipeline: Pipeline,\n  raycaster: Raycaster,\n  ray: Ray,\n  pA: Vector3,\n  pB: Vector3,\n  pC: Vector3,\n  point: Vector3\n): Intersection | null {\n  let intersect: Vector3 | null = null;\n\n  if (pipeline.side === Side.BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, pipeline.side !== Side.DoubleSide, point);\n  }\n\n  if (intersect === null) return null;\n\n  _intersectionPointWorld.copy(point);\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n  const distance: f32 = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n\n  return {\n    distance: distance,\n    point: _intersectionPointWorld.clone(),\n    object: object,\n    face: null,\n    uv: null,\n    uv2: null,\n    faceIndex: -1,\n    instanceId: -1,\n  };\n}\n\nfunction checkBufferGeometryIntersection(\n  object: Mesh,\n  pipeline: Pipeline,\n  raycaster: Raycaster,\n  ray: Ray,\n  position: BufferAttribute<f32, Float32Array>,\n  morphPosition: Float32BufferAttribute[] | null,\n  morphTargetsRelative: boolean,\n  uv: BufferAttribute<f32, Float32Array> | null,\n  uv2: BufferAttribute<f32, Float32Array> | null,\n  a: i32,\n  b: i32,\n  c: i32\n): Intersection | null {\n  _vA.fromBufferAttribute(position, a);\n  _vB.fromBufferAttribute(position, b);\n  _vC.fromBufferAttribute(position, c);\n\n  const morphInfluences = object.morphTargetInfluences;\n\n  if (morphPosition && morphInfluences) {\n    _morphA.set(0, 0, 0);\n    _morphB.set(0, 0, 0);\n    _morphC.set(0, 0, 0);\n\n    for (let i = 0, il = morphPosition.length; i < il; i++) {\n      const influence = morphInfluences[i];\n      const morphAttribute = morphPosition[i];\n\n      if (influence === 0) continue;\n\n      _tempA.fromBufferAttribute(morphAttribute, a);\n      _tempB.fromBufferAttribute(morphAttribute, b);\n      _tempC.fromBufferAttribute(morphAttribute, c);\n\n      if (morphTargetsRelative) {\n        _morphA.addScaledVector(_tempA, influence);\n        _morphB.addScaledVector(_tempB, influence);\n        _morphC.addScaledVector(_tempC, influence);\n      } else {\n        _morphA.addScaledVector(_tempA.sub(_vA), influence);\n        _morphB.addScaledVector(_tempB.sub(_vB), influence);\n        _morphC.addScaledVector(_tempC.sub(_vC), influence);\n      }\n    }\n\n    _vA.add(_morphA);\n    _vB.add(_morphB);\n    _vC.add(_morphC);\n  }\n\n  if (object instanceof SkinnedMesh) {\n    const smesh = object as SkinnedMesh;\n    smesh.boneTransform(a, _vA);\n    smesh.boneTransform(b, _vB);\n    smesh.boneTransform(c, _vC);\n  }\n\n  const intersection: Intersection | null = checkIntersection(\n    object,\n    pipeline,\n    raycaster,\n    ray,\n    _vA,\n    _vB,\n    _vC,\n    _intersectionPoint\n  );\n\n  if (intersection) {\n    if (uv) {\n      _uvA.fromBufferAttribute(uv, a);\n      _uvB.fromBufferAttribute(uv, b);\n      _uvC.fromBufferAttribute(uv, c);\n\n      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n\n    if (uv2) {\n      _uvA.fromBufferAttribute(uv2, a);\n      _uvB.fromBufferAttribute(uv2, b);\n      _uvC.fromBufferAttribute(uv2, c);\n\n      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n\n    const face: Face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0,\n    };\n\n    Triangle.getNormal(_vA, _vB, _vC, face.normal);\n\n    intersection.face = face;\n  }\n\n  return intersection;\n}\n","import { Box3 } from \"./Box3\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Plane } from \"./Plane\";\nimport { Sphere } from \"./Sphere\";\nimport { Vector3 } from \"./Vector3\";\n\nconst _vector = new Vector3();\nconst _segCenter = new Vector3();\nconst _segDir = new Vector3();\nconst _diff = new Vector3();\n\nconst _edge1 = new Vector3();\nconst _edge2 = new Vector3();\nconst _normal = new Vector3();\n\nexport class Ray {\n  origin: Vector3;\n  direction: Vector3;\n\n  constructor(origin: Vector3 = new Vector3(), direction: Vector3 = new Vector3(0, 0, -1)) {\n    this.origin = origin;\n    this.direction = direction;\n  }\n\n  set(origin: Vector3, direction: Vector3): Ray {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n\n    return this;\n  }\n\n  copy(ray: Ray): Ray {\n    this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n\n    return this;\n  }\n\n  at(t: f32, target: Vector3): Vector3 {\n    return target.copy(this.direction).multiplyScalar(t).add(this.origin);\n  }\n\n  lookAt(v: Vector3): Ray {\n    this.direction.copy(v).sub(this.origin).normalize();\n\n    return this;\n  }\n\n  recast(t: f32): Ray {\n    this.origin.copy(this.at(t, _vector));\n\n    return this;\n  }\n\n  closestPointToPoint(point: Vector3, target: Vector3): Vector3 {\n    target.subVectors(point, this.origin);\n\n    const directionDistance = target.dot(this.direction);\n\n    if (directionDistance < 0) {\n      return target.copy(this.origin);\n    }\n\n    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n  }\n\n  distanceToPoint(point: Vector3): f32 {\n    return Mathf.sqrt(this.distanceSqToPoint(point));\n  }\n\n  distanceSqToPoint(point: Vector3): f32 {\n    const directionDistance = _vector.subVectors(point, this.origin).dot(this.direction);\n\n    // point behind the ray\n\n    if (directionDistance < 0) {\n      return this.origin.distanceToSquared(point);\n    }\n\n    _vector.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\n    return _vector.distanceToSquared(point);\n  }\n\n  distanceSqToSegment(v0: Vector3, v1: Vector3, optionalPointOnRay: Vector3, optionalPointOnSegment: Vector3): f32 {\n    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n    // It returns the min distance between the ray and the segment\n    // defined by v0 and v1\n    // It can also set two optional targets :\n    // - The closest point on the ray\n    // - The closest point on the segment\n\n    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n    _segDir.copy(v1).sub(v0).normalize();\n    _diff.copy(this.origin).sub(_segCenter);\n\n    const segExtent: f32 = v0.distanceTo(v1) * 0.5;\n    const a01: f32 = -this.direction.dot(_segDir);\n    const b0: f32 = _diff.dot(this.direction);\n    const b1: f32 = -_diff.dot(_segDir);\n    const c: f32 = _diff.lengthSq();\n    const det: f32 = Mathf.abs(1 - a01 * a01);\n    let s0: f32, s1: f32, sqrDist: f32, extDet: f32;\n\n    if (det > 0) {\n      // The ray and segment are not parallel.\n\n      s0 = a01 * b1 - b0;\n      s1 = a01 * b0 - b1;\n      extDet = segExtent * det;\n\n      if (s0 >= 0) {\n        if (s1 >= -extDet) {\n          if (s1 <= extDet) {\n            // region 0\n            // Minimum at interior points of ray and segment.\n\n            const invDet = 1 / det;\n            s0 *= invDet;\n            s1 *= invDet;\n            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n          } else {\n            // region 1\n\n            s1 = segExtent;\n            s0 = Mathf.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          // region 5\n\n          s1 = -segExtent;\n          s0 = Mathf.max(0, -(a01 * s1 + b0));\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      } else {\n        if (s1 <= -extDet) {\n          // region 4\n\n          s0 = Mathf.max(0, -(-a01 * segExtent + b0));\n          s1 = s0 > 0 ? -segExtent : Mathf.min(Mathf.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        } else if (s1 <= extDet) {\n          // region 3\n\n          s0 = 0;\n          s1 = Mathf.min(Mathf.max(-segExtent, -b1), segExtent);\n          sqrDist = s1 * (s1 + 2 * b1) + c;\n        } else {\n          // region 2\n\n          s0 = Mathf.max(0, -(a01 * segExtent + b0));\n          s1 = s0 > 0 ? segExtent : Mathf.min(Mathf.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      }\n    } else {\n      // Ray and segment are parallel.\n\n      s1 = a01 > 0 ? -segExtent : segExtent;\n      s0 = Mathf.max(0, -(a01 * s1 + b0));\n      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n    }\n\n    if (optionalPointOnRay) {\n      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n    }\n\n    if (optionalPointOnSegment) {\n      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);\n    }\n\n    return sqrDist;\n  }\n\n  intersectSphere(sphere: Sphere, target: Vector3): Vector3 | null {\n    _vector.subVectors(sphere.center, this.origin);\n    const tca: f32 = _vector.dot(this.direction);\n    const d2: f32 = _vector.dot(_vector) - tca * tca;\n    const radius2: f32 = sphere.radius * sphere.radius;\n\n    if (d2 > radius2) return null;\n\n    const thc = Mathf.sqrt(radius2 - d2);\n\n    // t0 = first intersect point - entrance on front of sphere\n    const t0 = tca - thc;\n\n    // t1 = second intersect point - exit point on back of sphere\n    const t1 = tca + thc;\n\n    // test to see if both t0 and t1 are behind the ray - if so, return null\n    if (t0 < 0 && t1 < 0) return null;\n\n    // test to see if t0 is behind the ray:\n    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n    // in order to always return an intersect point that is in front of the ray.\n    if (t0 < 0) return this.at(t1, target);\n\n    // else t0 is in front of the ray, so return the first collision point scaled by t0\n    return this.at(t0, target);\n  }\n\n  intersectsSphere(sphere: Sphere): boolean {\n    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n  }\n\n  distanceToPlane(plane: Plane): f32 | null {\n    const denominator: f32 = plane.normal.dot(this.direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n      }\n\n      // Null is preferable to undefined since undefined means.... it is undefined\n\n      return null;\n    }\n\n    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n\n    // Return if the ray never intersects the plane\n\n    return t >= 0 ? t : null;\n  }\n\n  intersectPlane(plane: Plane, target: Vector3): Vector3 | null {\n    const t = this.distanceToPlane(plane);\n\n    if (t === null) {\n      return null;\n    }\n\n    return this.at(t, target);\n  }\n\n  intersectsPlane(plane: Plane): boolean {\n    // check if the ray lies on the plane first\n\n    const distToPoint = plane.distanceToPoint(this.origin);\n\n    if (distToPoint === 0) {\n      return true;\n    }\n\n    const denominator = plane.normal.dot(this.direction);\n\n    if (denominator * distToPoint < 0) {\n      return true;\n    }\n\n    // ray origin is behind the plane (and is pointing behind it)\n\n    return false;\n  }\n\n  intersectBox(box: Box3, target: Vector3): Vector3 | null {\n    let tmin: f32, tmax: f32, tymin: f32, tymax: f32, tzmin: f32, tzmax: f32;\n\n    const invdirx: f32 = 1 / this.direction.x,\n      invdiry: f32 = 1 / this.direction.y,\n      invdirz: f32 = 1 / this.direction.z;\n\n    const origin = this.origin;\n\n    if (invdirx >= 0) {\n      tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n\n    if (invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = (box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * invdiry;\n    }\n\n    if (tmin > tymax || tymin > tmax) return null;\n\n    // These lines also handle the case where tmin or tmax is NaN\n    // (result of 0 * Infinity). x !== x returns true if x is NaN\n\n    if (tymin > tmin || tmin !== tmin) tmin = tymin;\n\n    if (tymax < tmax || tmax !== tmax) tmax = tymax;\n\n    if (invdirz >= 0) {\n      tzmin = (box.min.z - origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    } else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = (box.min.z - origin.z) * invdirz;\n    }\n\n    if (tmin > tzmax || tzmin > tmax) return null;\n\n    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n\n    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n\n    //return point closest to the ray (positive side)\n\n    if (tmax < 0) return null;\n\n    return this.at(tmin >= 0 ? tmin : tmax, target);\n  }\n\n  intersectsBox(box: Box3): boolean {\n    return this.intersectBox(box, _vector) !== null;\n  }\n\n  intersectTriangle(a: Vector3, b: Vector3, c: Vector3, backfaceCulling: boolean, target: Vector3): Vector3 | null {\n    // Compute the offset origin, edges, and normal.\n\n    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n    _edge1.subVectors(b, a);\n    _edge2.subVectors(c, a);\n    _normal.crossVectors(_edge1, _edge2);\n\n    // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n    let DdN: f32 = this.direction.dot(_normal);\n    let sign: f32;\n\n    if (DdN > 0) {\n      if (backfaceCulling) return null;\n      sign = 1;\n    } else if (DdN < 0) {\n      sign = -1;\n      DdN = -DdN;\n    } else {\n      return null;\n    }\n\n    _diff.subVectors(this.origin, a);\n    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n\n    // b1 < 0, no intersection\n    if (DdQxE2 < 0) {\n      return null;\n    }\n\n    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));\n\n    // b2 < 0, no intersection\n    if (DdE1xQ < 0) {\n      return null;\n    }\n\n    // b1+b2 > 1, no intersection\n    if (DdQxE2 + DdE1xQ > DdN) {\n      return null;\n    }\n\n    // Line intersects triangle, check if ray does.\n    const QdN = -sign * _diff.dot(_normal);\n\n    // t < 0, no intersection\n    if (QdN < 0) {\n      return null;\n    }\n\n    // Ray intersects triangle.\n    return this.at(QdN / DdN, target);\n  }\n\n  applyMatrix4(matrix4: Matrix4): Ray {\n    this.origin.applyMatrix4(matrix4);\n    this.direction.transformDirection(matrix4);\n\n    return this;\n  }\n\n  equals(ray: Ray): boolean {\n    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n  }\n\n  clone(): Ray {\n    return new Ray().copy(this);\n  }\n}\n","import { UsageType } from \"../../common/GLEnums\";\nimport { Matrix3 } from \"../math/Matrix3\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { BaseAttribute, CloneToken, Float32BufferAttribute, UpdateRange } from \"./BufferAttribute\";\n// import { BufferAttribute } from \"./BufferAttribute\";\nimport { InterleavedBuffer } from \"./InterleavedBuffer\";\n\nconst _vector = new Vector3();\n\nexport class InterleavedBufferAttribute extends BaseAttribute {\n  data: InterleavedBuffer;\n  offset: u32;\n\n  constructor(interleavedBuffer: InterleavedBuffer, itemSize: u32, offset: u32, normalized: boolean = false) {\n    super();\n    this.name = \"\";\n\n    this.data = interleavedBuffer;\n    this.itemSize = itemSize;\n    this.offset = offset;\n\n    this.normalized = normalized;\n  }\n\n  get count(): u32 {\n    return this.data.count;\n  }\n\n  set needsUpdate(value: boolean) {\n    this.data.needsUpdate = value;\n  }\n\n  clone(token: CloneToken | null): BaseAttribute {\n    return new InterleavedBufferAttribute(\n      new InterleavedBuffer(this.data.array.slice(0), this.data.stride),\n      this.itemSize,\n      this.offset,\n      this.normalized\n    );\n  }\n\n  getArray(): ArrayBufferView {\n    return this.data.array;\n  }\n\n  getUsage(): UsageType {\n    return UsageType.DYNAMIC_DRAW;\n  }\n\n  convertBufferAttribute(indices: TypedArray<u32>): BaseAttribute {\n    const attribute = this;\n    // TODO: We cant assume its float 32. But not sure what else to do here\n    const array = this.getArray() as Float32Array;\n    const itemSize = this.itemSize;\n    const normalized = this.normalized;\n\n    const array2 = array.slice(0);\n\n    let index: i32 = 0,\n      index2: i32 = 0;\n\n    for (let i: i32 = 0, l = indices.length; i < l; i++) {\n      const iattribute = attribute as InterleavedBufferAttribute;\n      index = indices[i] * iattribute.data.stride + iattribute.offset;\n\n      for (let j: i32 = 0; j < itemSize; j++) {\n        array2[index2++] = array[index++];\n      }\n    }\n\n    return new Float32BufferAttribute(array2, itemSize, normalized);\n  }\n\n  getUpdateRange(): UpdateRange | null {\n    return null;\n  }\n\n  applyMatrix4(m: Matrix4): InterleavedBufferAttribute {\n    for (let i = 0, l = this.data.count; i < l; i++) {\n      _vector.x = this.getX(i);\n      _vector.y = this.getY(i);\n      _vector.z = this.getZ(i);\n\n      _vector.applyMatrix4(m);\n\n      this.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n\n    return this;\n  }\n\n  applyNormalMatrix(m: Matrix3): InterleavedBufferAttribute {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector.x = this.getX(i);\n      _vector.y = this.getY(i);\n      _vector.z = this.getZ(i);\n\n      _vector.applyNormalMatrix(m);\n\n      this.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n\n    return this;\n  }\n\n  transformDirection(m: Matrix4): InterleavedBufferAttribute {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector.x = this.getX(i);\n      _vector.y = this.getY(i);\n      _vector.z = this.getZ(i);\n\n      _vector.transformDirection(m);\n\n      this.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n\n    return this;\n  }\n\n  setX(index: u32, x: f32): InterleavedBufferAttribute {\n    this.data.array[index * this.data.stride + this.offset] = x;\n\n    return this;\n  }\n\n  setY(index: u32, y: f32): InterleavedBufferAttribute {\n    this.data.array[index * this.data.stride + this.offset + 1] = y;\n\n    return this;\n  }\n\n  setZ(index: u32, z: f32): InterleavedBufferAttribute {\n    this.data.array[index * this.data.stride + this.offset + 2] = z;\n\n    return this;\n  }\n\n  setW(index: u32, w: f32): InterleavedBufferAttribute {\n    this.data.array[index * this.data.stride + this.offset + 3] = w;\n\n    return this;\n  }\n\n  getX(index: u32): f32 {\n    return this.data.array[index * this.data.stride + this.offset];\n  }\n\n  getY(index: u32): f32 {\n    return this.data.array[index * this.data.stride + this.offset + 1];\n  }\n\n  getZ(index: u32): f32 {\n    return this.data.array[index * this.data.stride + this.offset + 2];\n  }\n\n  getW(index: u32): f32 {\n    return this.data.array[index * this.data.stride + this.offset + 3];\n  }\n\n  setXY(index: u32, x: f32, y: f32): InterleavedBufferAttribute {\n    index = index * this.data.stride + this.offset;\n\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n\n    return this;\n  }\n\n  setXYZ(index: u32, x: f32, y: f32, z: f32): InterleavedBufferAttribute {\n    index = index * this.data.stride + this.offset;\n\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n\n    return this;\n  }\n\n  setXYZW(index: u32, x: f32, y: f32, z: f32, w: f32): InterleavedBufferAttribute {\n    index = index * this.data.stride + this.offset;\n\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    this.data.array[index + 3] = w;\n\n    return this;\n  }\n\n  // TODO:\n  //   clone(data) {\n  //     if (data === undefined) {\n  //       console.log(\n  //         \"THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.\"\n  //       );\n\n  //       const array = [];\n\n  //       for (let i = 0; i < this.count; i++) {\n  //         const index = i * this.data.stride + this.offset;\n\n  //         for (let j = 0; j < this.itemSize; j++) {\n  //           array.push(this.data.array[index + j]);\n  //         }\n  //       }\n\n  //       return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);\n  //     } else {\n  //       if (data.interleavedBuffers === undefined) {\n  //         data.interleavedBuffers = {};\n  //       }\n\n  //       if (data.interleavedBuffers[this.data.uuid] === undefined) {\n  //         data.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n  //       }\n\n  //       return new InterleavedBufferAttribute(\n  //         data.interleavedBuffers[this.data.uuid],\n  //         this.itemSize,\n  //         this.offset,\n  //         this.normalized\n  //       );\n  //     }\n  //   }\n\n  // toJSON( data ) {\n\n  // \tif ( data === undefined ) {\n\n  // \t\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );\n\n  // \t\tconst array = [];\n\n  // \t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n  // \t\t\tconst index = i * this.data.stride + this.offset;\n\n  // \t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n  // \t\t\t\tarray.push( this.data.array[ index + j ] );\n\n  // \t\t\t}\n\n  // \t\t}\n\n  // \t\t// deinterleave data and save it as an ordinary buffer attribute for now\n\n  // \t\treturn {\n  // \t\t\titemSize: this.itemSize,\n  // \t\t\ttype: this.array.constructor.name,\n  // \t\t\tarray: array,\n  // \t\t\tnormalized: this.normalized\n  // \t\t};\n\n  // \t} else {\n\n  // \t\t// save as true interlaved attribtue\n\n  // \t\tif ( data.interleavedBuffers === undefined ) {\n\n  // \t\t\tdata.interleavedBuffers = {};\n\n  // \t\t}\n\n  // \t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n  // \t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );\n\n  // \t\t}\n\n  // \t\treturn {\n  // \t\t\tisInterleavedBufferAttribute: true,\n  // \t\t\titemSize: this.itemSize,\n  // \t\t\tdata: this.data.uuid,\n  // \t\t\toffset: this.offset,\n  // \t\t\tnormalized: this.normalized\n  // \t\t};\n\n  // \t}\n\n  // }\n}\n","import { Vector2 } from \"../math/Vector2\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Triangle } from \"../math/Triangle\";\nimport { Object } from \"../core/Object\";\nimport { AttributeTypes, BufferGeometry } from \"../core/BufferGeometry\";\nimport { InterleavedBuffer } from \"../core/InterleavedBuffer\";\nimport { InterleavedBufferAttribute } from \"../core/InterleavedBufferAttribute\";\nimport { SpriteMaterial } from \"../materials/SpriteMaterial\";\nimport { f32Array } from \"../utils\";\nimport { Raycaster } from \"../core/Raycaster\";\nimport { Intersection } from \"./Mesh\";\nimport { PerspectiveCamera } from \"../cameras/PerspectiveCamera\";\nimport { ASError } from \"../core/Error\";\n\nlet _geometry: BufferGeometry;\n\nconst _tempVec2 = new Vector2();\nconst _intersectPoint = new Vector3();\nconst _worldScale = new Vector3();\nconst _mvPosition = new Vector3();\n\nconst _alignedPosition = new Vector2();\nconst _rotatedPosition = new Vector2();\nconst _viewWorldMatrix = new Matrix4();\n\nconst _vA = new Vector3();\nconst _vB = new Vector3();\nconst _vC = new Vector3();\n\nconst _uvA = new Vector2();\nconst _uvB = new Vector2();\nconst _uvC = new Vector2();\n\nexport class Sprite extends Object {\n  geometry: BufferGeometry;\n  material: SpriteMaterial;\n  center: Vector2;\n\n  constructor(material: SpriteMaterial) {\n    super();\n\n    this.type = \"Sprite\";\n\n    if (_geometry === undefined) {\n      _geometry = new BufferGeometry();\n\n      const float32Array = f32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);\n\n      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n\n      _geometry.setIndexes([0, 1, 2, 0, 2, 3]);\n      _geometry.setAttribute(AttributeTypes.POSITION, new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n      _geometry.setAttribute(AttributeTypes.UV, new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n    }\n\n    this.geometry = _geometry;\n    this.material = material !== undefined ? material : new SpriteMaterial();\n\n    this.center = new Vector2(0.5, 0.5);\n  }\n\n  raycast(raycaster: Raycaster, intersects: Intersection[]): void {\n    if (raycaster.camera === null) {\n      throw new ASError('Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.');\n    }\n\n    _worldScale.setFromMatrixScale(this.matrixWorld);\n\n    _viewWorldMatrix.copy(raycaster.camera!.matrixWorld);\n    this.modelViewMatrix.multiplyMatrices(raycaster.camera!.matrixWorldInverse, this.matrixWorld);\n\n    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n\n    if (raycaster.camera! instanceof PerspectiveCamera && this.material.sizeAttenuation === false) {\n      _worldScale.multiplyScalar(-_mvPosition.z);\n    }\n\n    const rotation: f32 = this.material.rotation;\n    let sin: f32 = 0,\n      cos: f32 = 0;\n\n    if (rotation !== 0) {\n      cos = Mathf.cos(rotation);\n      sin = Mathf.sin(rotation);\n    }\n\n    const center = this.center;\n\n    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n    _uvA.set(0, 0);\n    _uvB.set(1, 0);\n    _uvC.set(1, 1);\n\n    // check first triangle\n    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);\n\n    if (intersect === null) {\n      // check second triangle\n      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n      _uvB.set(0, 1);\n\n      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);\n      if (intersect === null) {\n        return;\n      }\n    }\n\n    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n\n    if (distance < raycaster.near || distance > raycaster.far) return;\n\n    intersects.push({\n      distance: distance,\n      point: _intersectPoint.clone(),\n      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),\n      face: null,\n      object: this,\n      faceIndex: -1,\n      uv2: null,\n      instanceId: -1,\n    });\n  }\n\n  copy(source: Sprite): Sprite {\n    super.copy(source);\n\n    if (source.center !== undefined) this.center.copy(source.center);\n\n    this.material = source.material;\n\n    return this;\n  }\n}\n\nfunction transformVertex(\n  vertexPosition: Vector3,\n  mvPosition: Vector3,\n  center: Vector2,\n  scale: Vector3,\n  sin: f32,\n  cos: f32\n): void {\n  // compute position in camera space\n  _alignedPosition\n    .subVectors(_tempVec2.set(vertexPosition.x, vertexPosition.y), center)\n    .addScalar(0.5)\n    .multiply(_tempVec2.set(scale.x, scale.y));\n\n  // to check if rotation is not zero\n  if (sin !== undefined) {\n    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n  } else {\n    _rotatedPosition.copy(_alignedPosition);\n  }\n\n  vertexPosition.copy(mvPosition);\n  vertexPosition.x += _rotatedPosition.x;\n  vertexPosition.y += _rotatedPosition.y;\n\n  // transform to world space\n  vertexPosition.applyMatrix4(_viewWorldMatrix);\n}\n","import { Vector3 } from \"./Vector3\";\nimport { Sphere } from \"./Sphere\";\nimport { Plane } from \"./Plane\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Box3 } from \"./Box3\";\nimport { Mesh } from \"../objects/Mesh\";\nimport { Sprite } from \"../objects/Sprite\";\n\nconst _sphere = new Sphere();\nconst _vector = new Vector3();\n\nexport class Frustum {\n  planes: Plane[];\n\n  constructor(\n    p0: Plane = new Plane(),\n    p1: Plane = new Plane(),\n    p2: Plane = new Plane(),\n    p3: Plane = new Plane(),\n    p4: Plane = new Plane(),\n    p5: Plane = new Plane()\n  ) {\n    this.planes = [p0, p1, p2, p3, p4, p5];\n  }\n\n  set(p0: Plane, p1: Plane, p2: Plane, p3: Plane, p4: Plane, p5: Plane): Frustum {\n    const planes = this.planes;\n\n    planes[0].copy(p0);\n    planes[1].copy(p1);\n    planes[2].copy(p2);\n    planes[3].copy(p3);\n    planes[4].copy(p4);\n    planes[5].copy(p5);\n\n    return this;\n  }\n\n  copy(frustum: Frustum): Frustum {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      planes[i].copy(frustum.planes[i]);\n    }\n\n    return this;\n  }\n\n  setFromProjectionMatrix(m: Matrix4): Frustum {\n    const planes = this.planes;\n    const me = m.elements;\n    const me0 = me[0],\n      me1 = me[1],\n      me2 = me[2],\n      me3 = me[3];\n    const me4 = me[4],\n      me5 = me[5],\n      me6 = me[6],\n      me7 = me[7];\n    const me8 = me[8],\n      me9 = me[9],\n      me10 = me[10],\n      me11 = me[11];\n    const me12 = me[12],\n      me13 = me[13],\n      me14 = me[14],\n      me15 = me[15];\n\n    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n\n    return this;\n  }\n\n  intersectsObject(object: Mesh): boolean {\n    const geometry = object.geometry;\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere!).applyMatrix4(object.matrixWorld);\n\n    return this.intersectsSphere(_sphere);\n  }\n\n  intersectsSprite(sprite: Sprite): boolean {\n    _sphere.center.set(0, 0, 0);\n    _sphere.radius = 0.7071067811865476;\n    _sphere.applyMatrix4(sprite.matrixWorld);\n\n    return this.intersectsSphere(_sphere);\n  }\n\n  intersectsSphere(sphere: Sphere): boolean {\n    const planes = this.planes;\n    const center = sphere.center;\n    const negRadius = -sphere.radius;\n\n    for (let i = 0; i < 6; i++) {\n      const distance = planes[i].distanceToPoint(center);\n\n      if (distance < negRadius) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  intersectsBox(box: Box3): boolean {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      const plane = planes[i];\n\n      // corner at max distance\n\n      _vector.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n      _vector.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n      _vector.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n      if (plane.distanceToPoint(_vector) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  containsPoint(point: Vector3): boolean {\n    const planes = this.planes;\n\n    for (let i = 0; i < 6; i++) {\n      if (planes[i].distanceToPoint(point) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  clone(): Frustum {\n    return new Frustum().copy(this);\n  }\n}\n","import { Matrix4 } from \"../math/Matrix4\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { Vector4 } from \"../math/Vector4\";\nimport { Frustum } from \"../math/Frustum\";\nimport { Camera } from \"../cameras/Camera\";\nimport { Light } from \"./Light\";\nimport { DirectionalLight } from \"./DirectionalLight\";\nimport { SpotLight } from \"./SpotLight\";\n\nconst _projScreenMatrix = new Matrix4();\nconst _lightPositionWorld = new Vector3();\nconst _lookTarget = new Vector3();\n\nexport class LightShadow {\n  camera: Camera;\n  bias: f32;\n  normalBias: f32;\n  radius: f32;\n  mapSize: Vector2;\n  // map: Texture | null;\n  //   mapPass: null;\n  matrix: Matrix4;\n  autoUpdate: boolean;\n  needsUpdate: boolean;\n  _frustum: Frustum;\n  _frameExtents: Vector2;\n  _viewportCount: i32;\n  _viewports: Vector4[];\n\n  constructor(camera: Camera) {\n    this.camera = camera;\n\n    this.bias = 0;\n    this.normalBias = 0;\n    this.radius = 1;\n\n    this.mapSize = new Vector2(512, 512);\n\n    // this.map = null;\n    // this.mapPass = null;\n    this.matrix = new Matrix4();\n\n    this.autoUpdate = true;\n    this.needsUpdate = false;\n\n    this._frustum = new Frustum();\n    this._frameExtents = new Vector2(1, 1);\n\n    this._viewportCount = 1;\n\n    this._viewports = [new Vector4(0, 0, 1, 1)];\n  }\n\n  getViewportCount(): i32 {\n    return this._viewportCount;\n  }\n\n  getFrustum(): Frustum {\n    return this._frustum;\n  }\n\n  updateMatrices(light: Light): void {\n    const shadowCamera = this.camera;\n    const shadowMatrix = this.matrix;\n\n    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n    shadowCamera.position.copy(_lightPositionWorld);\n\n    const target =\n      light instanceof DirectionalLight\n        ? (light as DirectionalLight).target\n        : light instanceof SpotLight\n        ? (light as SpotLight).target\n        : null;\n\n    _lookTarget.setFromMatrixPosition(target!.matrixWorld);\n    shadowCamera.lookAt(_lookTarget.x, _lookTarget.y, _lookTarget.z);\n    shadowCamera.updateMatrixWorld();\n\n    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix);\n\n    // prettier-ignore\n    shadowMatrix.set(\n        0.5, 0.0, 0.0, 0.5,\n        0.0, 0.5, 0.0, 0.5,\n        0.0, 0.0, 0.5, 0.5,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    shadowMatrix.multiply(shadowCamera.projectionMatrix);\n    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);\n  }\n\n  getViewport(viewportIndex: u32): Vector4 {\n    return this._viewports[viewportIndex];\n  }\n\n  getFrameExtents(): Vector2 {\n    return this._frameExtents;\n  }\n\n  dispose(): void {\n    // if (this.map) {\n    //   this.map.dispose();\n    // }\n    // if (this.mapPass) {\n    //   this.mapPass.dispose();\n    // }\n  }\n\n  copy(source: LightShadow): LightShadow {\n    this.camera = source.camera.clone() as Camera;\n\n    this.bias = source.bias;\n    this.radius = source.radius;\n\n    this.mapSize.copy(source.mapSize);\n\n    return this;\n  }\n\n  clone(): LightShadow {\n    return new LightShadow(this.camera).copy(this);\n  }\n\n  // TODO:\n  // toJSON() {\n\n  // \tconst object = {};\n\n  // \tif ( this.bias !== 0 ) object.bias = this.bias;\n  // \tif ( this.normalBias !== 0 ) object.normalBias = this.normalBias;\n  // \tif ( this.radius !== 1 ) object.radius = this.radius;\n  // \tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n  // \tobject.camera = this.camera.toJSON( false ).object;\n  // \tdelete object.camera.matrix;\n\n  // \treturn object;\n\n  // }\n}\n","import { Camera } from \"../cameras/Camera\";\nimport { AmbientLight } from \"../lights/AmbientLight\";\nimport { DirectionalLight } from \"../lights/DirectionalLight\";\nimport { Light } from \"../lights/Light\";\nimport { Color } from \"../math/Color\";\nimport { Vector3 } from \"../math/Vector3\";\n\nconst color: Color = new Color();\nconst vector1: Vector3 = new Vector3();\nconst vector2: Vector3 = new Vector3();\n\n// The buffer size of 1 direction light struct\n// Made up of 2 vec4. The first is direction followed by color\nconst SIZE_DIR_LIGHT_BUFFER: u32 = 4 * 2;\n\nexport class WebGPULights {\n  numDirectionLights: i32;\n  lightingConfigBuffer: Uint32Array;\n  sceneLightsBuffer: Float32Array;\n  directionLightsBuffer!: Float32Array;\n\n  constructor() {\n    this.numDirectionLights = -1;\n    this.lightingConfigBuffer = new Uint32Array(1);\n    this.sceneLightsBuffer = new Float32Array(4);\n  }\n\n  setupLights(lights: Light[], camera: Camera): void {\n    let directionLight: DirectionalLight;\n    const viewMatrix = camera.matrixWorldInverse;\n\n    let numDirLights: u32 = 0;\n    color.setRGB(0, 0, 0);\n\n    for (let i: i32 = 0, l = lights.length; i < l; i++) {\n      if (lights[i] instanceof DirectionalLight) {\n        numDirLights++;\n      } else if (lights[i] instanceof AmbientLight) {\n        const ambient = lights[i] as AmbientLight;\n        color.setRGB(\n          ambient.color.r * ambient.intensity,\n          ambient.color.g * ambient.intensity,\n          ambient.color.b * ambient.intensity\n        );\n      }\n    }\n\n    if (this.numDirectionLights != numDirLights) {\n      this.numDirectionLights = numDirLights;\n      this.directionLightsBuffer = new Float32Array(SIZE_DIR_LIGHT_BUFFER * numDirLights);\n    }\n\n    // Set the info buffer of num of direction lights\n    this.lightingConfigBuffer[0] = numDirLights;\n\n    // Set the scene buffer ambient value\n    this.sceneLightsBuffer[0] = color.r;\n    this.sceneLightsBuffer[1] = color.g;\n    this.sceneLightsBuffer[2] = color.b;\n\n    let dirLightI = 0;\n    for (let i: i32 = 0, l = lights.length; i < l; i++) {\n      if (lights[i] instanceof DirectionalLight) {\n        directionLight = lights[i] as DirectionalLight;\n\n        vector1.setFromMatrixPosition(directionLight.matrixWorld);\n        vector2.setFromMatrixPosition(directionLight.target.matrixWorld);\n        vector1.sub(vector2);\n        vector1.transformDirection(viewMatrix);\n\n        this.directionLightsBuffer[dirLightI * SIZE_DIR_LIGHT_BUFFER] = vector1.x;\n        this.directionLightsBuffer[dirLightI * SIZE_DIR_LIGHT_BUFFER + 1] = vector1.y;\n        this.directionLightsBuffer[dirLightI * SIZE_DIR_LIGHT_BUFFER + 2] = vector1.z;\n        this.directionLightsBuffer[dirLightI * SIZE_DIR_LIGHT_BUFFER + 3] = 0; // Padding\n        this.directionLightsBuffer[dirLightI * SIZE_DIR_LIGHT_BUFFER + 4] =\n          directionLight.color.r * directionLight.intensity;\n        this.directionLightsBuffer[dirLightI * SIZE_DIR_LIGHT_BUFFER + 5] =\n          directionLight.color.g * directionLight.intensity;\n        this.directionLightsBuffer[dirLightI * SIZE_DIR_LIGHT_BUFFER + 6] =\n          directionLight.color.b * directionLight.intensity;\n        this.directionLightsBuffer[dirLightI * SIZE_DIR_LIGHT_BUFFER + 7] = 0; // Padding\n\n        dirLightI++;\n      }\n    }\n  }\n}\n","import { print, render } from \"../Imports\";\nimport { GPUCommands } from \"../../common/Commands\";\nimport { GroupType } from \"../../common/GroupType\";\nimport { WebGPULights } from \"./WebGPULights\";\n\nexport class WebGPURenderQueue {\n  q: Array<i32>;\n\n  constructor() {\n    this.q = new Array<i32>();\n  }\n\n  begin(): WebGPURenderQueue {\n    this.q.splice(0, this.q.length);\n    return this;\n  }\n\n  push(): WebGPURenderQueue {\n    render(this.q);\n    return this;\n  }\n\n  setTransform(\n    transformIndex: i32,\n    projectionMatrix: Float32Array,\n    modelViewMatrix: Float32Array,\n    normalMatrix: Float32Array\n  ): WebGPURenderQueue {\n    const q = this.q;\n    q.push(GPUCommands.SET_TRANSFORM);\n    q.push(transformIndex);\n    q.push(changetype<i32>(projectionMatrix));\n    q.push(changetype<i32>(modelViewMatrix));\n    q.push(changetype<i32>(normalMatrix));\n    return this;\n  }\n\n  setupLighting(lighting: WebGPULights): WebGPURenderQueue {\n    const q = this.q;\n    q.push(GPUCommands.SETUP_LIGHTING);\n    q.push(lighting.numDirectionLights);\n    q.push(changetype<i32>(lighting.lightingConfigBuffer));\n    q.push(changetype<i32>(lighting.sceneLightsBuffer));\n    q.push(changetype<i32>(lighting.directionLightsBuffer));\n    return this;\n  }\n\n  setBindGroupResource(type: GroupType, resourceIndex: u32 = 0): WebGPURenderQueue {\n    const q = this.q;\n    q.push(GPUCommands.SET_BIND_GROUP);\n    q.push(type);\n    q.push(resourceIndex);\n    return this;\n  }\n\n  setPipeline(pipeline: i32): WebGPURenderQueue {\n    const q = this.q;\n    q.push(GPUCommands.SET_PIPELINE);\n    q.push(pipeline);\n    return this;\n  }\n\n  drawIndexed(indexCount: i32): WebGPURenderQueue {\n    const q = this.q;\n    q.push(GPUCommands.DRAW_INDEXED);\n    q.push(indexCount);\n    return this;\n  }\n\n  startPass(): WebGPURenderQueue {\n    const q = this.q;\n    q.push(GPUCommands.START_PASS);\n    return this;\n  }\n\n  endPass(): WebGPURenderQueue {\n    const q = this.q;\n    q.push(GPUCommands.END_PASS);\n    return this;\n  }\n\n  setIndexBuffer(buffer: i32): WebGPURenderQueue {\n    const q = this.q;\n    q.push(GPUCommands.SET_INDEX_BUFFER);\n    q.push(buffer);\n    return this;\n  }\n\n  setBuffer(slot: i32, buffer: i32): WebGPURenderQueue {\n    const q = this.q;\n    q.push(GPUCommands.SET_BUFFER);\n    q.push(slot);\n    q.push(buffer);\n    return this;\n  }\n}\n","import { Camera } from \"../cameras/Camera\";\nimport { Object } from \"../core/Object\";\nimport { WebGPURenderQueue } from \"./WebGPURenderQueue\";\nimport { print } from \"../Imports\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Vector4 } from \"../math/Vector4\";\nimport { Mesh } from \"../objects/Mesh\";\nimport { Scene } from \"../scenes/Scene\";\nimport { WebGPUGeometries } from \"./WebGPUGeometries\";\nimport { AttributeTypes } from \"../core/BufferGeometry\";\nimport { GroupType } from \"../../common/GroupType\";\nimport { WebGPULights } from \"./WebGPULights\";\nimport { Light } from \"../lights/Light\";\n\nconst renderQueue = new WebGPURenderQueue();\n\nexport class RenderList {\n  solids: Mesh[];\n  lights: Light[];\n\n  constructor() {\n    this.solids = [];\n    this.lights = [];\n  }\n\n  reset(): void {\n    this.solids.splice(0, this.solids.length);\n    this.lights.splice(0, this.lights.length);\n  }\n}\n\nexport class WebGPURenderer {\n  view!: Vector4;\n  geometries: WebGPUGeometries;\n  lights: WebGPULights;\n  private _projScreenMatrix: Matrix4;\n  private currentRenderList: RenderList;\n\n  constructor() {\n    this._projScreenMatrix = new Matrix4();\n    this.currentRenderList = new RenderList();\n    this.geometries = new WebGPUGeometries();\n    this.lights = new WebGPULights();\n  }\n\n  init(view: Vector4): void {\n    print(`Initializing WGPU renderer`);\n    this.view = view;\n  }\n\n  render(scene: Scene, camera: Camera): void {\n    // update scene graph\n    scene.updateMatrixWorld();\n\n    // update camera matrices and frustum\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    scene.onBeforeRender();\n\n    const _projScreenMatrix = this._projScreenMatrix;\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n    this.currentRenderList.reset();\n    this.projectObject(scene, camera);\n\n    this.lights.setupLights(this.currentRenderList.lights, camera);\n\n    renderQueue.begin();\n    renderQueue.startPass();\n\n    renderQueue.setupLighting(this.lights);\n\n    for (let i: i32 = 0, l: i32 = this.currentRenderList.solids.length; i < l; i++) {\n      this.renderMesh(this.currentRenderList.solids[i], camera);\n    }\n\n    renderQueue.endPass();\n    renderQueue.push();\n  }\n\n  renderMesh(mesh: Mesh, camera: Camera): void {\n    mesh.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, mesh.matrixWorld);\n    mesh.normalMatrix.getNormalMatrix(mesh.modelViewMatrix);\n\n    // TODO:\n    // ========================\n    renderQueue.setPipeline(mesh.pipelines[0].index);\n\n    const transformIndex = mesh.pipelines[0].transformResourceIndex;\n\n    renderQueue.setTransform(\n      transformIndex,\n      camera.projectionMatrix.elements,\n      mesh.modelViewMatrix.elements,\n      mesh.normalMatrix.elements\n    );\n\n    renderQueue.setBindGroupResource(GroupType.Transform, transformIndex);\n    renderQueue.setBindGroupResource(GroupType.Material);\n\n    // ===========================\n\n    if (mesh.geometry) {\n      const attributeMap = this.geometries.get(mesh.geometry);\n      if (attributeMap) {\n        if (attributeMap.attributeBuffers.has(AttributeTypes.POSITION))\n          renderQueue.setBuffer(0, attributeMap.attributeBuffers.get(AttributeTypes.POSITION));\n\n        if (attributeMap.attributeBuffers.has(AttributeTypes.NORMAL))\n          renderQueue.setBuffer(1, attributeMap.attributeBuffers.get(AttributeTypes.NORMAL));\n\n        if (attributeMap.attributeBuffers.has(AttributeTypes.UV))\n          renderQueue.setBuffer(2, attributeMap.attributeBuffers.get(AttributeTypes.UV));\n\n        if (attributeMap.indexBuffer != -1) {\n          renderQueue.setIndexBuffer(attributeMap.indexBuffer);\n          renderQueue.drawIndexed(mesh.geometry.indexes!.count);\n        } else {\n        }\n      }\n    }\n  }\n\n  projectObject(object: Object, camera: Camera): void {\n    if (object.visible === false) return;\n\n    if (object instanceof Mesh) {\n      this.currentRenderList.solids.push(object as Mesh);\n    } else if (object instanceof Light) {\n      this.currentRenderList.lights.push(object as Light);\n    }\n\n    for (let i = 0, l = object.children.length; i < l; i++) this.projectObject(object.children[i], camera);\n  }\n}\n","import { Object } from \"../../../core/Object\";\nimport { Node } from \"./Node\";\nimport { Mesh } from \"../../Mesh\";\nimport { print } from \"../../../Imports\";\nimport { Portal } from \"./Portal\";\n\nlet totalTime: f32 = 0;\nexport class Container extends Node {\n  protected objects: Object[];\n  protected loaded: boolean;\n\n  constructor(name: string) {\n    super(name);\n    this.objects = [];\n    this.loaded = false;\n    this.portals.push(new Portal(\"Enter\", this));\n    this.portals.push(new Portal(\"Exit\", this));\n  }\n\n  addAsset(object: Object): void {\n    this.objects.push(object);\n  }\n\n  onUpdate(delta: f32, total: u32, fps: u32): void {}\n\n  mount(): void {\n    const objects = this.objects;\n    for (let i: i32 = 0, l: i32 = objects.length; i < l; i++) {\n      this.runtime!.scene.add(objects[i]);\n    }\n    super.mount();\n  }\n\n  unMount(): void {\n    const objects = this.objects;\n    for (let i: i32 = 0, l: i32 = objects.length; i < l; i++) {\n      this.runtime!.scene.remove(objects[i]);\n    }\n    super.unMount();\n  }\n\n  init(): void {\n    // Load any assets\n    const objects = this.objects;\n    for (let i: i32 = 0, l: i32 = objects.length; i < l; i++) {\n      const obj = objects[i];\n      if (obj instanceof Mesh) {\n        const geometry = (obj as Mesh).geometry;\n        if (geometry) this.runtime!.renderer.geometries.set(geometry);\n      }\n    }\n\n    super.init();\n  }\n}\n\nexport function createContainer(name: string): Container {\n  return new Container(name);\n}\n","import { RenderLoop } from \"../core/RenderLoop\";\nimport { Runtime } from \"../objects/routing/core/Runtime\";\nimport { print } from \"../Imports\";\nimport { Vector4 } from \"../math/Vector4\";\nimport { WebGPURenderer } from \"../renderers/WebGPURenderer\";\n\nlet runtime: Runtime | null = null;\nconst renderer = new WebGPURenderer();\n\nexport function getRuntime(): Runtime {\n  return runtime!;\n}\n\nexport function init(w: u16, h: u16): void {\n  print(\"Starting Engine\");\n  renderer.init(new Vector4(0, 0, f32(w), f32(h)));\n  runtime = new Runtime(f32(w), f32(h), renderer);\n}\n\nexport function resize(w: u16, h: u16): void {\n  runtime!.onResize(w, h);\n}\n\nconst renderLoop = new RenderLoop((delta: f32, total: u32, fps: u32) => {\n  runtime!.OnLoop(delta, total, fps);\n});\n\nexport function update(now: u32): void {\n  renderLoop.onFrame(now);\n}\n","import { GPUBufferUsageFlags } from \"../../common/GPUEnums\";\nimport { Float32BufferAttribute } from \"../core/BufferAttribute\";\nimport { AttributeTypes, BufferGeometry } from \"../core/BufferGeometry\";\nimport { Event } from \"../core/Event\";\nimport { Listener } from \"../core/EventDispatcher\";\nimport { InstancedBufferGeometry } from \"../core/InstancedBufferGeometry\";\nimport { createBufferFromF32, createIndexBuffer } from \"../Imports\";\n\nexport class AttributeMap {\n  attributeBuffers: Map<symbol, i32>;\n  indexBuffer: i32;\n\n  constructor() {\n    this.attributeBuffers = new Map<symbol, i32>();\n    this.indexBuffer = -1;\n  }\n}\n\nexport class WebGPUGeometries implements Listener {\n  private geometries: Map<i32, AttributeMap>;\n\n  constructor() {\n    this.geometries = new Map();\n  }\n\n  onEvent(event: Event): void {\n    const geometry = event.target as BufferGeometry;\n\n    geometry.removeEventListener(\"dispose\", this);\n\n    this.geometries.delete(geometry.id);\n\n    if (geometry instanceof InstancedBufferGeometry) {\n      (geometry as InstancedBufferGeometry)._maxInstanceCount = -1;\n    }\n  }\n\n  get(geometry: BufferGeometry): AttributeMap | null {\n    const geometries = this.geometries;\n\n    if (geometries.has(geometry.id)) return geometries.get(geometry.id);\n    return null;\n  }\n\n  set(geometry: BufferGeometry): BufferGeometry {\n    const geometries = this.geometries;\n\n    if (!geometries.has(geometry.id)) {\n      geometry.addEventListener(\"dispose\", this);\n\n      const attributeMap = new AttributeMap();\n\n      geometries.set(geometry.id, attributeMap);\n\n      const posBuffer = geometry.getAttribute<Float32BufferAttribute>(AttributeTypes.POSITION);\n      const normBuffer = geometry.getAttribute<Float32BufferAttribute>(AttributeTypes.NORMAL);\n      const uvBuffer = geometry.getAttribute<Float32BufferAttribute>(AttributeTypes.UV);\n      const indexBuffer = geometry.getIndexes();\n\n      if (posBuffer) {\n        attributeMap.attributeBuffers.set(\n          AttributeTypes.POSITION,\n          createBufferFromF32(posBuffer.array, GPUBufferUsageFlags.COPY_DST | GPUBufferUsageFlags.VERTEX)\n        );\n      }\n\n      if (normBuffer) {\n        attributeMap.attributeBuffers.set(\n          AttributeTypes.NORMAL,\n          createBufferFromF32(normBuffer.array, GPUBufferUsageFlags.COPY_DST | GPUBufferUsageFlags.VERTEX)\n        );\n      }\n\n      if (uvBuffer) {\n        attributeMap.attributeBuffers.set(\n          AttributeTypes.UV,\n          createBufferFromF32(uvBuffer.array, GPUBufferUsageFlags.COPY_DST | GPUBufferUsageFlags.VERTEX)\n        );\n      }\n\n      if (indexBuffer) {\n        attributeMap.indexBuffer = createIndexBuffer(\n          indexBuffer.array,\n          GPUBufferUsageFlags.COPY_DST | GPUBufferUsageFlags.INDEX\n        );\n      }\n    }\n\n    return geometry;\n  }\n\n  update(geometry: BufferGeometry): void {}\n}\n","export type RenderLoopCallback = (delta: f32, totalTime: u32, fps: u32) => void;\n\n/**\n * A class to encapsulate a rate limited render loop\n */\nexport class RenderLoop {\n  private callback: RenderLoopCallback;\n  private msLastFrame: u32;\n  private msFpsLimit: u32;\n  private isFPSLimited: boolean;\n  private totalTime: u32;\n\n  constructor(callback: RenderLoopCallback, fps: u32 = 0) {\n    this.msLastFrame = 0;\n    this.callback = callback;\n    this.totalTime = 0;\n    this.msFpsLimit = 0;\n    this.isFPSLimited = false;\n\n    // Check if we need to limit the FPS\n    if (fps && fps > 0) {\n      this.isFPSLimited = true;\n\n      // Calc how many milliseconds per frame in one second of time.\n      this.msFpsLimit = 1000 / fps;\n    }\n  }\n\n  onFrame(now: u32): RenderLoop {\n    const msDelta: u32 = now - this.msLastFrame;\n    this.totalTime += msDelta;\n\n    // Check if we need to limit the FPS\n    if (this.isFPSLimited) {\n      // What fraction of a single second is the delta time\n      const deltaTime: f32 = f32(msDelta) / 1000.0;\n\n      // Now execute frame since the time has elapsed.\n      if (msDelta >= this.msFpsLimit) {\n        const fps: f32 = Mathf.floor(1 / deltaTime);\n        this.msLastFrame = now;\n        this.callback(deltaTime, this.totalTime, u32(fps));\n      }\n    } else {\n      // Calculate Deltatime between frames and the FPS currently.\n      // ms between frames, Then / by 1 second to get the fraction of a second.\n      let deltaTime: f32 = f32(now - this.msLastFrame) / 1000.0;\n\n      if (deltaTime == 0) return this;\n\n      // Now execute frame since the time has elapsed.\n      // Time it took to generate one frame, divide 1 by that to get how many frames in one second.\n      const fps: f32 = Mathf.floor(1 / deltaTime);\n      this.msLastFrame = now;\n      this.callback(deltaTime, this.totalTime, u32(fps));\n    }\n\n    return this;\n  }\n}\n","import { Listener } from \"../../../core/EventDispatcher\";\nimport { WebGPURenderer } from \"../../../renderers/WebGPURenderer\";\nimport { inputManager } from \"../../../exports/io/InputManager\";\nimport { Event } from \"../../../core/Event\";\nimport { Scene } from \"../../../scenes/Scene\";\nimport { PerspectiveCamera } from \"../../../cameras/PerspectiveCamera\";\nimport { Container } from \"./Container\";\nimport { Node } from \"./Node\";\nimport { Link } from \"./Link\";\nimport { Portal } from \"./Portal\";\nimport { print } from \"../../../Imports\";\n\nexport class Runtime implements Listener {\n  renderer: WebGPURenderer;\n  scene: Scene;\n  camera: PerspectiveCamera;\n\n  private nodes: Node[];\n  private activeNodes: Node[];\n  private inactiveNodes: Node[];\n  private links: Link[];\n\n  constructor(width: f32, height: f32, renderer: WebGPURenderer) {\n    this.nodes = [];\n    this.activeNodes = [];\n    this.inactiveNodes = [];\n    this.links = [];\n\n    this.renderer = renderer;\n    this.scene = new Scene();\n    this.camera = new PerspectiveCamera(45, f32(width) / f32(height), 0.1, 1000);\n    this.camera.position.set(0, 0, 10);\n    this.camera.lookAt(0, 0, 0);\n    this.scene.add(this.camera);\n\n    inputManager.addEventListener(\"mousemove\", this);\n  }\n\n  getNode(name: string): Node | null {\n    const nodes = this.nodes;\n    for (let i: i32 = 0, l = nodes.length; i < l; i++) {\n      if (nodes[i].name == name) return nodes[i];\n    }\n\n    return null;\n  }\n\n  addContainer(container: Container, activevate: boolean): void {\n    container.runtime = this;\n    this.nodes.push(container);\n    if (activevate) this.activeNodes.push(container);\n  }\n\n  OnLoop(delta: f32, total: u32, fps: u32): void {\n    const activeNodes = this.activeNodes;\n    const inactiveNodes = this.inactiveNodes;\n\n    // Unmount inactive nodes\n    const numInactiveNodes = inactiveNodes.length;\n    if (numInactiveNodes) {\n      for (let i: i32 = 0; i < numInactiveNodes; i++) {\n        const node = inactiveNodes[i];\n        node.unMount();\n      }\n\n      inactiveNodes.splice(0, numInactiveNodes);\n    }\n\n    // Initialize and mount nodes\n    for (let i: i32 = 0, l: i32 = activeNodes.length; i < l; i++) {\n      const node = activeNodes[i];\n\n      if (!node.initialized) node.init();\n      if (!node.mounted) node.mount();\n    }\n\n    for (let i: i32 = 0, l: i32 = activeNodes.length; i < l; i++) {\n      activeNodes[i].onUpdate(delta, total, fps);\n    }\n\n    this.renderer.render(this.scene, this.camera);\n  }\n\n  sendSignal(sourcePortal: Portal): void {\n    const activeNodes = this.activeNodes;\n    const links = sourcePortal.links;\n\n    // If the source is no longer active then remove it\n    if (!sourcePortal.node.active) {\n      if (activeNodes.indexOf(sourcePortal.node) != -1) {\n        activeNodes.splice(activeNodes.indexOf(sourcePortal.node), 1);\n        this.inactiveNodes.push(sourcePortal.node);\n\n        print(`Deactivating ${sourcePortal.node.name}`);\n      }\n    }\n\n    for (let i: i32 = 0, l = links.length; i < l; i++) {\n      links[i].destinationPortal!.node.enter(links[i].destinationPortal!);\n\n      print(\n        `Entering ${links[i].destinationPortal!.name} of ${links[i].destinationPortal!.node.name} which is active ${\n          links[i].destinationPortal!.node.active\n        }`\n      );\n\n      if (activeNodes.indexOf(links[i].destinationPortal!.node) == -1) {\n        activeNodes.push(links[i].destinationPortal!.node);\n\n        print(`Activating ${links[i].destinationPortal!.node.name}`);\n      }\n    }\n  }\n\n  onResize(width: f32, height: f32): void {\n    this.camera.aspect = f32(width) / f32(height);\n    this.camera.updateProjectionMatrix();\n  }\n\n  onEvent(event: Event): void {}\n}\n","import { Runtime } from \".\";\nimport { Link } from \"./Link\";\nimport { Portal } from \"./Portal\";\n\nexport class Node {\n  protected portals: Portal[];\n  protected children: Node[];\n  protected parent: Node | null;\n\n  runtime: Runtime | null;\n  initialized: boolean;\n  mounted: boolean;\n  active: boolean;\n  name: string;\n\n  constructor(name: string) {\n    this.name = name;\n    this.children = [];\n    this.portals = [];\n    this.initialized = false;\n    this.parent = null;\n    this.mounted = false;\n    this.active = false;\n  }\n\n  addChild(node: Node): Node {\n    if (node.parent) {\n      node.parent!.removeChild(node);\n    }\n\n    if (this.children.indexOf(node) == -1) this.children.push(node);\n\n    node.parent = this;\n    return node;\n  }\n\n  removeChild(node: Node): Node {\n    const i = this.children.indexOf(node);\n    if (i != -1) {\n      this.children.splice(i, 1);\n      node.parent = null;\n    }\n    return node;\n  }\n\n  init(): void {\n    this.initialized = true;\n  }\n\n  getPortal(name: string): Portal | null {\n    const portals = this.portals;\n    for (let i: i32 = 0, l = portals.length; i < l; i++) if (portals[i].name == name) return portals[i];\n\n    return null;\n  }\n\n  mount(): void {\n    this.mounted = true;\n  }\n\n  unMount(): void {\n    this.mounted = false;\n  }\n\n  onUpdate(delta: f32, total: u32, fps: u32): void {}\n\n  enter(portalEntered: Portal): void {\n    this.active = true;\n  }\n\n  exit(exitPortal: Portal, turnOff: boolean): void {\n    if (turnOff) this.active = false;\n    this.runtime!.sendSignal(exitPortal);\n  }\n}\n","import { Matrix4 } from \"../math/Matrix4\";\nimport { Object } from \"../core/Object\";\nimport { Vector3 } from \"../math/Vector3\";\n\nexport class Camera extends Object {\n  readonly matrixWorldInverse: Matrix4 = new Matrix4();\n  readonly projectionMatrix: Matrix4 = new Matrix4();\n  readonly projectionMatrixInverse: Matrix4 = new Matrix4();\n\n  constructor() {\n    super();\n    this.type = \"Camera\";\n  }\n\n  copy(source: Camera, recursive: boolean = true): Camera {\n    super.copy(source, recursive);\n\n    this.matrixWorldInverse.copy(source.matrixWorldInverse);\n    this.projectionMatrix.copy(source.projectionMatrix);\n    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n\n    return this;\n  }\n\n  getWorldDirection(target: Vector3): Vector3 {\n    this.updateWorldMatrix(true, false);\n\n    const e = this.matrixWorld.elements;\n\n    return target.set(-e[8], -e[9], -e[10]).normalize();\n  }\n\n  updateMatrixWorld(force: boolean = false): void {\n    super.updateMatrixWorld(force);\n\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n\n  updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void {\n    super.updateWorldMatrix(updateParents, updateChildren);\n\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n\n  clone(recursive: boolean = false): Object {\n    return new Camera().copy(this);\n  }\n}\n","import { print } from \"../Imports\";\n\nexport const textures: Texture[] = [];\n\nexport class Texture {\n  name: string;\n  index: i32;\n  constructor(name: string, index: i32) {\n    this.name = name;\n    this.index = index;\n  }\n}\n\nexport function createTexture(name: string, index: i32): Texture {\n  print(`Added texture ${name}...`);\n  textures.push(new Texture(name, index));\n  return textures[textures.length - 1];\n}\n","import { print } from \"../Imports\";\nimport { Pipeline } from \"../pipelines/Pipeline\";\nimport { MeshPipeline } from \"../pipelines/MeshPipeline\";\nimport { PipelineType } from \"../../common/PipelineType\";\n\nconst pipelines: Pipeline[] = [];\n\nexport function createPipeline(name: string, index: i32, type: PipelineType): Pipeline {\n  print(`Added pipeline ${name}...`);\n  if (type == PipelineType.Mesh) pipelines.push(new MeshPipeline(name, index));\n  else throw new Error(`Pipeline type not recognised`);\n\n  return pipelines[pipelines.length - 1];\n}\n\nexport { Pipeline, MeshPipeline };\n","import { Camera } from \"../cameras/Camera\";\nimport { OrthographicCamera } from \"../cameras/OrthographicCamera\";\nimport { PerspectiveCamera } from \"../cameras/PerspectiveCamera\";\nimport { Event } from \"../core/Event\";\nimport { Listener } from \"../core/EventDispatcher\";\nimport { inputManager } from \"../exports/io/InputManager\";\nimport { MouseEvent } from \"../exports/io/MouseEvent\";\nimport { print } from \"../Imports\";\nimport { Matrix4 } from \"../math/Matrix4\";\nimport { Quaternion } from \"../math/Quaternion\";\nimport { Spherical } from \"../math/Spherical\";\nimport { Vector2 } from \"../math/Vector2\";\nimport { Vector3 } from \"../math/Vector3\";\n\nenum STATE {\n  NONE = -1,\n  ROTATE = 0,\n  DOLLY = 1,\n  PAN = 2,\n  TOUCH_ROTATE = 3,\n  TOUCH_DOLLY = 4,\n  TOUCH_PAN = 5,\n}\n\nconst EPS: f32 = 0.000001;\n\nexport class OrbitController implements Listener {\n  object: Camera;\n  enabled: boolean;\n  target: Vector3;\n  enableZoom: boolean;\n  zoomSpeed: f32;\n  minDistance: f32;\n  maxDistance: f32;\n  enableRotate: boolean;\n  rotateSpeed: f32;\n  minZoom: f32;\n  maxZoom: f32;\n  minPolarAngle: f32;\n  maxPolarAngle: f32;\n  minAzimuthAngle: f32;\n  maxAzimuthAngle: f32;\n  enablePan: boolean;\n  autoRotate: boolean;\n  autoRotateSpeed: f32;\n  enableDamping: boolean;\n  dampingFactor: f32;\n\n  private spherical: Spherical;\n  private sphericalDelta: Spherical;\n  private scale: f32;\n  private zoomChanged: boolean;\n  private state: STATE;\n  private panOffset: Vector3;\n\n  private target0: Vector3;\n  private position0: Vector3;\n  private zoom0: f32;\n\n  private rotateStart: Vector2;\n  private rotateEnd: Vector2;\n  private rotateDelta: Vector2;\n\n  private panStart: Vector2;\n  private panEnd: Vector2;\n  private panDelta: Vector2;\n\n  private dollyStart: Vector2;\n  private dollyEnd: Vector2;\n  private dollyDelta: Vector2;\n\n  private updateLastPosition: Vector3;\n  private updateOffset: Vector3;\n  private updateQuat: Quaternion;\n  private updateLastQuaternion: Quaternion;\n  private updateQuatInverse: Quaternion;\n\n  private panLeftV: Vector3;\n  private panUpV: Vector3;\n  private panInternalOffset: Vector3;\n\n  constructor(object: Camera) {\n    this.object = object;\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the object orbits around\n    this.target = new Vector3();\n\n    // How far you can dolly in and out ( PerspectiveCamera only )\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Set to false to disable rotating\n    this.enableRotate = true;\n    this.rotateSpeed = 0.2;\n\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    this.enableZoom = true;\n    this.zoomSpeed = 1.0;\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Mathf.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Mathf.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Mathf.PI, Mathf.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // current position in spherical coordinates\n    this.spherical = new Spherical();\n    this.sphericalDelta = new Spherical();\n\n    this.scale = 1;\n    this.panOffset = new Vector3();\n    this.zoomChanged = false;\n\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    this.enableDamping = true;\n    this.dampingFactor = 0.15;\n\n    // for reset\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 =\n      this.object instanceof PerspectiveCamera\n        ? (this.object as PerspectiveCamera).zoom\n        : (this.object as OrthographicCamera).zoom;\n\n    // Set to false to disable panning\n    this.enablePan = true;\n\n    // for update speedup\n    this.updateOffset = new Vector3();\n    // so camera.up is the orbit axis\n    this.updateQuat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));\n    this.updateQuatInverse = this.updateQuat.clone().invert();\n    this.updateLastPosition = new Vector3();\n    this.updateLastQuaternion = new Quaternion();\n\n    this.rotateStart = new Vector2();\n    this.rotateEnd = new Vector2();\n    this.rotateDelta = new Vector2();\n\n    this.panStart = new Vector2();\n    this.panEnd = new Vector2();\n    this.panDelta = new Vector2();\n\n    this.dollyStart = new Vector2();\n    this.dollyEnd = new Vector2();\n    this.dollyDelta = new Vector2();\n\n    this.panLeftV = new Vector3();\n    this.panUpV = new Vector3();\n    this.panInternalOffset = new Vector3();\n\n    this.state = STATE.NONE;\n\n    inputManager.addEventListener(\"wheel\", this);\n    inputManager.addEventListener(\"mousedown\", this);\n  }\n\n  onEvent(event: Event): void {\n    const mouseEvent = event.attachment as MouseEvent;\n    if (event.type === \"mousedown\") this.onMouseDown(mouseEvent);\n    else if (event.type === \"mouseup\") this.onMouseUp(mouseEvent);\n    else if (event.type === \"mousemove\") this.onMouseMove(mouseEvent);\n    else if (event.type === \"wheel\") this.onMouseWheel(mouseEvent);\n  }\n\n  private onMouseDown(event: MouseEvent): void {\n    if (this.enabled === false) return;\n\n    if (event.button === 0) {\n      if (this.enableRotate === false) return;\n      this.rotateStart.set(f32(event.clientX), f32(event.clientY));\n      this.state = STATE.ROTATE;\n    } else if (event.button === 2) {\n      if (this.enableZoom === false) return;\n      this.dollyStart.set(f32(event.clientX), f32(event.clientY));\n      this.state = STATE.DOLLY;\n    } else if (event.button === 1) {\n      print(`Panning`);\n      if (this.enablePan === false) return;\n      this.panStart.set(f32(event.clientX), f32(event.clientY));\n      this.state = STATE.PAN;\n    }\n\n    if (this.state !== STATE.NONE) {\n      inputManager.addEventListener(\"mousemove\", this);\n      inputManager.addEventListener(\"mouseup\", this);\n      //   this.dispatchEvent(START_EVENT);\n    }\n  }\n\n  private onMouseMove(event: MouseEvent): void {\n    if (this.enabled === false) return;\n    //     // event.preventDefault();\n    if (this.state === STATE.ROTATE) {\n      if (this.enableRotate === false) return;\n      this.rotateEnd.set(f32(event.clientX), f32(event.clientY));\n      this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);\n      // const element = this.domElement === document ? this.domElement.body : this.domElement;\n      // rotating across whole screen goes 360 degrees around\n      this.rotateLeft(((2 * Mathf.PI * this.rotateDelta.x) / f32(event.targetWidth)) * this.rotateSpeed);\n      // rotating up and down along whole screen attempts to go 360, but limited to 180\n      this.rotateUp(((2 * Mathf.PI * this.rotateDelta.y) / f32(event.targetHeight)) * this.rotateSpeed);\n      this.rotateStart.copy(this.rotateEnd);\n      this.update();\n    } else if (this.state === STATE.DOLLY) {\n      if (this.enableZoom === false) return;\n      this.dollyEnd.set(f32(event.clientX), f32(event.clientY));\n      this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart);\n      if (this.dollyDelta.y > 0) {\n        this.dollyIn(this.getZoomScale());\n      } else if (this.dollyDelta.y < 0) {\n        this.dollyOut(this.getZoomScale());\n      }\n      this.dollyStart.copy(this.dollyEnd);\n      this.update();\n    } else if (this.state === STATE.PAN) {\n      if (this.enablePan === false) return;\n      this.panEnd.set(f32(event.clientX), f32(event.clientY));\n      this.panDelta.subVectors(this.panEnd, this.panStart);\n      this.pan(this.panDelta.x, this.panDelta.y, f32(event.targetWidth), f32(event.targetHeight));\n      this.panStart.copy(this.panEnd);\n      this.update();\n    }\n  }\n\n  private onMouseUp(event: MouseEvent): void {\n    if (this.enabled === false) return;\n    inputManager.removeEventListener(\"mousemove\", this);\n    inputManager.removeEventListener(\"mouseup\", this);\n\n    //     this.dispatchEvent(END_EVENT);\n    this.state = STATE.NONE;\n  }\n\n  private onMouseWheel(event: MouseEvent): void {\n    if (\n      this.enabled === false ||\n      this.enableZoom === false ||\n      (this.state !== STATE.NONE && this.state !== STATE.ROTATE)\n    )\n      return;\n\n    // event.preventDefault();\n    // event.stopPropagation();\n\n    if (event.delta < 0) {\n      this.dollyOut(this.getZoomScale());\n    } else if (event.delta > 0) {\n      this.dollyIn(this.getZoomScale());\n    }\n\n    print(`Zooming? with delta ${event.delta}`);\n\n    this.update();\n\n    // this.dispatchEvent(START_EVENT); // not sure why these are here...\n    // this.dispatchEvent(END_EVENT);\n  }\n\n  reset(): void {\n    this.target.copy(this.target0);\n    this.object.position.copy(this.position0);\n    if (this._checkPerspectiveCamera(this.object)) {\n      (this.object as PerspectiveCamera).zoom = this.zoom0;\n      (this.object as PerspectiveCamera).updateProjectionMatrix();\n    } else {\n      (this.object as OrthographicCamera).zoom = this.zoom0;\n      (this.object as OrthographicCamera).updateProjectionMatrix();\n    }\n\n    // this.dispatchEvent(CHANGE_EVENT);\n\n    this.update();\n\n    this.state = STATE.NONE;\n  }\n\n  saveState(): void {\n    this.target0.copy(this.target);\n    this.position0.copy(this.object.position);\n    // Check whether the camera has zoom property\n    if (this._checkOrthographicCamera(this.object) || this._checkPerspectiveCamera(this.object)) {\n      this.zoom0 = (this.object as OrthographicCamera).zoom;\n    }\n  }\n\n  update(): boolean {\n    const position = this.object.position;\n    this.updateOffset.copy(position).sub(this.target);\n\n    // rotate offset to \"y-axis-is-up\" space\n    this.updateOffset.applyQuaternion(this.updateQuat);\n\n    // angle from z-axis around y-axis\n    this.spherical.setFromVector3(this.updateOffset);\n\n    if (this.autoRotate && this.state === STATE.NONE) {\n      this.rotateLeft(this.getAutoRotationAngle());\n    }\n\n    this.spherical.theta += this.sphericalDelta.theta;\n    this.spherical.phi += this.sphericalDelta.phi;\n\n    // restrict theta to be between desired limits\n    this.spherical.theta = Mathf.max(this.minAzimuthAngle, Mathf.min(this.maxAzimuthAngle, this.spherical.theta));\n\n    // restrict phi to be between desired limits\n    this.spherical.phi = Mathf.max(this.minPolarAngle, Mathf.min(this.maxPolarAngle, this.spherical.phi));\n\n    this.spherical.makeSafe();\n\n    this.spherical.radius *= this.scale;\n\n    // restrict radius to be between desired limits\n    this.spherical.radius = Mathf.max(this.minDistance, Mathf.min(this.maxDistance, this.spherical.radius));\n\n    // move target to panned location\n    this.target.add(this.panOffset);\n\n    this.updateOffset.setFromSpherical(this.spherical);\n\n    // rotate offset back to \"camera-up-vector-is-up\" space\n    this.updateOffset.applyQuaternion(this.updateQuatInverse);\n\n    position.copy(this.target).add(this.updateOffset);\n\n    this.object.lookAt(this.target.x, this.target.y, this.target.z);\n\n    if (this.enableDamping === true) {\n      this.sphericalDelta.theta *= 1 - this.dampingFactor;\n      this.sphericalDelta.phi *= 1 - this.dampingFactor;\n    } else {\n      this.sphericalDelta.set(0, 0, 0);\n    }\n\n    this.scale = 1;\n    this.panOffset.set(0, 0, 0);\n\n    // update condition is:\n    // min(camera displacement, camera rotation in radians)^2 > EPS\n    // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n    if (\n      this.zoomChanged ||\n      this.updateLastPosition.distanceToSquared(this.object.position) > EPS ||\n      8.0 * (1.0 - this.updateLastQuaternion.dot(this.object.quaternion)) > EPS\n    ) {\n      //   this.dispatchEvent(CHANGE_EVENT);\n      this.updateLastPosition.copy(this.object.position);\n      this.updateLastQuaternion.copy(this.object.quaternion);\n      this.zoomChanged = false;\n      return true;\n    }\n    return false;\n  }\n\n  panLeft(distance: f32, objectMatrix: Matrix4): void {\n    this.panLeftV.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n    this.panLeftV.multiplyScalar(-distance);\n    this.panOffset.add(this.panLeftV);\n  }\n\n  panUp(distance: f32, objectMatrix: Matrix4): void {\n    this.panUpV.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix\n    this.panUpV.multiplyScalar(distance);\n    this.panOffset.add(this.panUpV);\n  }\n\n  // deltaX and deltaY are in pixels; right and down are positive\n  pan(deltaX: f32, deltaY: f32, clientWidth: f32, clientHeight: f32): void {\n    // const element = this.domElement === document ? this.domElement.body : this.domElement;\n\n    if (this._checkPerspectiveCamera(this.object)) {\n      const persCam = this.object as PerspectiveCamera;\n\n      // perspective\n      const position = persCam.position;\n      this.panInternalOffset.copy(position).sub(this.target);\n      var targetDistance = this.panInternalOffset.length();\n\n      // half of the fov is center to top of screen\n      targetDistance *= Mathf.tan(((persCam.fov / 2) * Mathf.PI) / 180.0);\n\n      // we actually don't use screenWidth, since perspective camera is fixed to screen height\n      this.panLeft((2 * deltaX * targetDistance) / clientHeight, persCam.matrix);\n      this.panUp((2 * deltaY * targetDistance) / clientHeight, persCam.matrix);\n    } else if (this._checkOrthographicCamera(this.object)) {\n      const ortho = this.object as OrthographicCamera;\n      // orthographic\n      this.panLeft((deltaX * (ortho.right - ortho.left)) / ortho.zoom / clientWidth, ortho.matrix);\n      this.panUp((deltaY * (ortho.top - ortho.bottom)) / ortho.zoom / clientHeight, ortho.matrix);\n    } else {\n      // camera neither orthographic nor perspective\n      this.enablePan = false;\n    }\n  }\n\n  dollyIn(dollyScale: f32): void {\n    if (this._checkPerspectiveCamera(this.object)) {\n      this.scale /= dollyScale;\n    } else if (this._checkOrthographicCamera(this.object)) {\n      const ortho = this.object as OrthographicCamera;\n      ortho.zoom = Mathf.max(this.minZoom, Mathf.min(this.maxZoom, ortho.zoom * dollyScale));\n      ortho.updateProjectionMatrix();\n      this.zoomChanged = true;\n    } else {\n      this.enableZoom = false;\n    }\n  }\n\n  dollyOut(dollyScale: f32): void {\n    if (this._checkPerspectiveCamera(this.object)) {\n      this.scale *= dollyScale;\n    } else if (this._checkOrthographicCamera(this.object)) {\n      const ortho = this.object as OrthographicCamera;\n      ortho.zoom = Mathf.max(this.minZoom, Mathf.min(this.maxZoom, ortho.zoom / dollyScale));\n      ortho.updateProjectionMatrix();\n      this.zoomChanged = true;\n    } else {\n      this.enableZoom = false;\n    }\n  }\n\n  getAutoRotationAngle(): f32 {\n    return ((2 * Mathf.PI) / 60 / 60) * this.autoRotateSpeed;\n  }\n\n  getZoomScale(): f32 {\n    return Mathf.pow(0.95, this.zoomSpeed);\n  }\n\n  rotateLeft(angle: f32): void {\n    this.sphericalDelta.theta -= angle;\n  }\n\n  rotateUp(angle: f32): void {\n    this.sphericalDelta.phi -= angle;\n  }\n\n  getPolarAngle(): f32 {\n    return this.spherical.phi;\n  }\n\n  getAzimuthalAngle(): f32 {\n    return this.spherical.theta;\n  }\n\n  dispose(): void {\n    // this.domElement.removeEventListener(\"contextmenu\", this.onContextMenu, false);\n    inputManager.removeEventListener(\"mousedown\", this);\n    inputManager.removeEventListener(\"wheel\", this);\n\n    // this.domElement.removeEventListener(\"touchstart\", this.onTouchStart, false);\n    // this.domElement.removeEventListener(\"touchend\", this.onTouchEnd, false);\n    // this.domElement.removeEventListener(\"touchmove\", this.onTouchMove, false);\n\n    inputManager.removeEventListener(\"mousemove\", this);\n    inputManager.removeEventListener(\"mouseup\", this);\n\n    // this.window.removeEventListener(\"keydown\", this.onKeyDown, false);\n    //this.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n  }\n\n  /**\n   * TS typeguard. Checks whether the provided camera is PerspectiveCamera.\n   * If the check passes (returns true) the passed camera will have the type PerspectiveCamera in the if branch where the check was performed.\n   * @param camera Object to be checked.\n   */\n  private _checkPerspectiveCamera(camera: Camera): boolean {\n    return camera instanceof PerspectiveCamera;\n  }\n  /**\n   * TS typeguard. Checks whether the provided camera is OrthographicCamera.\n   * If the check passes (returns true) the passed camera will have the type OrthographicCamera in the if branch where the check was performed.\n   * @param camera Object to be checked.\n   */\n  private _checkOrthographicCamera(camera: Camera): boolean {\n    return camera instanceof OrthographicCamera;\n  }\n}\n","import { OrbitController } from \"../../../extras/OrbitController\";\nimport { AmbientLight } from \"../../../lights/AmbientLight\";\nimport { DirectionalLight } from \"../../../lights/DirectionalLight\";\nimport { Color } from \"../../../math/Color\";\nimport { Container } from \"../core/Container\";\nimport { inputManager } from \"../../../exports/io/InputManager\";\nimport { KeyboardEvent } from \"../../../exports/io/KeyboardEvent\";\nimport { Listener } from \"../../../core/EventDispatcher\";\nimport { uiSignaller } from \"../../../exports/ui/uiSignalManager\";\nimport { Event } from \"../../../core/Event\";\nimport { Mesh } from \"../../Mesh\";\nimport { UIEventType } from \"../../../../common/UIEventType\";\nimport { UIEvent } from \"../../../exports/ui/UIEvent\";\nimport { Link } from \"../core/Link\";\n\nconst playerHungerThreshold: u32 = 5;\n\nexport class Level1 extends Container implements Listener {\n  orbitController!: OrbitController;\n  totalTime: f32;\n  playerDied: bool;\n  isPaused: bool;\n\n  private direction1!: DirectionalLight;\n  private direction2!: DirectionalLight;\n  private direction3!: DirectionalLight;\n  private ambient!: AmbientLight;\n\n  constructor() {\n    super(\"Level1\");\n    this.totalTime = 0;\n    this.playerDied = false;\n    this.isPaused = false;\n  }\n\n  init(): void {\n    super.init();\n    const link = new Link();\n    const mainMenu = this.runtime!.getNode(\"MainMenu\");\n    link.connect(this.getPortal(\"Exit\")!, mainMenu!.getPortal(\"Enter\")!);\n\n    this.direction1 = new DirectionalLight(new Color(1, 1, 1), 3.1416);\n    this.direction1.position.set(0, 10, 0);\n    this.direction1.target.position.set(0, 0, 0);\n    this.addAsset(this.direction1);\n\n    this.direction2 = new DirectionalLight(new Color(0, 1, 0), 1.1416);\n    this.direction2.position.set(10, -10, 0);\n    this.direction2.target.position.set(0, 0, 0);\n    this.addAsset(this.direction2);\n\n    this.direction3 = new DirectionalLight(new Color(1, 1, 0), 2.1416);\n    this.direction3.position.set(-10, -10, 0);\n    this.direction3.target.position.set(0, 0, 0);\n    this.addAsset(this.direction3);\n\n    this.ambient = new AmbientLight(new Color(1, 1, 1), 0.1);\n    this.addAsset(this.ambient);\n\n    this.orbitController = new OrbitController(this.runtime!.camera);\n  }\n\n  onEvent(event: Event): void {\n    if (event.attachment instanceof KeyboardEvent) {\n      const keyEvent = event.attachment as KeyboardEvent;\n      if (!this.playerDied) {\n        if (keyEvent.code == \"Escape\") {\n          this.isPaused = !this.isPaused;\n          uiSignaller.signalClientEvent(UIEventType.OpenInGameMenu);\n        }\n      }\n    } else {\n      const uiEvent = event.attachment as UIEvent;\n      if (uiEvent.eventType == UIEventType.QuitGame) this.exit(this.getPortal(\"Exit\")!, true);\n      else if (uiEvent.eventType == UIEventType.Resume) this.isPaused = false;\n    }\n  }\n\n  onUpdate(delta: f32, total: u32, fps: u32): void {\n    if (this.isPaused) return;\n\n    const objects = this.objects;\n    this.totalTime += delta;\n\n    if (u32(this.totalTime) > playerHungerThreshold && this.playerDied == false) {\n      this.playerDied = true;\n      this.orbitController.enabled = false;\n      uiSignaller.signalClientEvent(UIEventType.PlayerDied);\n    }\n\n    for (let i: i32 = 0, l: i32 = objects.length; i < l; i++) {\n      if (objects[i] instanceof Mesh) {\n        objects[i].rotation.x += delta * 1;\n        objects[i].rotation.y += delta * 1;\n        objects[i].position.y = Mathf.sin(this.totalTime + objects[i].position.x);\n      }\n    }\n\n    if (this.orbitController) this.orbitController.update();\n  }\n\n  mount(): void {\n    super.mount();\n    this.totalTime = 0;\n    this.playerDied = false;\n    this.isPaused = false;\n\n    this.objects[0].position.set(0, 0, 0);\n    this.objects[1].position.set(3, 0, 0);\n    this.objects[2].position.set(-3, 0, 0);\n    this.objects[2].rotation.y += 0.8;\n\n    // Possitive z comes out of screen\n    this.runtime!.camera.position.set(0, 0, 10);\n    this.runtime!.camera.lookAt(0, 0, 0);\n\n    this.orbitController.enabled = true;\n\n    inputManager.addEventListener(\"keyup\", this);\n    uiSignaller.addEventListener(\"uievent\", this);\n  }\n\n  unMount(): void {\n    super.unMount();\n    this.orbitController.enabled = false;\n    inputManager.removeEventListener(\"keyup\", this);\n    uiSignaller.removeEventListener(\"uievent\", this);\n  }\n}\n\nexport function createLevel1(): Level1 {\n  return new Level1();\n}\n","export * from \"./exports/io\";\nexport * from \"./exports/ui\";\nexport * from \"./exports/AsSceneManager\";\nexport * from \"./exports/TextureFactory\";\nexport * from \"./exports/GeometryFactory\";\nexport * from \"./exports/PipelineFactory\";\nexport * from \"./exports/MeshFactory\";\nexport * from \"./objects/routing\";\nexport { Object } from \"./core/Object\";\n\nexport const Float32ArrayID = idof<Float32Array>();\n","type auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","import { EventAttachable } from \"../../core/EventAttachable\";\n\nexport class MouseEvent extends EventAttachable {\n  constructor(\n    public clientX: i32,\n    public clientY: i32,\n    public pageX: i32,\n    public pageY: i32,\n    public ctrlKey: boolean,\n    public shiftKey: boolean,\n    public altKey: boolean,\n    public button: i32,\n    public buttons: i32,\n    public targetX: i32,\n    public targetY: i32,\n    public targetWidth: i32,\n    public targetHeight: i32,\n    public delta: i16\n  ) {\n    super();\n  }\n}\n\nexport function createMouseEvent(\n  clientX: i32,\n  clientY: i32,\n  pageX: i32,\n  pageY: i32,\n  ctrlKey: boolean,\n  shiftKey: boolean,\n  altKey: boolean,\n  button: i32,\n  buttons: i32,\n  targetX: i32,\n  targetY: i32,\n  targetWidth: i32,\n  targetHeight: i32,\n  delta: i16\n): MouseEvent {\n  return new MouseEvent(\n    clientX,\n    clientY,\n    pageX,\n    pageY,\n    ctrlKey,\n    shiftKey,\n    altKey,\n    button,\n    buttons,\n    targetX,\n    targetY,\n    targetWidth,\n    targetHeight,\n    delta\n  );\n}\n","import { EventAttachable } from \"../../core/EventAttachable\";\n\nexport class KeyboardEvent extends EventAttachable {\n  constructor(public code: string) {\n    super();\n  }\n}\n\nexport function createKeyboardEvent(code: string): KeyboardEvent {\n  return new KeyboardEvent(code);\n}\n","import { EventAttachable } from \"../../core/EventAttachable\";\nimport { UIEventType } from \"../../../common/UIEventType\";\n\nexport class UIEvent extends EventAttachable {\n  eventType: UIEventType;\n\n  constructor(eventType: UIEventType) {\n    super();\n    this.eventType = eventType;\n  }\n}\n","import { BufferAttribute } from \"../core/BufferAttribute\";\nimport { Matrix4 } from \"./Matrix4\";\nimport { Quaternion } from \"./Quaternion\";\n\nexport class Vector4 {\n  x: f32;\n  y: f32;\n  z: f32;\n  w: f32;\n\n  constructor(x: f32 = 0, y: f32 = 0, z: f32 = 0, w: f32 = 1) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n\n  get width(): f32 {\n    return this.z;\n  }\n\n  set width(value: f32) {\n    this.z = value;\n  }\n\n  get height(): f32 {\n    return this.w;\n  }\n\n  set height(value: f32) {\n    this.w = value;\n  }\n\n  set(x: f32, y: f32, z: f32, w: f32): Vector4 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n\n    return this;\n  }\n\n  setScalar(scalar: f32): Vector4 {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    this.w = scalar;\n\n    return this;\n  }\n\n  setX(x: f32): Vector4 {\n    this.x = x;\n\n    return this;\n  }\n\n  setY(y: f32): Vector4 {\n    this.y = y;\n\n    return this;\n  }\n\n  setZ(z: f32): Vector4 {\n    this.z = z;\n\n    return this;\n  }\n\n  setW(w: f32): Vector4 {\n    this.w = w;\n\n    return this;\n  }\n\n  setComponent(index: u32, value: f32): Vector4 {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      case 3:\n        this.w = value;\n        break;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n\n    return this;\n  }\n\n  getComponent(index: u32): f32 {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      case 3:\n        return this.w;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n  }\n\n  clone(): Vector4 {\n    return new Vector4(this.x, this.y, this.z, this.w);\n  }\n\n  copy(v: Vector4): Vector4 {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    this.w = v.w;\n\n    return this;\n  }\n\n  add(v: Vector4): Vector4 {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    this.w += v.w;\n\n    return this;\n  }\n\n  addScalar(s: f32): Vector4 {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    this.w += s;\n\n    return this;\n  }\n\n  addVectors(a: Vector4, b: Vector4): Vector4 {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    this.w = a.w + b.w;\n\n    return this;\n  }\n\n  addScaledVector(v: Vector4, s: f32): Vector4 {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    this.w += v.w * s;\n\n    return this;\n  }\n\n  sub(v: Vector4): Vector4 {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= v.w;\n\n    return this;\n  }\n\n  subScalar(s: f32): Vector4 {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    this.w -= s;\n\n    return this;\n  }\n\n  subVectors(a: Vector4, b: Vector4): Vector4 {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    this.w = a.w - b.w;\n\n    return this;\n  }\n\n  multiply(v: Vector4): Vector4 {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    this.w *= v.w;\n\n    return this;\n  }\n\n  multiplyScalar(scalar: f32): Vector4 {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w *= scalar;\n\n    return this;\n  }\n\n  applyMatrix4(m: Matrix4): Vector4 {\n    const x = this.x,\n      y = this.y,\n      z = this.z,\n      w = this.w;\n    const e = m.elements;\n\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\n    return this;\n  }\n\n  divideScalar(scalar: f32): Vector4 {\n    return this.multiplyScalar(1 / scalar);\n  }\n\n  setAxisAngleFromQuaternion(q: Quaternion): Vector4 {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n    // q is assumed to be normalized\n\n    this.w = 2 * Mathf.acos(q.w);\n\n    const s = Mathf.sqrt(1 - q.w * q.w);\n\n    if (s < 0.0001) {\n      this.x = 1;\n      this.y = 0;\n      this.z = 0;\n    } else {\n      this.x = q.x / s;\n      this.y = q.y / s;\n      this.z = q.z / s;\n    }\n\n    return this;\n  }\n\n  setAxisAngleFromRotationMatrix(m: Matrix4): Vector4 {\n    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n    let angle: f32, x: f32, y: f32, z: f32; // variables for result\n    const epsilon: f32 = 0.01, // margin to allow for rounding errors\n      epsilon2: f32 = 0.1, // margin to distinguish between 0 and 180 degrees\n      te = m.elements,\n      m11: f32 = te[0],\n      m12: f32 = te[4],\n      m13: f32 = te[8],\n      m21: f32 = te[1],\n      m22: f32 = te[5],\n      m23: f32 = te[9],\n      m31: f32 = te[2],\n      m32: f32 = te[6],\n      m33: f32 = te[10];\n\n    if (Mathf.abs(m12 - m21) < epsilon && Mathf.abs(m13 - m31) < epsilon && Mathf.abs(m23 - m32) < epsilon) {\n      // singularity found\n      // first check for identity matrix which must have +1 for all terms\n      // in leading diagonal and zero in other terms\n\n      if (\n        Mathf.abs(m12 + m21) < epsilon2 &&\n        Mathf.abs(m13 + m31) < epsilon2 &&\n        Mathf.abs(m23 + m32) < epsilon2 &&\n        Mathf.abs(m11 + m22 + m33 - 3) < epsilon2\n      ) {\n        // this singularity is identity matrix so angle = 0\n\n        this.set(1, 0, 0, 0);\n\n        return this; // zero angle, arbitrary axis\n      }\n\n      // otherwise this singularity is angle = 180\n\n      angle = Mathf.PI;\n\n      const xx: f32 = (m11 + 1) / 2;\n      const yy: f32 = (m22 + 1) / 2;\n      const zz: f32 = (m33 + 1) / 2;\n      const xy: f32 = (m12 + m21) / 4;\n      const xz: f32 = (m13 + m31) / 4;\n      const yz: f32 = (m23 + m32) / 4;\n\n      if (xx > yy && xx > zz) {\n        // m11 is the largest diagonal term\n\n        if (xx < epsilon) {\n          x = 0;\n          y = 0.707106781;\n          z = 0.707106781;\n        } else {\n          x = Mathf.sqrt(xx);\n          y = xy / x;\n          z = xz / x;\n        }\n      } else if (yy > zz) {\n        // m22 is the largest diagonal term\n\n        if (yy < epsilon) {\n          x = 0.707106781;\n          y = 0;\n          z = 0.707106781;\n        } else {\n          y = Mathf.sqrt(yy);\n          x = xy / y;\n          z = yz / y;\n        }\n      } else {\n        // m33 is the largest diagonal term so base result on this\n\n        if (zz < epsilon) {\n          x = 0.707106781;\n          y = 0.707106781;\n          z = 0;\n        } else {\n          z = Mathf.sqrt(zz);\n          x = xz / z;\n          y = yz / z;\n        }\n      }\n\n      this.set(x, y, z, angle);\n\n      return this; // return 180 deg rotation\n    }\n\n    // as we have reached here there are no singularities so we can handle normally\n\n    let s: f32 = Mathf.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n    if (Mathf.abs(s) < 0.001) s = 1;\n\n    // prevent divide by zero, should not happen if matrix is orthogonal and should be\n    // caught by singularity test above, but I've left it in just in case\n\n    this.x = (m32 - m23) / s;\n    this.y = (m13 - m31) / s;\n    this.z = (m21 - m12) / s;\n    this.w = Mathf.acos((m11 + m22 + m33 - 1) / 2);\n\n    return this;\n  }\n\n  min(v: Vector4): Vector4 {\n    this.x = Mathf.min(this.x, v.x);\n    this.y = Mathf.min(this.y, v.y);\n    this.z = Mathf.min(this.z, v.z);\n    this.w = Mathf.min(this.w, v.w);\n\n    return this;\n  }\n\n  max(v: Vector4): Vector4 {\n    this.x = Mathf.max(this.x, v.x);\n    this.y = Mathf.max(this.y, v.y);\n    this.z = Mathf.max(this.z, v.z);\n    this.w = Mathf.max(this.w, v.w);\n\n    return this;\n  }\n\n  clamp(min: Vector4, max: Vector4): Vector4 {\n    // assumes min < max, componentwise\n\n    this.x = Mathf.max(min.x, Mathf.min(max.x, this.x));\n    this.y = Mathf.max(min.y, Mathf.min(max.y, this.y));\n    this.z = Mathf.max(min.z, Mathf.min(max.z, this.z));\n    this.w = Mathf.max(min.w, Mathf.min(max.w, this.w));\n\n    return this;\n  }\n\n  clampScalar(minVal: f32, maxVal: f32): Vector4 {\n    this.x = Mathf.max(minVal, Mathf.min(maxVal, this.x));\n    this.y = Mathf.max(minVal, Mathf.min(maxVal, this.y));\n    this.z = Mathf.max(minVal, Mathf.min(maxVal, this.z));\n    this.w = Mathf.max(minVal, Mathf.min(maxVal, this.w));\n\n    return this;\n  }\n\n  clampLength(min: f32, max: f32): Vector4 {\n    const length = this.length();\n\n    return this.divideScalar(length || 1).multiplyScalar(Mathf.max(min, Mathf.min(max, length)));\n  }\n\n  floor(): Vector4 {\n    this.x = Mathf.floor(this.x);\n    this.y = Mathf.floor(this.y);\n    this.z = Mathf.floor(this.z);\n    this.w = Mathf.floor(this.w);\n\n    return this;\n  }\n\n  ceil(): Vector4 {\n    this.x = Mathf.ceil(this.x);\n    this.y = Mathf.ceil(this.y);\n    this.z = Mathf.ceil(this.z);\n    this.w = Mathf.ceil(this.w);\n\n    return this;\n  }\n\n  round(): Vector4 {\n    this.x = Mathf.round(this.x);\n    this.y = Mathf.round(this.y);\n    this.z = Mathf.round(this.z);\n    this.w = Mathf.round(this.w);\n\n    return this;\n  }\n\n  roundToZero(): Vector4 {\n    this.x = this.x < 0 ? Mathf.ceil(this.x) : Mathf.floor(this.x);\n    this.y = this.y < 0 ? Mathf.ceil(this.y) : Mathf.floor(this.y);\n    this.z = this.z < 0 ? Mathf.ceil(this.z) : Mathf.floor(this.z);\n    this.w = this.w < 0 ? Mathf.ceil(this.w) : Mathf.floor(this.w);\n\n    return this;\n  }\n\n  negate(): Vector4 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n\n    return this;\n  }\n\n  dot(v: Vector4): f32 {\n    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  }\n\n  lengthSq(): f32 {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }\n\n  length(): f32 {\n    return Mathf.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n\n  manhattanLength(): f32 {\n    return Mathf.abs(this.x) + Mathf.abs(this.y) + Mathf.abs(this.z) + Mathf.abs(this.w);\n  }\n\n  normalize(): Vector4 {\n    return this.divideScalar(this.length() || 1);\n  }\n\n  setLength(length: f32): Vector4 {\n    return this.normalize().multiplyScalar(length);\n  }\n\n  lerp(v: Vector4, alpha: f32): Vector4 {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    this.w += (v.w - this.w) * alpha;\n\n    return this;\n  }\n\n  lerpVectors(v1: Vector4, v2: Vector4, alpha: f32): Vector4 {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    this.w = v1.w + (v2.w - v1.w) * alpha;\n\n    return this;\n  }\n\n  equals(v: Vector4): boolean {\n    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n  }\n\n  fromArray(array: f32[], offset: u32 = 0): Vector4 {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n\n    return this;\n  }\n\n  toArray(array: f32[] = [], offset: u32 = 0): f32[] {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    array[offset + 3] = this.w;\n\n    return array;\n  }\n\n  fromBufferAttribute(attribute: BufferAttribute<f32, Float32Array>, index: u32): Vector4 {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    this.w = attribute.getW(index);\n\n    return this;\n  }\n\n  random(): Vector4 {\n    this.x = Mathf.random();\n    this.y = Mathf.random();\n    this.z = Mathf.random();\n    this.w = Mathf.random();\n\n    return this;\n  }\n}\n","import { Object } from \"../core/Object\";\nimport { Material } from \"../materials/Material\";\nimport { Color } from \"../math/Color\";\nimport { Texture } from \"../textures/Texture\";\nimport { Fog } from \"./Fog\";\n\nexport class Scene extends Object {\n  isScene: boolean = true;\n  autoUpdate: boolean;\n  overrideMaterial: Material | null;\n  fog: Fog | null;\n  environment: Texture | null;\n  background: Color | null;\n\n  constructor() {\n    super();\n\n    this.type = \"Scene\";\n\n    this.background = null;\n    this.environment = null;\n    this.fog = null;\n\n    this.overrideMaterial = null;\n    this.autoUpdate = true; // checked by the renderer\n  }\n\n  copy(source: Scene, recursive: boolean): Scene {\n    super.copy(source, recursive);\n\n    const background = source.background;\n    const environment = source.environment;\n    const overrideMaterial = source.overrideMaterial;\n    const fog = source.fog;\n\n    if (background != null) this.background = background.clone();\n    if (environment != null) this.environment = environment.clone();\n    if (fog != null) this.fog = fog.clone();\n    if (overrideMaterial != null) this.overrideMaterial = overrideMaterial.clone();\n\n    this.autoUpdate = source.autoUpdate;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n\n    return this;\n  }\n\n  // TODO:\n  // toJSON( meta ) {\n\n  // \tconst data = super.toJSON( meta );\n\n  // \tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n  // \tif ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );\n  // \tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n  // \treturn data;\n\n  // }\n}\n","import { Camera } from \"./Camera\";\nimport * as MathUtils from \"../math/MathUtils\";\nimport { ViewProperties } from \"./ViewProperties\";\n\nexport class PerspectiveCamera extends Camera {\n  fov: f32;\n  zoom: f32;\n  near: f32;\n  far: f32;\n  focus: f32;\n  aspect: f32;\n  filmGauge: f32; // width of the film (default in millimeters)\n  filmOffset: f32;\n  view: ViewProperties | null;\n\n  constructor(fov: f32 = 50, aspect: f32 = 1, near: f32 = 0.1, far: f32 = 2000) {\n    super();\n\n    this.type = \"PerspectiveCamera\";\n\n    this.fov = fov;\n    this.zoom = 1;\n\n    this.near = near;\n    this.far = far;\n    this.focus = 10;\n\n    this.aspect = aspect;\n    this.view = null;\n\n    this.filmGauge = 35; // width of the film (default in millimeters)\n    this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n    this.updateProjectionMatrix();\n  }\n\n  copy(source: PerspectiveCamera, recursive: boolean = true): PerspectiveCamera {\n    super.copy(source, recursive);\n\n    this.fov = source.fov;\n    this.zoom = source.zoom;\n\n    this.near = source.near;\n    this.far = source.far;\n    this.focus = source.focus;\n\n    this.aspect = source.aspect;\n    this.view = source.view === null ? null : new ViewProperties(source.view);\n\n    this.filmGauge = source.filmGauge;\n    this.filmOffset = source.filmOffset;\n\n    return this;\n  }\n\n  /**\n   * Sets the FOV by focal length in respect to the current .filmGauge.\n   *\n   * The default film gauge is 35, so that the focal length can be specified for\n   * a 35mm (full frame) camera.\n   *\n   * Values for focal length and film gauge must have the same unit.\n   */\n  setFocalLength(focalLength: f32): void {\n    /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n    const vExtentSlope = (0.5 * this.getFilmHeight()) / focalLength;\n\n    this.fov = MathUtils.RAD2DEG * 2 * Mathf.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n  }\n\n  /**\n   * Calculates the focal length from the current .fov and .filmGauge.\n   */\n  getFocalLength(): f32 {\n    const vExtentSlope = Mathf.tan(MathUtils.DEG2RAD * 0.5 * this.fov);\n\n    return (0.5 * this.getFilmHeight()) / vExtentSlope;\n  }\n\n  getEffectiveFOV(): f32 {\n    return MathUtils.RAD2DEG * 2 * Mathf.atan(Mathf.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);\n  }\n\n  getFilmWidth(): f32 {\n    // film not completely covered in portrait format (aspect < 1)\n    return this.filmGauge * Mathf.min(this.aspect, 1);\n  }\n\n  getFilmHeight(): f32 {\n    // film not completely covered in landscape format (aspect > 1)\n    return this.filmGauge / Mathf.max(this.aspect, 1);\n  }\n\n  /**\n   * Sets an offset in a larger frustum. This is useful for multi-window or\n   * multi-monitor/multi-machine setups.\n   *\n   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n   * the monitors are in grid like this\n   *\n   *   +---+---+---+\n   *   | A | B | C |\n   *   +---+---+---+\n   *   | D | E | F |\n   *   +---+---+---+\n   *\n   * then for each monitor you would call it like this\n   *\n   *   const w = 1920;\n   *   const h = 1080;\n   *   const fullWidth = w * 3;\n   *   const fullHeight = h * 2;\n   *\n   *   --A--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n   *   --B--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n   *   --C--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n   *   --D--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n   *   --E--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n   *   --F--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n   *\n   *   Note there is no reason monitors have to be the same size or in a grid.\n   */\n  setViewOffset(fullWidth: f32, fullHeight: f32, x: f32, y: f32, width: f32, height: f32): void {\n    this.aspect = fullWidth / fullHeight;\n\n    if (this.view === null) {\n      this.view = new ViewProperties(null);\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n\n    this.updateProjectionMatrix();\n  }\n\n  clearViewOffset(): void {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n\n    this.updateProjectionMatrix();\n  }\n\n  updateProjectionMatrix(): void {\n    const near: f32 = this.near;\n    let top: f32 = (near * Mathf.tan(MathUtils.DEG2RAD * 0.5 * this.fov)) / this.zoom;\n    let height: f32 = 2 * top;\n    let width: f32 = this.aspect * height;\n    let left: f32 = -0.5 * width;\n    const view = this.view;\n\n    if (view != null && view.enabled) {\n      const fullWidth = view.fullWidth,\n        fullHeight = view.fullHeight;\n\n      left += (view.offsetX * width) / fullWidth;\n      top -= (view.offsetY * height) / fullHeight;\n      width *= view.width / fullWidth;\n      height *= view.height / fullHeight;\n    }\n\n    const skew = this.filmOffset;\n    if (skew !== 0) left += (near * skew) / this.getFilmWidth();\n\n    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n\n  // TODO\n  // toJSON( meta ) {\n\n  // \tconst data = super.toJSON( meta );\n\n  // \tdata.object.fov = this.fov;\n  // \tdata.object.zoom = this.zoom;\n\n  // \tdata.object.near = this.near;\n  // \tdata.object.far = this.far;\n  // \tdata.object.focus = this.focus;\n\n  // \tdata.object.aspect = this.aspect;\n\n  // \tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n  // \tdata.object.filmGauge = this.filmGauge;\n  // \tdata.object.filmOffset = this.filmOffset;\n\n  // \treturn data;\n\n  // }\n}\n","import { AttributeTypes, BufferGeometry } from \"../core/BufferGeometry\";\nimport { Float32BufferAttribute } from \"../core/BufferAttribute\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { f32Array } from \"../utils\";\n\nexport class BoxGeometryParameters {\n  public width: f32;\n  public height: f32;\n  public depth: f32;\n  public widthSegments: u16;\n  public heightSegments: u16;\n  public depthSegments: u16;\n}\n\nclass BoxGeometryBuilder {\n  indices: u32[] = [];\n  vertices: f32[] = [];\n  normals: f32[] = [];\n  uvs: f32[] = [];\n  private numberOfVertices: u16 = 0;\n  private groupStart: u16 = 0;\n\n  constructor(public widthSegments: u16, public heightSegments: u16, public depthSegments: u16) {}\n\n  buildPlane(\n    u: u8,\n    v: u8,\n    w: u8,\n    udir: f32,\n    vdir: f32,\n    width: f32,\n    height: f32,\n    depth: f32,\n    gridX: u16,\n    gridY: u16,\n    materialIndex: u16,\n    box: BoxGeometry\n  ): void {\n    const vertices = this.vertices;\n    const indices = this.indices;\n    const normals = this.normals;\n    const uvs = this.uvs;\n    const numberOfVertices = this.numberOfVertices;\n\n    const segmentWidth: f32 = width / gridX;\n    const segmentHeight: f32 = height / gridY;\n\n    const widthHalf: f32 = width / 2;\n    const heightHalf: f32 = height / 2;\n    const depthHalf: f32 = depth / 2;\n\n    const gridX1: u16 = gridX + 1;\n    const gridY1: u16 = gridY + 1;\n\n    let vertexCounter: u16 = 0;\n    let groupCount: u16 = 0;\n\n    const vector = new Vector3();\n\n    // generate vertices, normals and uvs\n\n    for (let iy: u16 = 0; iy < gridY1; iy++) {\n      const y = iy * segmentHeight - heightHalf;\n\n      for (let ix: u16 = 0; ix < gridX1; ix++) {\n        const x: f32 = ix * segmentWidth - widthHalf;\n\n        // set values to correct vector component\n\n        vector.setByIndex(u, x * udir);\n        vector.setByIndex(v, y * vdir);\n        vector.setByIndex(w, depthHalf);\n\n        // now apply vector to vertex buffer\n\n        vertices.push(vector.x);\n        vertices.push(vector.y);\n        vertices.push(vector.z);\n\n        // set values to correct vector component\n\n        vector.setByIndex(u, 0);\n        vector.setByIndex(v, 0);\n        vector.setByIndex(w, depth > 0 ? 1 : -1);\n\n        // now apply vector to normal buffer\n\n        normals.push(vector.x);\n        normals.push(vector.y);\n        normals.push(vector.z);\n\n        // uvs\n\n        uvs.push(ix / gridX);\n        uvs.push(1 - iy / gridY);\n\n        // counters\n\n        vertexCounter += 1;\n      }\n    }\n\n    // indices\n\n    // 1. you need three indices to draw a single face\n    // 2. a single segment consists of two faces\n    // 3. so we need to generate six (2*3) indices per segment\n\n    for (let iy: u16 = 0; iy < gridY; iy++) {\n      for (let ix: u16 = 0; ix < gridX; ix++) {\n        const a: u16 = numberOfVertices + ix + gridX1 * iy;\n        const b: u16 = numberOfVertices + ix + gridX1 * (iy + 1);\n        const c: u16 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n        const d: u16 = numberOfVertices + (ix + 1) + gridX1 * iy;\n\n        // faces\n\n        indices.push(a);\n        indices.push(b);\n        indices.push(d);\n\n        indices.push(b);\n        indices.push(c);\n        indices.push(d);\n\n        // increase counter\n\n        groupCount += 6;\n      }\n    }\n\n    // add a group to the geometry. this will ensure multi material support\n\n    box.addGroup(this.groupStart, groupCount, materialIndex);\n\n    // calculate new start value for groups\n\n    this.groupStart += groupCount;\n\n    // update total number of vertices\n\n    this.numberOfVertices += vertexCounter;\n  }\n}\n\nexport class BoxGeometry extends BufferGeometry {\n  parameters: BoxGeometryParameters;\n\n  constructor(\n    width: f32 = 1,\n    height: f32 = 1,\n    depth: f32 = 1,\n    widthSegments: u16 = 1,\n    heightSegments: u16 = 1,\n    depthSegments: u16 = 1\n  ) {\n    super();\n\n    this.type = \"BoxGeometry\";\n\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments,\n    };\n\n    // segments\n    const builder = new BoxGeometryBuilder(\n      <u16>Math.floor(widthSegments),\n      <u16>Math.floor(heightSegments),\n      <u16>Math.floor(depthSegments)\n    );\n\n    // build each side of the box geometry\n\n    builder.buildPlane(2, 1, 0, -1, -1, depth, height, width, depthSegments, heightSegments, 0, this); // px\n    builder.buildPlane(2, 1, 0, 1, -1, depth, height, -width, depthSegments, heightSegments, 1, this); // nx\n    builder.buildPlane(0, 2, 1, 1, 1, width, depth, height, widthSegments, depthSegments, 2, this); // py\n    builder.buildPlane(0, 2, 1, 1, -1, width, depth, -height, widthSegments, depthSegments, 3, this); // ny\n    builder.buildPlane(0, 1, 2, 1, -1, width, height, depth, widthSegments, heightSegments, 4, this); // pz\n    builder.buildPlane(0, 1, 2, -1, -1, width, height, -depth, widthSegments, heightSegments, 5, this); // nz\n\n    // build geometry\n\n    this.setIndexes(builder.indices);\n    this.setAttribute(AttributeTypes.POSITION, new Float32BufferAttribute(f32Array(builder.vertices), 3));\n    this.setAttribute(AttributeTypes.NORMAL, new Float32BufferAttribute(f32Array(builder.normals), 3));\n    this.setAttribute(AttributeTypes.UV, new Float32BufferAttribute(f32Array(builder.uvs), 2));\n  }\n\n  // static fromJSON( data ) {\n  // \treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n  // }\n}\n","import { BoxGeometry } from \"../geometries/BoxGeometry\";\nimport { PlaneGeometry } from \"../geometries/PlaneGeometry\";\nimport { SphereGeometry } from \"../geometries/SphereGeometry\";\nimport { print } from \"../Imports\";\n\nexport function createBox(\n  width: f32 = 1,\n  height: f32 = 1,\n  depth: f32 = 1,\n  widthSegments: u16 = 1,\n  heightSegments: u16 = 1,\n  depthSegments: u16 = 1\n): BoxGeometry {\n  const geometry = new BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);\n  return geometry;\n}\n\nexport function createPlane(\n  width: f32 = 1,\n  height: f32 = 1,\n  widthSegments: u16 = 1,\n  heightSegments: u16 = 1\n): PlaneGeometry {\n  const geometry = new PlaneGeometry(width, height, widthSegments, heightSegments);\n  return geometry;\n}\n\nexport function createSphere(radius: f32 = 1, widthSegments: u16 = 32, heightSegments: u16 = 16): SphereGeometry {\n  const geometry = new SphereGeometry(radius, widthSegments, heightSegments);\n  return geometry;\n}\n\nexport function addVertGeometry(verts: Float32Array): i32 {\n  print(\"Added a new object\");\n  print(`We received your vector ${verts[0]}, ${verts[1]}, ${verts[2]}`);\n  return 0;\n}\n","import { AttributeTypes, BufferGeometry } from \"../core/BufferGeometry\";\nimport { Float32BufferAttribute } from \"../core/BufferAttribute\";\nimport { f32Array } from \"../utils\";\n\nexport class PlaneGeometryParameters {\n  public width: f32;\n  public height: f32;\n  public widthSegments: u32;\n  public heightSegments: u32;\n}\n\nexport class PlaneGeometry extends BufferGeometry {\n  parameters: PlaneGeometryParameters;\n\n  constructor(width: f32 = 1, height: f32 = 1, widthSegments: u16 = 1, heightSegments: u16 = 1) {\n    super();\n    this.type = \"PlaneGeometry\";\n    this.parameters = {\n      width: width,\n      height: height,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n    };\n\n    const width_half: f32 = width / 2;\n    const height_half: f32 = height / 2;\n\n    const gridX: u32 = u32(Math.floor(widthSegments));\n    const gridY: u32 = u32(Math.floor(heightSegments));\n\n    const gridX1: u32 = gridX + 1;\n    const gridY1: u32 = gridY + 1;\n\n    const segment_width = width / f32(gridX);\n    const segment_height = height / f32(gridY);\n\n    //\n\n    const indices: u32[] = [];\n    const vertices: f32[] = [];\n    const normals: f32[] = [];\n    const uvs: f32[] = [];\n\n    for (let iy: u32 = 0; iy < gridY1; iy++) {\n      const y: f32 = f32(iy) * segment_height - height_half;\n\n      for (let ix: u32 = 0; ix < gridX1; ix++) {\n        const x: f32 = f32(ix) * segment_width - width_half;\n\n        vertices.push(x);\n        vertices.push(-y);\n        vertices.push(0);\n\n        normals.push(0);\n        normals.push(0);\n        normals.push(1);\n\n        uvs.push(f32(ix) / f32(gridX));\n        uvs.push(1 - f32(iy) / f32(gridY));\n      }\n    }\n\n    for (let iy: u32 = 0; iy < gridY; iy++) {\n      for (let ix: u32 = 0; ix < gridX; ix++) {\n        const a: u32 = ix + gridX1 * iy;\n        const b: u32 = ix + gridX1 * (iy + 1);\n        const c: u32 = ix + 1 + gridX1 * (iy + 1);\n        const d: u32 = ix + 1 + gridX1 * iy;\n\n        indices.push(a);\n        indices.push(b);\n        indices.push(d);\n        indices.push(b);\n        indices.push(c);\n        indices.push(d);\n      }\n    }\n\n    this.setIndexes(indices);\n    this.setAttribute(AttributeTypes.POSITION, new Float32BufferAttribute(f32Array(vertices), 3));\n    this.setAttribute(AttributeTypes.NORMAL, new Float32BufferAttribute(f32Array(normals), 3));\n    this.setAttribute(AttributeTypes.UV, new Float32BufferAttribute(f32Array(uvs), 2));\n  }\n\n  // TODO:\n  // static fromJSON( data ) {\n\n  // \treturn new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );\n\n  // }\n}\n","import { AttributeTypes, BufferGeometry } from \"../core/BufferGeometry\";\nimport { Float32BufferAttribute } from \"../core/BufferAttribute\";\nimport { Vector3 } from \"../math/Vector3\";\nimport { f32Array } from \"../utils\";\n\nexport class SphereGeometryParameters {\n  public radius: f32;\n  public widthSegments: u32;\n  public heightSegments: u32;\n  public phiStart: f32;\n  public phiLength: f32;\n  public thetaStart: f32;\n  public thetaLength: f32;\n}\n\nexport class SphereGeometry extends BufferGeometry {\n  parameters: SphereGeometryParameters;\n\n  constructor(\n    radius: f32 = 1,\n    widthSegments: u32 = 32,\n    heightSegments: u32 = 16,\n    phiStart: f32 = 0,\n    phiLength: f32 = Mathf.PI * 2,\n    thetaStart: f32 = 0,\n    thetaLength: f32 = Mathf.PI\n  ) {\n    super();\n    this.type = \"SphereGeometry\";\n\n    this.parameters = {\n      radius: radius,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      phiStart: phiStart,\n      phiLength: phiLength,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength,\n    };\n\n    widthSegments = <u32>Math.max(3, Math.floor(widthSegments));\n    heightSegments = <u32>Math.max(2, Math.floor(heightSegments));\n\n    const thetaEnd: f32 = Mathf.min(thetaStart + thetaLength, Mathf.PI);\n\n    let index: u32 = 0;\n    const grid: u32[][] = [];\n\n    const vertex = new Vector3();\n    const normal = new Vector3();\n\n    // buffers\n\n    const indices: u32[] = [];\n    const vertices: f32[] = [];\n    const normals: f32[] = [];\n    const uvs: f32[] = [];\n\n    // generate vertices, normals and uvs\n\n    for (let iy: u32 = 0; iy <= heightSegments; iy++) {\n      const verticesRow: u32[] = [];\n\n      const v: f32 = f32(iy) / f32(heightSegments);\n\n      // special case for the poles\n\n      let uOffset: f32 = 0;\n\n      if (iy == 0 && thetaStart == 0) {\n        uOffset = 0.5 / f32(widthSegments);\n      } else if (iy == heightSegments && thetaEnd == Mathf.PI) {\n        uOffset = -0.5 / f32(widthSegments);\n      }\n\n      for (let ix: u32 = 0; ix <= widthSegments; ix++) {\n        const u: f32 = f32(ix) / f32(widthSegments);\n\n        // vertex\n\n        vertex.x = -radius * Mathf.cos(phiStart + u * phiLength) * Mathf.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Mathf.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Mathf.sin(phiStart + u * phiLength) * Mathf.sin(thetaStart + v * thetaLength);\n\n        vertices.push(vertex.x);\n        vertices.push(vertex.y);\n        vertices.push(vertex.z);\n\n        // normal\n\n        normal.copy(vertex).normalize();\n        normals.push(normal.x);\n        normals.push(normal.y);\n        normals.push(normal.z);\n\n        // uv\n\n        uvs.push(u + uOffset);\n        uvs.push(1 - v);\n\n        verticesRow.push(index++);\n      }\n\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy: u32 = 0; iy < heightSegments; iy++) {\n      for (let ix: u32 = 0; ix < widthSegments; ix++) {\n        const a: u32 = grid[iy][ix + 1];\n        const b: u32 = grid[iy][ix];\n        const c: u32 = grid[iy + 1][ix];\n        const d: u32 = grid[iy + 1][ix + 1];\n\n        if (iy !== 0 || thetaStart > 0) {\n          indices.push(a);\n          indices.push(b);\n          indices.push(d);\n        }\n        if (iy !== heightSegments - 1 || thetaEnd < Mathf.PI) {\n          indices.push(b);\n          indices.push(c);\n          indices.push(d);\n        }\n      }\n    }\n\n    // build geometry\n\n    this.setIndexes(indices);\n    this.setAttribute(AttributeTypes.POSITION, new Float32BufferAttribute(f32Array(vertices), 3));\n    this.setAttribute(AttributeTypes.NORMAL, new Float32BufferAttribute(f32Array(normals), 3));\n    this.setAttribute(AttributeTypes.UV, new Float32BufferAttribute(f32Array(uvs), 2));\n  }\n\n  // static fromJSON( data ) {\n\n  // \treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n  // }\n}\n","import { Pipeline } from \"./Pipeline\";\n\nexport class MeshPipeline extends Pipeline {\n  transformResourceIndex: i32;\n  transformGroupId: i32;\n\n  constructor(name: string, index: i32) {\n    super(name, index);\n    this.transformResourceIndex = -1;\n  }\n\n  clone(): Pipeline {\n    return new MeshPipeline(this.name, this.index).copy(this);\n  }\n\n  copy(source: MeshPipeline): Pipeline {\n    super.copy(source);\n    this.transformResourceIndex = source.transformResourceIndex;\n    this.transformGroupId = source.transformResourceIndex;\n    return this;\n  }\n}\n","import { MeshPipeline } from \"../pipelines/MeshPipeline\";\nimport { BufferGeometry } from \"../core/BufferGeometry\";\nimport { Mesh } from \"../objects/Mesh\";\n\nexport function createMesh(geometry: BufferGeometry, pipeline: MeshPipeline): Mesh {\n  const newMesh = new Mesh(geometry, [pipeline]);\n  return newMesh;\n}\n\nexport { Mesh };\n","import { IBridge } from \"../../common/IBridge\";\n\nexport class BridgeManager {\n  static manager: BridgeManager | null;\n  bridge: IBridge;\n\n  constructor(bridge: IBridge) {\n    this.bridge = bridge;\n  }\n\n  static init(bridge: IBridge): BridgeManager {\n    BridgeManager.manager = new BridgeManager(bridge);\n    return BridgeManager.manager!;\n  }\n\n  static getBridge(): IBridge {\n    return BridgeManager.manager!.bridge;\n  }\n}\n","import { Link } from \"./Link\";\nimport { Node } from \"./Node\";\n\nexport class Portal {\n  node: Node;\n  name: string;\n  links: Link[];\n\n  constructor(name: string, node: Node) {\n    this.name = name;\n    this.node = node;\n    this.links = [];\n  }\n}\n","import { Portal } from \"./Portal\";\n\nexport class Link {\n  sourcePortal: Portal | null;\n  destinationPortal: Portal | null;\n\n  constructor() {\n    this.sourcePortal = null;\n    this.destinationPortal = null;\n  }\n\n  connect(source: Portal, destination: Portal): void {\n    this.sourcePortal = source;\n    this.destinationPortal = destination;\n    source.links.push(this);\n  }\n}\n","import { Object } from \"../core/Object\";\nimport { Color } from \"../math/Color\";\n\nexport class Light extends Object {\n  isLight: boolean = true;\n  color: Color;\n  intensity: f32;\n\n  constructor(color: Color, intensity: f32 = 1) {\n    super();\n\n    this.type = \"Light\";\n\n    this.color = new Color(color.r, color.g, color.b);\n    this.intensity = intensity;\n  }\n\n  dispose(): void {\n    // Empty here in base class; some subclasses override.\n  }\n\n  copy(source: Object, recursive: boolean = true): Object {\n    const lightSource = source as Light;\n    super.copy(lightSource);\n\n    this.color.copy(lightSource.color);\n    this.intensity = lightSource.intensity;\n\n    return this;\n  }\n\n  // TODO:\n  // toJSON( meta ) {\n\n  // \tconst data = super.toJSON( meta );\n\n  // \tdata.object.color = this.color.getHex();\n  // \tdata.object.intensity = this.intensity;\n\n  // \tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n  // \tif ( this.distance !== undefined ) data.object.distance = this.distance;\n  // \tif ( this.angle !== undefined ) data.object.angle = this.angle;\n  // \tif ( this.decay !== undefined ) data.object.decay = this.decay;\n  // \tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n  // \tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n  // \treturn data;\n\n  // }\n}\n","import { Light } from \"./Light\";\nimport { DirectionalLightShadow } from \"./DirectionalLightShadow\";\nimport { Object } from \"../core/Object\";\nimport { Color } from \"../math/Color\";\n\nexport class DirectionalLight extends Light {\n  target: Object;\n  shadow: DirectionalLightShadow;\n\n  constructor(color: Color, intensity: f32) {\n    super(color, intensity);\n\n    this.type = \"DirectionalLight\";\n\n    this.position.copy(Object.DefaultUp);\n\n    this.target = new Object();\n    this.shadow = new DirectionalLightShadow();\n\n    this.updateMatrix();\n  }\n\n  dispose(): void {\n    this.shadow.dispose();\n  }\n\n  copy(source: Object, recursive?: boolean): Object {\n    super.copy(source, recursive);\n\n    const sourceLight = source as DirectionalLight;\n\n    this.target = sourceLight.clone();\n    this.shadow = sourceLight.shadow.clone() as DirectionalLightShadow;\n\n    return this;\n  }\n}\n","import { Camera } from \"./Camera\";\nimport { ViewProperties } from \"./ViewProperties\";\n\nexport class OrthographicCamera extends Camera {\n  zoom: f32;\n  private view: ViewProperties | null;\n\n  left: f32;\n  right: f32;\n  top: f32;\n  bottom: f32;\n\n  near: f32;\n  far: f32;\n\n  constructor(left: f32 = -1, right: f32 = 1, top: f32 = 1, bottom: f32 = -1, near: f32 = 0.1, far: f32 = 2000) {\n    super();\n\n    this.type = \"OrthographicCamera\";\n\n    this.zoom = 1;\n    this.view = null;\n\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n\n    this.near = near;\n    this.far = far;\n\n    this.updateProjectionMatrix();\n  }\n\n  copy(source: OrthographicCamera, recursive: boolean = true): OrthographicCamera {\n    super.copy(source, recursive);\n\n    this.left = source.left;\n    this.right = source.right;\n    this.top = source.top;\n    this.bottom = source.bottom;\n    this.near = source.near;\n    this.far = source.far;\n\n    this.zoom = source.zoom;\n    this.view = source.view == null ? null : new ViewProperties(source.view);\n\n    return this;\n  }\n\n  setViewOffset(fullWidth: f32, fullHeight: f32, x: f32, y: f32, width: f32, height: f32): void {\n    if (this.view == null) {\n      this.view = new ViewProperties(null);\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n\n    this.updateProjectionMatrix();\n  }\n\n  clearViewOffset(): void {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n\n    this.updateProjectionMatrix();\n  }\n\n  updateProjectionMatrix(): void {\n    const dx = (this.right - this.left) / (2 * this.zoom);\n    const dy = (this.top - this.bottom) / (2 * this.zoom);\n    const cx = (this.right + this.left) / 2;\n    const cy = (this.top + this.bottom) / 2;\n\n    let left = cx - dx;\n    let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n\n    if (this.view !== null && this.view!.enabled) {\n      const scaleW = (this.right - this.left) / this.view!.fullWidth / this.zoom;\n      const scaleH = (this.top - this.bottom) / this.view!.fullHeight / this.zoom;\n\n      left += scaleW * this.view!.offsetX;\n      right = left + scaleW * this.view!.width;\n      top -= scaleH * this.view!.offsetY;\n      bottom = top - scaleH * this.view!.height;\n    }\n\n    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);\n\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n\n  // toJSON( meta ) {\n\n  // \tconst data = super.toJSON( meta );\n\n  // \tdata.object.zoom = this.zoom;\n  // \tdata.object.left = this.left;\n  // \tdata.object.right = this.right;\n  // \tdata.object.top = this.top;\n  // \tdata.object.bottom = this.bottom;\n  // \tdata.object.near = this.near;\n  // \tdata.object.far = this.far;\n\n  // \tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n  // \treturn data;\n\n  // }\n}\n","import { LightShadow } from \"./LightShadow\";\nimport { OrthographicCamera } from \"../cameras/OrthographicCamera\";\n\nexport class DirectionalLightShadow extends LightShadow {\n  constructor() {\n    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n  }\n}\n","import { Color } from \"../math/Color\";\nimport { Light } from \"./Light\";\n\nexport class AmbientLight extends Light {\n  constructor(color: Color, intensity: f32) {\n    super(color, intensity);\n\n    this.type = \"AmbientLight\";\n  }\n}\n","/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n * The azimuthal angle (theta) is measured from the positive z-axis.\n */\n\nimport * as MathUtils from \"./MathUtils\";\nimport { Vector3 } from \"./Vector3\";\n\nexport class Spherical {\n  radius: f32;\n  phi: f32;\n  theta: f32;\n\n  constructor(radius: f32 = 1, phi: f32 = 0, theta: f32 = 0) {\n    this.radius = radius;\n    this.phi = phi; // polar angle\n    this.theta = theta; // azimuthal angle\n\n    return this;\n  }\n\n  set(radius: f32, phi: f32, theta: f32): Spherical {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n\n    return this;\n  }\n\n  copy(other: Spherical): Spherical {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n\n    return this;\n  }\n\n  // restrict phi to be betwee EPS and PI-EPS\n  makeSafe(): Spherical {\n    const EPS: f32 = 0.000001;\n    this.phi = Mathf.max(EPS, Mathf.min(Mathf.PI - EPS, this.phi));\n\n    return this;\n  }\n\n  setFromVector3(v: Vector3): Spherical {\n    return this.setFromCartesianCoords(v.x, v.y, v.z);\n  }\n\n  setFromCartesianCoords(x: f32, y: f32, z: f32): Spherical {\n    this.radius = Mathf.sqrt(x * x + y * y + z * z);\n\n    if (this.radius === 0) {\n      this.theta = 0;\n      this.phi = 0;\n    } else {\n      this.theta = Mathf.atan2(x, z);\n      this.phi = Mathf.acos(MathUtils.clamp(y / this.radius, -1, 1));\n    }\n\n    return this;\n  }\n\n  clone(): Spherical {\n    return new Spherical().copy(this);\n  }\n}\n","import { DirectionalLight } from \"../../../lights/DirectionalLight\";\nimport { Color } from \"../../../math/Color\";\nimport { Container } from \"../core/Container\";\nimport { uiSignaller } from \"../../../exports/ui/uiSignalManager\";\nimport { Listener } from \"../../../core/EventDispatcher\";\nimport { Event } from \"../../../core/Event\";\nimport { UIEvent } from \"../../../exports/ui/UIEvent\";\nimport { degToRad } from \"../../../math/MathUtils\";\nimport { Link } from \"../core/Link\";\nimport { print } from \"../../../Imports\";\nimport { UIEventType } from \"../../../../common/UIEventType\";\n\nexport class MainMenu extends Container implements Listener {\n  private sun!: DirectionalLight;\n\n  constructor() {\n    super(\"MainMenu\");\n  }\n\n  init(): void {\n    super.init();\n    const link = new Link();\n    const level1 = this.runtime!.getNode(\"Level1\");\n\n    if (!level1) print(`dont have level`);\n    link.connect(this.getPortal(\"Exit\")!, level1!.getPortal(\"Enter\")!);\n\n    this.sun = new DirectionalLight(new Color(1, 1, 1), 6);\n    this.sun.position.set(10, 10, 0);\n    this.sun.target.position.set(0, 0, 0);\n    this.addAsset(this.sun);\n  }\n\n  onEvent(event: Event): void {\n    const uiEvent = event.attachment as UIEvent;\n    if (uiEvent.eventType == UIEventType.StartGame) this.exit(this.getPortal(\"Exit\")!, true);\n  }\n\n  onUpdate(delta: f32, total: u32, fps: u32): void {\n    this.objects[0].rotation.y += delta * 0.1;\n  }\n\n  mount(): void {\n    super.mount();\n\n    this.runtime!.camera.position.set(0, 5, 10);\n    this.runtime!.camera.lookAt(0, 0, 0);\n\n    this.objects[0].position.set(0, -40, -50);\n    this.objects[0].scale.set(30, 30, 30);\n    this.objects[0].rotation.x = degToRad(180);\n\n    uiSignaller.addEventListener(\"uievent\", this);\n  }\n\n  unMount(): void {\n    super.unMount();\n    uiSignaller.removeEventListener(\"uievent\", this);\n  }\n}\n\nexport function createMainMenu(): MainMenu {\n  return new MainMenu();\n}\n","import { Color } from \"../math/Color\";\n\nexport class Fog {\n  isFog: boolean = true;\n  name: string;\n  color: Color;\n  near: f32;\n  far: f32;\n\n  constructor(color: Color, near: f32 = 1, far: f32 = 1000) {\n    this.name = \"\";\n    this.color = new Color(color.r, color.g, color.b);\n    this.near = near;\n    this.far = far;\n  }\n\n  clone(): Fog {\n    return new Fog(this.color, this.near, this.far);\n  }\n\n  // TODO:\n  //   toJSON() {\n  //     return {\n  //       type: \"Fog\",\n  //       color: this.color.getHex(),\n  //       near: this.near,\n  //       far: this.far,\n  //     };\n  //   }\n}\n","export class ViewProperties {\n  enabled: boolean;\n  fullWidth: f32;\n  fullHeight: f32;\n  offsetX: f32;\n  offsetY: f32;\n  width: f32;\n  height: f32;\n\n  constructor(source: ViewProperties | null) {\n    this.enabled = source ? source.enabled : true;\n    this.fullWidth = source ? source.fullWidth : 1;\n    this.fullHeight = source ? source.fullHeight : 1;\n    this.offsetX = source ? source.offsetX : 0;\n    this.offsetY = source ? source.offsetY : 0;\n    this.width = source ? source.width : 1;\n    this.height = source ? source.height : 1;\n  }\n}\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}